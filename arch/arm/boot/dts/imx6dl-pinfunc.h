                            (alle anderen m√∂glichen Einstiegspunkte werden ignoriert) (Kurz-
                              form: -m).
-fullpaths                    Der Compiler generiert vollqualifizierte Pfade.
-filealign:<n>                Gibt die Ausrichtung an, die f√ºr Ausgabedateiabschnitte
                              verwendet werden soll.
-pathmap:<K1>=<V1>,<K2>=<V2>,...
                              Gibt eine Zuordnung f√ºr die Quellpfadnamen an, die vom
                              Compiler ausgegeben werden.
-pdb:<Datei>                   Gibt den Namen der Debuginformationsdatei an (Standard:
                              Ausgabe des Dateinamens mit PDB-Erweiterung).
-errorendlocation             Gibt f√ºr jeden Fehler die Zeile und Spalte
                              des Endpunkts aus.
-preferreduilang              Gibt den Namen der bevorzugten Ausgabesprache an.
-nosdkpath                    Deaktiviert die Suche nach dem SDK-Standardpfad f√ºr Standardbibliotheksassemblys.
-nostdlib[+|-]                Kein Verweis auf die Standardbibliothek (mscorlib.dll).
-subsystemversion:<Zeichenfolge>    Gibt die Subsystemversion dieser Assembly an.
-lib:<Dateiliste>              Gibt zus√§tzliche Verzeichnisse an, in denen nach Verweisen
                              gesucht werden soll.
-errorreport:<Zeichenfolge>         Gibt die Verarbeitung interner Compilerfehler an:
                              "prompt", "send", "queue" oder "none". Der Standardwert lautet
                              "queue".
-appconfig:<Datei>             Gibt eine Anwendungskonfigurationsdatei
                              mit Assemblybindungseinstellungen an.
-moduleassemblyname:<Zeichenfolge>  Der Name der Assembly, zu der dieses Modul
                              geh√∂ren wird.
-modulename:<Zeichenfolge>          Gibt den Quellmodulnamen an.
-generatedfilesout:<dir>      Platziert die beim Kompiliervorgang generierten Dateien
                              im angegebenen Verzeichnis.
Sammlungcontravariantcontravariant	covariant	covariant%Standardschnittstellenimplementierung$Das Verzeichnis ist nicht vorhanden.$Der Pfad ist zu lang oder ung√ºltig.
Verwerfbarfixed-Variableforeach-Iterationsvariable5Alternative interpolierte ausf√ºhrliche Zeichenfolgen
and-MusterAnonyme Methodenanonyme TypenAsync-Funktionasynchrones HauptelementAsynchrone Streamsasynchrone using-Anweisungauto default struct fields(automatisch implementierte Eigenschaften)Automatische Eigenschafteninitialisierungbin√§re Literalechecked user-defined operatorsZusammenf√ºgungszuweisungSammlungsinitialisierer%Konstante interpolierte ZeichenfolgenCovariante R√ºckgabenStandardoperatorStandardliteral+Parametereinschr√§nkungen vom Typ "default"-Generische Typeneinschr√§nkungen f√ºr DelegatW√∂rterbuchinitialisiererZifferntrennzeichenAusschussvariablenMusterbasierte Entsorgung	Dynamisch1Generische Typeneinschr√§nkungen f√ºr EnumerationAusnahmefilter1Eigenschaftszugriffsmethode f√ºr Ausdrucksk√∂rper0Konstruktor und Destruktor f√ºr Ausdrucksk√∂rperAusdrucksk√∂rperindexerAusdrucksk√∂rpermethodeAusdrucksk√∂rpereigenschaftHDeklaration von Ausdrucksvariablen in Memberinitialisierern und AbfragenErweiterte partielle Methoden$Muster f√ºr erweiterte EigenschaftenErweiterbare fixed-Anweisung Erweiterung "GetAsyncEnumerator"Erweiterung "GetEnumerator"Erweiterungsmethodeexterner AliasExterne lokale FunktionenDateibereichsnamespacePuffer fester Gr√∂√üeFunktionszeigerGenerische AttributeGenerikaNamespacealias-Qualifiziererglobale using-Anweisungimplizit typisiertes Array#implizit typisierte lokale VariableObjekterstellung mit Zieltyp)Handler einer interpolierten ZeichenfolgeIndexoperator2Bewegliche Puffer fester Gr√∂√üe werden indiziert.abgeleiteter Delegattypinit-only-SetterInterpolierte Zeichenfolgen
IteratorenLambdaausdruckLambdaattribute*Parameter zum Verwerfen von LambdafunktionLambda-R√ºckgabetyp(Trennzeichen f√ºr vorangestellte ZiffernZeilenabstand-AnweisungListenmusterAttribute lokaler Funktionenlokale FunktionenMemberNotNull-Attribut<Gemischte Deklarationen und Ausdr√ºcke in der Dekonstruktion#Modul als AttributzielspezifiziererModulinitialisierer,Namensshadowing in geschachtelten Funktionenbenanntes Argumentnameof-OperatorInteger-Werte nativer Gr√∂√üe*"stackalloc" in geschachtelten Ausdr√ºcken"Zeilenumbr√ºche in Interpolationen+notnull-Einschr√§nkung f√ºr generischen Typ
not-Muster"Muster f√ºr NULL-Zeiger-KonstantenNull-progagierender OperatorTypen, die NULL-Werte zulassenNullable-VerweistypenObjektinitialisierer#veraltet f√ºr Eigenschaftenaccessoroptionaler Parameter	or-Musterout-Variablendeklaration#Parameterlose Strukturkonstruktorenin Klammern gesetztes Musterpartielle Methodepartielle TypenMusterabgleichPositionsfelder in Datens√§tzen#pragmaWarnungsaktion "enable"privat gesch√ºtzt'Zugriffsmodifizierer f√ºr EigenschaftenAbfrageausdruckBereichsoperatorRohzeichenfolgenliteralereadonly-Memberschreibgesch√ºtzte Verweiseschreibgesch√ºtzte Strukturen;Schreibgesch√ºtzte automatisch implementierte EigenschaftenDatensatzstrukturenDatens√§tzeRekursive MusterBedingter ref-AusdruckReferenzerweiterungsmethodenVerweis auf for-loop-Variablen'Verweis auf foreach-Iterationsvariablen$Lokale byref-Elemente und R√ºckgabenref-NeuzuweisungReferenzstrukturenrelationales Muster#versiegelte "ToString" im Datensatz7pattern matching ReadOnly/Span<char> on constant stringstackalloc-Initialisierer,Statische abstrakte Member in SchnittstellenStatische anonyme Funktionstatische KlassenStatische lokale FunktionenStrukturfeldinitialisierer<switch-Ausdruck>Schalter f√ºr booleschen TypBedingter Ausdruck mit Zieltypthrow-AusdruckTupelgleichheitTupel	Typmuster
TypvarianzUtf8 String Literals?Uneingeschr√§nkte Typparameter in NULL-Zusammenf√ºgungsoperator#nicht verwaltete konstruierte Typen1Nicht verwaltete generische Typeneinschr√§nkungenunsigned right shiftUsing-Deklarationenverwendet statische5Varianzsicherheit f√ºr statische Schnittstellenmember"with" in anonymen Typen"with" in Strukturen<globaler Namespace>	invariantLIB-UmgebungsvariableOption "/LIB"LambdaausdruckUnterst√ºtzte Sprachversionen:{0} Version {1}=Copyright (C) Microsoft Corporation. Alle Rechte vorbehalten.Methodengruppe<NULL><Namespace>.Der Vorgang verursachte einen Stapel√ºberlauf.]Einschr√§nkungen f√ºr Au√üerkraftsetzung und explizite Schnittstellenimplementierungsmethoden	Parameter!NULL-√úberpr√ºfung des Parameters<Pfadliste>/REFERENCEPATH-Option1(Position des Symbols f√ºr den vorherigen Fehler)1(Position des Symbols f√ºr die vorherige Warnung)	R√ºckgabeusing-AliasKonstruktorEreignisexterner AliasFeldBezeichnungMethode	NamespaceEigenschaftTypTypparameterElementVariable<Text>throw-Ausdruck Microsoft (R) Visual C# CompilerAnweisungen der obersten Ebeneusing-Variable'"experimentell" Ung√ºltiges Include-Tag U Der enthaltene XML-Abschnitt konnte nur teilweise oder gar nicht eingef√ºgt werden. :<!-- Badly formed XML comment ignored for member "{0}" -->@ Ung√ºltiger XML-Code. Datei "{0}" kann nicht einbezogen werden.Dateiattribut fehltPfadattribut fehltO F√ºr folgendes Include-Tag wurden keine √ºbereinstimmenden Elemente gefunden. mEinige Typen werden in der Analyzer-Assembly {0} aufgrund von ReflectionTypeLoadException √ºbersprungen: {1}.~Das Laden von Typen in der Analyseassembly √ºberspringen, bei denen durch eine ReflectionTypeLoadException ein Fehler auftrat.ÑGetDeclarationName wurde f√ºr einen Deklarationsknoten aufgerufen, der m√∂glicherweise mehrere Variablendeklaratoren enthalten kann."Elemente: D√ºrfen nicht leer sein.DF√ºr eine minimale Typqualifizierung muss der Pfad angegeben werden.ALookupOptions weist eine ung√ºltige Kombination von Optionen auf.Namenskonflikt f√ºr Name {0}.SearchCriteria wird erwartet.Kein C#-Symbol.yAngegeben wurden {0} Parametertypen und {1} Arten von Parameterverweisen. Diese Arrays m√ºssen dieselbe L√§nge aufweisen.D"RefKind.Out" ist keine g√ºltige Verweisart f√ºr einen R√ºckgabetyp.IDie Position ist nicht innerhalb des Syntaxbaums mit dem Vollbereich {0}.2Die Position muss im Bereich des Syntaxbaums sein.`Der zu analysierende Syntaxknoten kann nicht zum Syntaxbaum der aktuellen Kompilierung geh√∂ren./Es kann nur ein Syntaxbaum √ºbermittelt werden.+Es kann nur Skriptcode √ºbermittelt werden..Der Syntaxknoten geh√∂rt nicht zum Syntaxbaum.%Der Syntaxbaum ist bereits vorhanden.eSyntaxTree ist das Ergebnis einer #load-Direktive und kann nicht direkt entfernt oder ersetzt werden.>Der Syntaxbaum sollte aus einer √úbermittlung erstellt werden.*SyntaxTree ist kein Teil der Kompilierung.OSyntaxTree ist kein Teil der Kompilierung und kann daher nicht entfernt werden.SF√ºr eine minimale Typqualifizierung muss SyntaxTreeSemanticModel angegeben werden.VDiese Methode kann nur zum Erstellen von Token verwendet werden. "{0}" ist kein Token.IDer Baum muss einen Stammknoten mit SyntaxKind.CompilationUnit aufweisen.)Der Baum ist nicht Teil der Kompilierung.%Das Typargument kann nicht NULL sein.oVerwenden Sie "Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Literal" zum Erstellen von numerischen Literaltoken.jVerwenden Sie "Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Literal" zum Erstellen von Zeichenliteraltoken.ØVerwenden Sie "Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Identifier" oder "Microsoft.CodeAnalysis.CSharp.SyntaxFactory.VerbatimIdentifier" zum Erstellen von Bezeichnertoken.oAusrichtungswert {0} hat einen Wert gr√∂√üer {1} und kann eine gro√üe formatierte Zeichenfolge zur Folge haben.kDer Ausrichtungswert weist eine Gr√∂√üe auf, die eine gro√üe formatierte Zeichenfolge zur Folge haben kann.8Das Ergebnis des Ausdrucks ist immer NULL vom Typ "{0}"..Das Ergebnis des Ausdrucks lautet immer 'null'•Mehrdeutiger Verweis in cref-Attribut: "{0}". "{1}" wird angenommen, es sind jedoch auch √úbereinstimmungen mit anderen √úberladungen einschlie√ülich "{2}" m√∂glich.%Zweideutige Referenz im cref-AttributGEine Instanz des {0}-Analyzers kann nicht aus {1} erstellt werden: {2}..Es konnte keine Analyseinstanz erstellt werdencDie Assembly "{0}" mit dem Typ "{1}" verweist auf das .NET Framework. Dies wird nicht unterst√ºtzt.TDie geladene Assembly verweist auf das .NET Framework. Dies wird nicht unterst√ºtzt.iDas Attribut "{0}" aus dem Modul "{1}" wird ignoriert, stattdessen wird die Instanz der Quelle verwendet.YAttribut wird ignoriert, damit die in der Quelle angezeigte Instanz bevorzugt werden kann˜"{0}" (lokal) dient als Argument f√ºr eine using- oder lock-Anweisung, hat jedoch m√∂glicherweise einen falschen Wert zugewiesen bekommen. Der Dispose-Aufruf bzw. das Aufheben der Sperre erfolgt f√ºr den urspr√ºnglichen Wert der lokalen Variablen.rM√∂glicherweise falsche Zuweisung zur lokalen Ressource, die das Argument zu einer using- oder lock-Anweisung ist.QZuweisung zur gleichen Variablen. Wollten Sie eine andere Zuweisung durchf√ºhren?9Die Zuweisung wurde f√ºr dieselbe Variable durchgef√ºhrt.∑In dieser Async-Methode fehlen die "await"-Operatoren, weshalb sie synchron ausgef√ºhrt wird. Sie sollten die Verwendung des "await"-Operators oder von "await Task.Run(...)" in Betracht ziehen, um auf nicht blockierende API-Aufrufe zu warten bzw. CPU-gebundene Aufgaben auf einem Hintergrundthread auszuf√ºhren.]Bei der asynchronen Methode fehlen "await"-Operatoren. Die Methode wird synchron ausgef√ºhrt.nDer Typ "{0}" kann in diesem Kontext nicht verwendet werden, da er nicht in Metadaten dargestellt werden kann.lDer Typ kann in diesem Kontext nicht verwendet werden, da er nicht in den Metadaten dargestellt werden kann.ODas Attribut "{0}" wird ignoriert, wenn √∂ffentliche Signierung angegeben wird.IDas Attribut wird ignoriert, wenn √∂ffentliche Signierung angegeben wird.®"{0}" ist kein g√ºltiger Attributpfad f√ºr diese Deklaration. G√ºltige Attributpfade f√ºr diese Deklaration sind "{1}". Alle Attribute in diesem Block werden ignoriert.HF√ºr diese Deklaration ist kein g√ºltiger Atttributspeicherort vorhandenüAuf Felder ausgerichtete Attribute f√ºr automatische Eigenschaften werden in Sprachversion {0} nicht unterst√ºtzt. Verwenden Sie Sprachversion {1} oder h√∂her.uAuf Felder ausgerichtete Attribute f√ºr automatische Eigenschaften werden in dieser Sprachversion nicht unterst√ºtzt.zUnbeabsichtigter Verweisvergleich. Wandeln Sie die linke Seite in den Typ "{0}" um, um einen Wertvergleich durchzuf√ºhren.SM√∂glicher unbeabsichtigter Referenzvergleich; linke Seite muss umgewandelt werden.{Unbeabsichtigter Verweisvergleich. Wandeln Sie die rechte Seite in den Typ "{0}" um, um einen Wertvergleich durchzuf√ºhren.SM√∂glicher unbeabsichtigter Referenzvergleich; rechte Seite muss umgewandelt werdenYDie Warnung "CS{0}" kann nicht wiederhergestellt werden, da sie global deaktiviert wurde.OWarnung konnte nicht wiederhergestellt werden, da sie global deaktiviert wurde.%Der Sprachenname "{0}" ist ung√ºltig.Der Sprachenname ist ung√ºltig.("{0}" ist keine g√ºltige Warnungsnummer.¬Eine Zahl, die an die Pr√§prozessordirektive der #pragma-Warnung √ºbergeben wurde, war keine g√ºltige Warnungszahl. Vergewissern Sie sich, dass die Zahl eine Warnung und keinen Fehler darstellt.Keine g√ºltige Warnungszahl.WDer XML-Kommentar enth√§lt ein cref-Attribut "{0}", das nicht aufgel√∂st werden konnte:QUng√ºltiger Typ f√ºr den {0}-Parameter im cref-Attribut des XML-Kommentars: "{1}"GUng√ºltiger Typ f√ºr den Parameter im XML-Kommentar des cref-Attributs.=Ung√ºltiger R√ºckgabetyp im cref-Attribut des XML-Kommentars.=Ung√ºltiger R√ºckgabetyp im cref-Attribut des XML-Kommentars.GDer XML-Kommentar enth√§lt ein cref-Attribut "{0}" mit falscher Syntax.?XML-Kommentar weist ein syntaktisch falsches cref-Attribut auf.XDer XML-Kommentar enth√§lt ein cref-Attribut "{0}", das auf einen Typparameter verweist.SXML-Kommentar weist ein cref-Attribut auf, das sich auf einen Typparameter bezieht.NXML-Kommentar weist ein cref-Attribut auf, das nicht aufgel√∂st werden konnte.¨Bitweiser OR-Operator wird f√ºr einen signaturerweiterten Operanden verwendet. Es wird empfohlen, zuerst eine Umwandlung in einen kleineren unsignierten Typ durchzuf√ºhren.«Der Compiler hat eine Variable implizit und signaturerweitert. Anschlie√üend hat er den daraus resultierenden Wert in einem bitweisen OR-Vorgang verwendet. Das kann zu unerwartetem Verhalten f√ºhren.SBitweiser OR-Operator, der bei einem signaturerweiterten Operanden verwendet wurde.¬Das Verwenden von "{0}" als ref- oder out-Wert bzw. das Annehmen der Adresse kann zu einer Laufzeitausnahme f√ºhren, weil es sich hierbei um ein Feld einer "Marshal by Reference"-Klasse handelt.úDas Verwenden eines Felds einer "Marshal by Reference"-Klasse als ref- oder out-Wert bzw. das Annehmen seiner Adresse kann zu einer Laufzeitausnahme f√ºhrenóRufen Sie System.IDisposable.Dispose() f√ºr die zugeordnete Instanz von "{0}" auf, bevor alle Verweise darauf au√üerhalb des g√ºltigen Bereichs liegen.çDer Aufruf System.IDisposable.Dispose() zu der zugeordneten Instanz vor allen Verweisen dazu befinden sich au√üerdem des zul√§ssigen Bereichs≈Die zugeordnete Instanz von "{0}" wird nicht entlang allen Ausnahmepfaden verworfen. Rufen Sie System.IDisposable.Dispose() auf, bevor alle Verweise darauf au√üerhalb des g√ºltigen Bereichs liegen.KZugeordnete Instanz wird nicht zusammen mit allen Ausnahmepfaden zugeordnet4Das Objekt "{0}" kann mehrere Male verworfen werden.&Objekt kann mehrmals zugeordnet werden7Arrays als Attributargumente sind nicht CLS-kompatibel.7Arrays als Attributargumente sind nicht CLS-kompatibel.h"{0}" kann nicht als CLS-kompatibel markiert werden, da die Assembly kein CLSCompliant-Attribut besitzt.`"{0}" erfordert kein CLSCompliant-Attribut, da die Assembly kein CLSCompliant-Attribut aufweist.iTyp oder Element ben√∂tigt kein CLSCompliant-Attribut, da die Assembly kein CLSCompliant-Attribut besitztrTyp oder Element kann nicht als CLS-kompatibel markiert werden, da die Assembly kein CLSCompliant-Attribut besitzt+Argumenttyp "{0}" ist nicht CLS-kompatibel.$Argumenttyp ist nicht CLS-kompatibelS"{0}" hat keine zugreifbaren Konstruktoren, die nur CLS-kompatible Typen verwenden.UTyp besitzt keine zug√§nglichen Konstruktoren, die nur CLS-kompatible Typen verwenden/"{0}": Basistyp "{1}" ist nicht CLS-kompatibel.ÿEin Basistyp wurde so gekennzeichnet, dass er nicht mit der Common Language Specification (CLS) in einer Assembly kompatibel sein muss, die als CLS.kompatibel markiert wurde. Entfernen Sie entweder das Attribut, das angibt, dass die Assembly CLS-kompatibel ist oder entfernen Sie das Attribut, das angibt, dass der Typ nicht CLS-kompatibel ist.!Basistyp ist nicht CLS-kompatibel+Der Typ von "{0}" ist nicht CLS-kompatibel.òEine √∂ffentliche, gesch√ºtzte oder eine interne, gesch√ºtzte Variable muss ein Typ sein, dermit der Common Language Specification (CLS) kompatibel ist.Typ ist nicht CLS-kompatibel.Der Bezeichner "{0}" ist nicht CLS-kompatibel.wDer Bezeichner "{0}", der sich nur hinsichtlich der Gro√ü- und Kleinschreibung unterscheidet, ist nicht CLS-kompatibel.9Bezeichner weist nur ab, wenn er nicht CLS-kompatibel ist#Bezeichner ist nicht CLS-kompatibelY"{0}" ist nicht CLS-kompatibel, da die Basisschnittstelle "{1}" nicht CLS-kompatibel ist.Q"{0}": CLS-kompatible Schnittstellen d√ºrfen nur CLS-kompatible Member aufweisen.JCLS-kompatible Schnittstellen d√ºrfen nur CLS-kompatible Elemente besitzenPTyp ist nicht CLS-kompatibel, da die Basisschnittstelle nicht CLS-kompatibel ist4Der R√ºckgabetyp von "{0}" ist nicht CLS-kompatibel.%R√ºckgabetyp ist nicht CLS-kompatibel2Einschr√§nkungstyp "{0}" ist nicht CLS-kompatibel.+Einschr√§nkungstyp ist nicht CLS-kompatibelr"{0}" ist ein Member des nicht CLS-kompatiblen Typs "{1}" und kann daher nicht als CLS-kompatibel markiert werden.VTyp kann nicht als CLS-kompatibel, da es ein Element des Typs nicht CLS-kompatibel istÉDas CLSCompliant-Attribut hat keine Bedeutung, wenn es auf Parameter angewendet wird. Wenden Sie es stattdessen auf die Methode an.TCLSCompliant-Attribut hat keine Bedeutung, wenn es auf die Parameter angewendet wirdpDie CLS-Kompatibilit√§tspr√ºfung wird nicht f√ºr "{0}" ausgef√ºhrt (ist au√üerhalb der Assembly nicht sichtbar).vDie CLS-Kompatibilit√§ts√ºberpr√ºfung wird nicht ausgef√ºhrt, da sie von au√üerhalb dieser Assembly nicht sichtbar istàDas CLSCompliant-Attribut hat keine Bedeutung, wenn es auf R√ºckgabetypen angewendet wird. Wenden Sie es stattdessen auf die Methode an.]Das CLSCompliant-Attribut hat keine Bedeutung, wenn es auf die R√ºckgabetypen angewendet wirdwHinzugef√ºgte Module m√ºssen mit dem CLSCompliant-Attribut markiert werden, damit sie mit der Assembly √ºbereinstimmen.wHinzugef√ºgte Module m√ºssen mit dem CLSCompliant-Attribut markiert werden, damit sie mit der Assembly √ºbereinstimmen.7"{0}": Nur CLS-kompatible Member k√∂nnen abstrakt sein.1Nur CLS-kompatible Elemente k√∂nnen abstrakt sein;Methoden mit Variablenargumenten sind nicht CLS-kompatibel.;Methoden mit Variablenargumenten sind nicht CLS-kompatibel.ÄSie m√ºssen das CLSCompliant-Attribut in der Assembly statt im Modul angeben, um die CLS-Kompatibilit√§tspr√ºfung zu aktivieren.ÑDas CLSCompliant-Attribut kann nicht f√ºr ein Modul angegeben werden, das sich vom CLSCompliant-Attribut der Assembly unterscheidet.ÑDas CLSCompliant-Attribut kann nicht f√ºr ein Modul angegeben werden, das sich vom CLSCompliant-Attribut der Assembly unterscheidet.ÄSie m√ºssen das CLSCompliant-Attribut in der Assembly statt im Modul angeben, um die CLS-Kompatibilit√§tspr√ºfung zu aktivieren.xDie √ºberladene {0}-Methode, die sich nur nach "ref" , "out" oder dem Arrayrang unterscheidet, ist nicht CLS-kompatibel.ÑDie √ºberladene Methode weicht nur hinsichtlich des Verweises oder der Ausgabe ab, oder des Arrayrangs, und ist nicht CLS-kompatibelnDie √ºberladene {0}-Methode, die sich nur durch unbenannte Arraytypen unterscheidet, ist nicht CLS-kompatibel.∏Dieser Fehler tritt auf, wenn Sie eine √ºberladene Methode besitzen, die ein verzweigtes Array aufnimmt, liegt der einzige Unterschied zwischen den Methodensignaturen im Elementtyp des Arrays. Um diesen Fehler zu vermeiden, sollte ein rechteckiges Array in Betracht gezogen werden, statt eines verzweigten Arrays; verwenden Sie einen zus√§tzlichen Parameter, um den Funktionsaufruf eindeutig zu machen; benennen Sie eine oder mehrere der √ºberladenen Methoden um; oder falls keine CLS-Kompatibilit√§t erforderlich ist, entfernen Sie das CLSCompliantAttribute-Attribut.nDie √ºberladene Methode unterscheidet sich nur darin, dass nicht benannte Arraytypen nicht CLS-kompatibel sind8Das CLS-kompatible Feld "{0}" kann nicht fl√ºchtig sein..CLS-kompatibles Feld kann nicht tempor√§r seinúDas Zugreifen auf einen Member auf "{0}" kann zu einer Laufzeitausnahme f√ºhren, da es sich hierbei um ein Feld einer "Marshal by Reference"-Klasse handelt.îDiese Warnung tritt auf, wenn Sie versuchen eine Methode, Eigenschaft oder einen Indexer eines Elements einer Klasse aufzurufen, die vom MarshalByRefObject abgeleitet wird, und es sich bei dem Element um einen Werttyp handelt. Objekte, die vom MarshalByRefObject vererbt werden, dienen in der Regel dazu, als Verweis in einer Anwendungsdom√§ne gemarshallt zu werden. Wenn √ºber den Code versucht wird, direkt auf das Werttypelement eines solchen Objekts einer Anwendungsdom√§ne zuzugreifen, tritt eine Laufzeitausnahme auf. Um diese Warnung zu beheben, kopieren Sie zun√§chst das Element in eine lokale Variable und rufen Sie dann die Methode der Variable auf.{Beim Zugriff auf ein Element zu einem Feld einer "Marshal by Reference"-Klasse kann eine Laufzeitausnahme ausgel√∂st werden®Das CallerArgumentExpressionAttribute, das auf den Parameter ‚Äû{0}‚Äú angewendet wird, hat keine Auswirkungen. Es wird mit einem ung√ºltigen Parameternamen angewendet.[Das CallerArgumentExpressionAttribute wird mit einem ung√ºltigen Parameternamen angewendet.ùDas auf den Parameter "{0}" angewendete CallerArgumentExpressionAttribute hat keine Auswirkungen, da es sich um einen selbstreferenziellen Parameter handelt.úDas CallerArgumentExpressionAttribute, das auf den Parameter angewendet wird, hat keine Auswirkungen, da es sich um einen selbstreferenziellen Wert handelt.ºDas auf Parameter ‚Äû{0}‚Äú angewendete CallerArgumentExpressionAttribute hat keine Auswirkung, da es auf ein Element in Kontexten angewendet wird, die keine optionalen Argumente zulassen.•Das CallerArgumentExpressionAttribute hat keine Auswirkungen, da es f√ºr einen Element gilt, das in Kontexten verwendet wird, die keine optionalen Argumente zulassenÕDas auf den Parameter "{0}" angewendete "CallerFilePathAttribute" besitzt keine Auswirkungen, weil es f√ºr einen Member gilt, der in Kontexten verwendet wird, in denen optionale Argumente unzul√§ssig sind.©Das "CallerFilePathAttribute" besitzt keine Auswirkungen, weil es f√ºr einen Member gilt, der in Kontexten verwendet wird, in denen optionale Argumente unzul√§ssig sind.ïDas auf den Parameter "{0}" angewendete CallerArgumentExpressionAttribute hat keine Auswirkungen. Es wird vom CallerFilePathAttribute √ºberschrieben.qDas CallerArgumentExpressionAttribute hat keine Auswirkungen. Es wird vom CallerFilePathAttribute √ºberschrieben.áDas auf Parameter "{0}" angewendete CallerMemberNameAttribute hat keine Auswirkung. Es wird vom CallerFilePathAttribute √ºberschrieben.jDas CallerMemberNameAttribute hat keine Auswirkung; es wird von dem CallerFilePathAttribute √ºberschrieben±Das auf Parameter "{0}" angewendete CallerLineNumberAttribute hat keine Auswirkung, da es auf einen Member in Kontexten angewendet wird, die keine optionalen Argumente zulassen.õDas CallerLineNumberAttribute hat keine Auswirkungen, da es f√ºr ein Element gilt, das in Kontexten verwendet wird, die keine optionalen Argumente zulassenïDas auf Parameter ‚Äû{0}‚Äú angewendete CallerArgumentExpressionAttribute hat keine Auswirkung. Es wird vom CallerLineNumberAttribute √ºberschrieben.vDas CallerArgumentExpressionAttribute hat keine Auswirkungen. Es wird von dem CallerLineNumberAttribute √ºberschriebenáDas auf Parameter "{0}" angewendete CallerFilePathAttribute hat keine Auswirkung. Es wird vom CallerLineNumberAttribute √ºberschrieben.lDas CallerFilePathAttribute hat keine Auswirkungen; es wird von dem CallerLineNumberAttribute √ºberschriebenâDas auf Parameter "{0}" angewendete CallerMemberNameAttribute hat keine Auswirkung. Es wird vom CallerLineNumberAttribute √ºberschrieben.nDas CallerMemberNameAttribute hat keine Auswirkungen; es wird von dem CallerLineNumberAttribute √ºberschrieben±Das auf Parameter "{0}" angewendete CallerMemberNameAttribute hat keine Auswirkung, da es auf einen Member in Kontexten angewendet wird, die keine optionalen Argumente zulassen.úDas CallerMemberNameAttribute hat keine Auswirkungen, da es f√ºr einen Member gilt, das in Kontexten verwendet wird, die keine optionalen Argumente zulassenïDas auf Parameter ‚Äû{0}‚Äú angewendete CallerArgumentExpressionAttribute hat keine Auswirkung. Es wird vom CallerMemberNameAttribute √ºberschrieben.vDas CallerArgumentExpressionAttribute hat keine Auswirkungen. Es wird von dem CallerMemberNameAttribute √ºberschriebenK"/win32manifest" gilt nur f√ºr Assemblys und wird f√ºr das Modul ignoriert.K"/win32manifest" gilt nur f√ºr Assemblys und wird f√ºr das Modul ignoriert.±Der Name "_" verweist auf die Konstante, nicht auf das discard-Muster. Verwenden Sie "var _" zum Verwerfen des Werts oder "@_" zum Verweis auf eine Konstante √ºber diesen Namen.1Verwenden Sie "_" nicht f√ºr eine case-Konstante.kDie Option "{0}" √ºberschreibt das {1}-Attribut (in der Quelldatei oder im hinzugef√ºgten Modul angegeben).‚Diese Warnung tritt auf, wenn die in der Quelle gefundenen Assemblyattribute 'AssemblyKeyFileAttribute' oder 'AssemblyKeyNameAttribute' einen Konflikt mit der in den Projekteigenschaften angegebenen /Schl√ºsseldatei- oder /Schl√ºsselcontainer-Befehlszeilenoption, dem Schl√ºsseldateinamen oder Schl√ºsselcontainer in den Projekteigenschaften verursachen.eDie Option √ºberschreibt das in einer Quelldatei oder einem hinzugef√ºgten Modul angegebene Attribut.HBeim Vergleich mit NULL vom Typ "{0}" wird immer "False" zur√ºckgegeben.>Der Vergleich mit dem Strukturtyp Null f√ºhrt immer zu 'false'\'Die {0}-Schnittstelle wurde mit CoClassAttribute und nicht mit ComImportAttribute markiert.MSchnittstelle markiert mit 'CoClassAttribute', nicht mit 'ComImportAttribute'YDer Vergleich erfolgte mit der gleichen Variablen. Wollten Sie etwas anderes vergleichen?)Vergleich erfolgte mit derselben VariableÖDer Vorgang kann zur Laufzeit einen √úberlauf von ‚Äû{0}‚Äú verursachen (verwenden Sie zum √úberschreiben die Syntax ‚Äûunchecked‚Äú)gDer Vorgang kann zur Laufzeit √ºberlaufen (verwenden Sie zum √úberschreiben die Syntax ‚Äûunchecked‚Äú):F√ºr "{0}" wurden verschiedene Pr√ºfsummenwerte angegeben.3Unterschiedliche #pragma-Pr√ºfsummenwerte angegebenLDie Assembly "{0}", auf die verwiesen wird, hat einen anderen Zielprozessor.FDie Assembly, auf die verwiesen wird, hat einen anderen Zielprozessor.âDer konstante Wert "{0}" kann zur Laufzeit einen √úberlauf von "{1}" verursachen (verwenden Sie zum √úberschreiben die unchecked-Syntax).]M√∂glicher √úberlauf zur Laufzeit durch konstanten Wert (unchecked-Syntax zum √úberschreiben)ZDas NULL-Literal oder ein m√∂glicher NULL-Wert wird in einen Non-Nullable-Typ konvertiert.ZDas NULL-Literal oder ein m√∂glicher NULL-Wert wird in einen Non-Nullable-Typ konvertiert.rDer vollqualifizierte Name f√ºr "{0}" ist f√ºr Debuginformationen zu lang. Kompilieren Sie ohne die /debug-Option.<Voll qualifizierter Name ist zu lang f√ºr DebuginformationenªDer f√ºr Parameter "{0}" angegebene Standardwert hat keine Auswirkungen, da er f√ºr einen Member gilt, der in Kontexten verwendet wird, in denen keine optionalen Argumente zul√§ssig sind.ôDer angegebene Standardwert hat keine Auswirkungen, da es f√ºr ein Element gilt, das in Kontexten verwendet wird, die keine optionalen Argumente zulassenVUng√ºltiger Name f√ºr ein Vorverarbeitungssymbol; "{0}" ist kein g√ºltiger Bezeichner.KUng√ºltiger Name f√ºr ein Vorverarbeitungssymbol; kein g√ºltiger BezeichnerãVerz√∂gertes Signieren wurde angegeben und erfordert einen √∂ffentlichen Schl√ºssel, es wurde aber kein √∂ffentlicher Schl√ºssel angegeben.ãVerz√∂gertes Signieren wurde angegeben und erfordert einen √∂ffentlichen Schl√ºssel, es wurde aber kein √∂ffentlicher Schl√ºssel angegeben.]Die beste √ºberladene Add-Methode "{0}" f√ºr das Sammlungsinitialisiererelement ist veraltet.aDie beste √ºberladene Add-Methode "{0}" f√ºr das Sammlungsinitialisiererelement ist veraltet. {1}WDie beste √ºberladene Add-Methode f√ºr das Sammlungsinitialisiererelement ist veraltet.WDie beste √ºberladene Add-Methode f√ºr das Sammlungsinitialisiererelement ist veraltet."{0}" ist veraltet."{0}" ist veraltet: "{1}"Typ oder Element ist veraltetTyp oder Element ist veraltetqEin m√∂glicher NULL-Wert darf nicht f√ºr einen mit [NotNull] oder [DisallowNull] markierten Typ verwendet werden.qEin m√∂glicher NULL-Wert darf nicht f√ºr einen mit [NotNull] oder [DisallowNull] markierten Typ verwendet werden.óDer Vergleich von Funktionszeigern kann zu einem unerwarteten Ergebnis f√ºhren, weil Zeiger auf dieselbe Funktion m√∂glicherweise unterschiedlich sind.&Funktionszeigerwerte nicht vergleichenÇIn der Methode "{0}" fehlt die Anmerkung "[DoesNotReturn]" f√ºr den Abgleich mit dem implementierten oder √ºberschriebenen Member.|In der Methode fehlt die Anmerkung "[DoesNotReturn]" f√ºr den Abgleich mit dem implementierten oder √ºberschriebenen Member.cDer Ausdruck f√ºhrt immer zu System.NullReferenceException, da der Standardwert von "{0}" NULL ist.fAusdruck verursacht immer eine System.NullReferenceException, da der Standardwert des Typs null lautetë"{0}" wird bereits mit einer anderen NULL-Zul√§ssigkeit oder abweichenden Verweistypen in der Schnittstellenliste f√ºr den Typ "{1}" aufgef√ºhrt.äDie Schnittstelle wird bereits mit einer anderen NULL-Zul√§ssigkeit oder abweichenden Verweistypen in der Schnittstellenliste aufgef√ºhrt.>Der XML-Kommentar enth√§lt ein doppeltes param-Tag f√ºr "{0}"..XML-Kommentar enth√§lt ein doppeltes param-TagBDer XML-Kommentar enth√§lt ein doppeltes typeparam-Tag f√ºr "{0}".2XML-Kommentar enth√§lt ein doppeltes typeparam-TagRDie using-Direktive f√ºr "{0}" ist bereits vorher in diesem Namespace aufgetreten.GDirektive wird verwendet, die zuvor in diesem Namespace angezeigt wurde¿Der dynamisch gebundene Aufruf von Methode "{0}" verursacht m√∂glicherweise einen Fehler zur Laufzeit, weil es sich bei mindestens einer geltenden √úberladung um eine bedingte Methode handelt.öEin dynamisch gebundener Aufruf verursacht m√∂glicherweise einen Fehler zur Laufzeit, da mindestens eine anwendbare √úberladung eine bedingte Methode ist.Leerer Schalterblock.Leerer Schalterblock./Einzeiliger Kommentar oder Zeilenende erwartet.EEinzeiliger Kommentar oder Zeilenende erwartet nach #pragma-DirektiveZ"{0}" definiert den Operator == oder !=, aber √ºberschreibt Object.Equals(object o) nicht.^Typ definiert Operator == oder Operator !=, √ºberschreibt jedoch nicht Object.Equals(Objekt o)W"{0}" definiert den Operator == oder !=, aber √ºberschreibt Object.GetHashCode() nicht.[Typ definiert Operator == oder Operator !=, √ºberschreibt jedoch nicht Object.GetHashCode()M"{0}" √ºberschreibt Object.Equals(object o), aber nicht Object.GetHashCode().ZTyp √ºberschreibt Object.Equals(object o), √ºberschreibt jedoch nicht Object.GetHashCode(){0}. Siehe auch Fehler CS{1}.ΩDer Compiler gibt diese Warnung aus, wenn er einen Fehler mit einer Warnung √ºberschreibt. Weitere Informationen zu dem Problem finden Sie, indem Sie nach dem angegebenen Fehlercode suchen."Warnung √ºberschreibt einen Fehlerh"{0}" dient nur zu Testzwecken und kann in zuk√ºnftigen Aktualisierungen ge√§ndert oder entfernt werden.jDer Typ dient nur zu Testzwecken und kann in zuk√ºnftigen Aktualisierungen ge√§ndert oder entfernt werden.ÒDie explizite Schnittstellenimplementierung "{0}" entspricht mehreren Schnittstellenmembern. Es h√§ngt von der Implementierung ab, welcher Schnittstellenmember ausgew√§hlt wird. Verwenden Sie stattdessen eine nicht explizite Implementierung.\Explizite Schnittstellenimplementierung stimmt mit mehreren Schnittstellenelementen √ºberein.Der Konstruktor "{0}" ist als extern markiert.Konstruktor ist extern markiert∫Die Methode, der Operator oder der Accessor "{0}" ist als extern markiert und enth√§lt keine Attribute. F√ºgen Sie ein DllImport-Attribut hinzu, um die externe Implementierung anzugeben.QMethode, Operator oder Accessor ist extern markiert und weist keine Attribute aufHDas XML-Fragment "{1}" der Datei "{0}" kann nicht einbezogen werden: {2}2Das XML-Fragment kann nicht eingeschlossen werden.$Quelldatei "{0}" mehrmals angegeben.,Die Quelldatei wurde mehrere Male angegeben.uUng√ºltiger Dateiname f√ºr Pr√§prozessordirektive angegeben. Der Dateiname ist zu lang oder kein g√ºltiger Dateiname.<Ung√ºltiger Dateiname f√ºr Pr√§prozessordirektive angegeben.fDer Filterausdruck ist eine Konstante "false". Ziehen Sie in Betracht, die catch-Klausel zu entfernen.hDer Filterausdruck ist eine Konstante "false". Ziehen Sie in Betracht, den try-catch-Block zu entfernen.+Filterausdruck ist eine Konstante "false". )Filterausdruck ist eine Konstante "false"^Der Filterausdruck ist eine Konstante "true". Ziehen Sie in Betracht, den Filter zu entfernen.(Filterausdruck ist eine Konstante "true"oEine neue Finalize-Methode kann den Aufruf eines Destruktors st√∂ren. Wollten Sie einen Destruktor deklarieren?”Diese Warnung tritt auf, wenn Sie eine Klasse mit einer Methode erstellen, dessen Signatur eine √∂ffentliche, virtuell virtuelle ung√ºltige Finalize-Methode ist.

Wenn solch eine Klasse als Basisklasse verwendet wird und die ableitende Klasse einen Destruktor definiert, √ºberschreibt der Destruktor die Finalize-Methode der Basisklasse.DEine neue Finalize-Methode kann den Aufruf eines Destruktors st√∂renæFehler beim Generieren der Quelle durch den Generator "{0}". Dieser wird bei der Ausgabe nicht ber√ºcksichtigt, deshalb kann es zu Kompilierungsfehlern kommen. Ausnahmetyp: {1}. Meldung: {2}8Der Generator hat die folgende Ausnahme ausgel√∂st:
{0}6Fehler beim Generieren der Quelle durch den Generator.ÆFehler beim Initialisieren des Generators "{0}". Er wird bei der Ausgabe nicht ber√ºcksichtigt, deshalb kann es zu Kompilierungsfehlern kommen. Ausnahmetyp: {1}. Meldung: {2}8Der Generator hat die folgende Ausnahme ausgel√∂st:
{0}*Fehler beim Initialisieren des Generators.LDer angegebene Ausdruck stimmt immer mit der angegebenen Konstante √ºberein.LDer angegebene Ausdruck stimmt immer mit der angegebenen Konstante √ºberein.IDer angegebene Ausdruck stimmt immer mit dem angegebenen Muster √ºberein.IDer angegebene Ausdruck stimmt immer mit dem angegebenen Muster √ºberein.GDer angegebene Ausdruck stimmt nie mit dem angegebenen Muster √ºberein.GDer angegebene Ausdruck stimmt nie mit dem angegebenen Muster √ºberein.óEs sollte kein Alias mit dem Namen "global" definiert werden, da "global::" immer ein Verweis auf den globalen Namespace und nicht auf einen Alias ist.=Es sollte kein Alias mit dem Namen " global" definiert werdenMDer "goto case"-Wert kann nicht implizit in den Typ "{0}" konvertiert werden.NDer 'goto case'-Wert kann nicht implizit in den Schaltertyp konvertiert werden>Es wurde ein Bezeichner oder ein numerisches Literal erwartet.>Es wurde ein Bezeichner oder ein numerisches Literal erwartet.ÄUng√ºltige #pragma checksum-Syntax; muss lauten: #pragma checksum "Dateiname" "{XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX}" "XXXX..."$Ung√ºltige #pragma-Pr√ºfsummensyntax""disable" oder "restore" erwartet.7"disable" oder " restore" erwartet nach #pragma-WarnungUnbekannte #pragma-Direktive.Unbekannte #pragma-Direktive.~Der Aufruf eines nicht schreibgesch√ºtzten Members "{0}" aus einem readonly-Member f√ºhrt zu einer impliziten Kopie von "{1}".nDer Aufruf eines nicht schreibgesch√ºtzten Members aus einem readonly-Member f√ºhrt zu einer impliziten Kopie.fDie Zuweisung in einem bedingten Ausdruck ist immer konstant. Wollten Sie == anstelle von = verwenden?2Zuweisung in bedingtem Ausdruck ist immer konstantÑDas InterpolatedStringHandlerArgument hat bei Anwendung auf Lambdaparameter keine Auswirkungen und wird am Aufrufstandort ignoriert.ÑDas InterpolatedStringHandlerArgument hat bei Anwendung auf Lambdaparameter keine Auswirkungen und wird am Aufrufstandort ignoriert.IDer Assemblyverweis "{0}" ist ung√ºltig und kann nicht aufgel√∂st werden.oDiese Warnung gibt an, dass ein Attribut, wie z. B. InternalsVisibleToAttribute, nicht richtig angegeben wurde.CDer Assemblyverweis ist ung√ºltig und kann nicht aufgel√∂st werden.ü"{0}" ist kein bekannter Attributspeicherort. G√ºltige Attributspeicherorte f√ºr diese Deklaration sind "{1}". Alle Attribute in diesem Block werden ignoriert.Kein bekannter Attributpfad$Ung√ºltiges XML-Include-Element: {0}Ung√ºltiges XML-Include-Element>"{0}" hat die falsche Signatur, um ein Einstiegspunkt zu sein.9Methode weist als Einstiegspunkt die falsche Signatur aufUng√ºltige Zahl.Ung√ºltige Zahl.*Ung√ºltiger Suchpfad "{0}" in "{1}": "{2}"Ung√ºltiger Suchpfad angegebenuDie angegebene Versionszeichenfolge entspricht nicht dem empfohlenen Format: Hauptversion.Nebenversion.Build.RevisionuDie angegebene Versionszeichenfolge entspricht nicht dem empfohlenen Format: Hauptversion.Nebenversion.Build.RevisionADer angegebene Ausdruck ist nie vom bereitgestellten ("{0}") Typ.T'Der angegebene Ausdruck f√ºr den 'is'-Ausdruck darf niemals der angegebene Typ seinCDer angegebene Ausdruck ist immer vom bereitgestellten ("{0}") Typ.L'Der angegebene Ausdruck f√ºr den 'is'-Ausdruck ist immer der angegebene Typ¥Die Verwendung von "{0}" zum Testen der Kompatibilit√§t mit "{1}" entspricht grunds√§tzlich dem Testen der Kompatibilit√§t mit "{2}" und ist f√ºr alle Nicht-NULL-Werte erfolgreich.äDas Verwenden von 'is' zum Testen der Kompatibilit√§t mit 'dynamic' entspricht im Wesentlichen dem Testen der Kompatibilit√§t mit 'Object'LEin Ausdruck vom Typ "{0}" stimmt immer mit dem angegebenen Muster √ºberein.=Die Eingabe stimmt immer mit dem angegebenen Muster √ºberein.ÇDer Name "_" verweist auf den Typ "{0}", nicht auf das discard-Muster. Verwenden Sie "@_" f√ºr den Typ oder "var _" zum Verwerfen.JVerwenden Sie "_" nicht zum Verweis auf den Typ in einem is-type-Ausdruck.çDer Typname ‚Äû{0}‚Äú enth√§lt nur ASCII-Zeichen in Kleinbuchstaben. Solche Namen k√∂nnen m√∂glicherweise f√ºr die Sprache reserviert werden.ÉDer Typname enth√§lt nur ASCII-Zeichen in Kleinbuchstaben. Solche Namen k√∂nnen m√∂glicherweise f√ºr die Sprache reserviert werden.nDas l-Suffix kann leicht mit der Zahl 1 verwechselt werden. Verwenden Sie zur deutlichen Unterscheidung das L.@Das Suffix 'l' kann leicht mit der Ziffer '1' verwechselt werden`"{0}": Ein Einstiegspunkt kann nicht generisch sein oder sich in einem generischen Typ befinden.YEin Einstiegspunkt kann nicht generisch sein oder sich in einem generischen Typ befinden.\Der Einstiegspunkt des Programms ist globaler Code. Der Einstiegspunkt "{0}" wird ignoriert.VDer Einstiegspunkt des Programms ist globaler Code. Der Einstiegspunkt wird ignoriert.FDer Member "{0}" muss beim Beenden einen Wert ungleich NULL aufweisen.@Der Member "{0}" kann in diesem Attribut nicht verwendet werden.:Der Member kann in diesem Attribut nicht verwendet werden.PDer Member "{0}" muss beim Beenden mit "{1}" einen Wert ungleich NULL aufweisen._Der Member muss beim Beenden mit einer bestimmten Bedingung einen Wert ungleich NULL aufweisen.@Der Member muss beim Beenden einen Wert ungleich NULL aufweisen.qDie Methodengruppe ‚Äû{0}‚Äú wird in den Nichtdelegattyp ‚Äû{1}‚Äú konvertiert. Wollten Sie die Methode aufrufen?=Die Methodengruppe wird in einen Nichtdelegattyp konvertiert.xDie Anmerkung f√ºr Nullable-Verweistypen darf nur in Code innerhalb eines #nullable-Anmerkungskontexts verwendet werden.›Die Anmerkung f√ºr Nullable-Verweistypen darf nur in Code innerhalb eines #nullable-Anmerkungskontexts verwendet werden. F√ºr automatisch generierten Code ist eine explizite #nullable-Anweisung in der Quelle erforderlich.›Die Anmerkung f√ºr Nullable-Verweistypen darf nur in Code innerhalb eines #nullable-Anmerkungskontexts verwendet werden. F√ºr automatisch generierten Code ist eine explizite #nullable-Anweisung in der Quelle erforderlich.xDie Anmerkung f√ºr Nullable-Verweistypen darf nur in Code innerhalb eines #nullable-Anmerkungskontexts verwendet werden.uDer {0}-Parameter hat (im Gegensatz zu anderen Parametern) kein entsprechendes param-Tag im XML-Kommentar f√ºr "{1}".dParameter besitzt kein √ºbereinstimmendes param-Tag im XML-Kommentar (andere Parameter jedoch schon)Der {0}-Typparameter hat (im Gegensatz zu anderen Typparametern) kein entsprechendes typeparam-Tag im XML-Kommentar f√ºr "{1}".pTypparameter besitzt kein √ºbereinstimmendes typeparam-Tag im XML-Kommentar (andere type-Parameter jedoch schon)NDer XML-Kommentar f√ºr den √∂ffentlich sichtbaren Typ oder Member "{0}" fehlt.eDie /doc-Cmpileroption wurde angegeben, ein oder mehrere Konstrukte besitzen jedoch keine Kommentare.CFehledes XML-Kommentar f√ºr √∂ffentlich sichtbaren Typ oder Element{Der vordefinierte Typ "{0}" ist in mehreren Assemblys im globalen Alias definiert. Die Definition aus "{1}" wird verwendet.ΩDieser Fehler tritt auf, wenn der vordefinierte Systemtyp, wie z. B. System.Int32, in zwei Assemblys gefunden wird. Das kann auftreten, wenn Sie von zwei unterschiedlichen Stellen auf mscorlib oder System.Runtime.dll verweisen, z. B., indem Sie versuchen, zwei Versionen des .NET Framework nebeneinander auszuf√ºhren.JDer vordefinierte Typ is in mehreren Assemblys im globalen Alias definiert—Der Member "{0}" implementiert den Schnittstellenmember "{1}" im Typ "{2}". Zur Laufzeit gibt es mehrere √úbereinstimmungen f√ºr den Schnittstellenmember. Die aufgerufene Methode ist implementierungsabh√§ngig.ÕDiese Warnung kann generiert werden, wenn sich zwei Schnittstellenmethoden nur dain unterscheiden, ob ein bestimmter Parameter mit Verweis oder Ausgabe markiert wird. Am besten √§ndern Sie Ihren Code, um diese Warnung zu vermeiden, da es nicht offensichtlich ist und nicht sichergestellt werden kann, welche Methode zur Laufzeit aufgerufen wird.

Obwohl C# zwischen Ausgabe und Verweis unterscheidet, sieht CLR da keinen Unterschied. Bei der Entscheidung welche Methode die Schnittstelle implementiert, w√§hlt CLR nur eine aus.

Unterst√ºtzen Sie den Compiler bei der Unterscheidung zwischen den Methoden. Dazu k√∂nnen Sie beispielsweise unterschiedliche Namen vergeben oder einen zus√§tzlichen Parameter angeben.XElement implementiert Schnittstellenelement mit mehreren √úbereinstimmungen zur Laufzeit“Der Member "{1}" √ºberschreibt "{0}". Zur Laufzeit sind mehrere Kandidaten zum √úberschreiben verf√ºgbar. Es h√§ngt von der Implementierung ab, welche Methode aufgerufen wird. Verwenden Sie eine neuere Runtime.WElement √ºberschreibt Basiselement mit mehreren √úberschreibungskandidaten zur LaufzeitYIndizierung eines Arrays mit einem negativen Index (Arrayindizes starten immer mit Null)./Indiziert einen Array mit einem negativen IndexjDas Mitglied "{0}" blendet kein verf√ºgbares Mitglied aus. Das neue Schl√ºsselwort ist nicht erforderlich.MElement blendet kein vererbtes Element aus; neues Schl√ºsselwort erforderlichÕ"{0}" blendet den vererbten Member "{1}" aus. Damit der aktuelle Member diese Implementierung √ºberschreibt, f√ºgen Sie das override-Schl√ºsselwort hinzu. Ansonsten f√ºgen Sie das new-Schl√ºsselwort hinzu.OElement blendet vererbtes Element aus; fehlendes √úberschreibungsschl√ºsselwortw"{0}" blendet den vererbten Member "{1}" aus. Verwenden Sie das new-Schl√ºsselwort, wenn das Ausblenden vorgesehen war.´Eine Variable wurde mit demselben Namen deklariert wie eine Variable in einem Basistyp. Das new-Schl√ºsselwort wurde jedoch nicht verwendet. Diese Warnung informiert Sie dar√ºber, dass Sie "new" verwenden m√ºssen; die Variable wird so deklariert, als w√§re "new" in der Deklaration verwendet worden.DElement blendet vererbte Element aus; fehlendes 'new'-Schl√ºsselwort+Die Assembly "{0}" enth√§lt keine Analyzer. Assembly enth√§lt keine AnalysenRDie /noconfig-Option wird ignoriert, da sie in einer Antwortdatei angegeben wurde.RDie /noconfig-Option wird ignoriert, da sie in einer Antwortdatei angegeben wurde.∂F√ºr RuntimeMetadataVersion wurde kein Wert gefunden. Keine Assembly mit System.Object wurde gefunden, und es wurde auch kein Wert f√ºr RuntimeMetadataVersion mit Optionen angegeben.7Es wurde kein Wert f√ºr RuntimeMetadataVersion gefunden'Es wurden keine Quelldateien angegeben.'Es wurden keine Quelldateien angegeben.ëDie Funktion "{0}" ist nicht Teil der C#-Sprachspezifikation nach ISO-Norm und wird daher m√∂glicherweise von anderen Compilern nicht akzeptiert.àFeature ist nicht Teil der standardisierten ISO C#-Sprachspezifikation, und wird m√∂glicherweise von anderen Compilern nicht akzeptiert.lDer Member "{0}" √ºberschreibt den veralteten Member "{1}". F√ºgen Sie das Obsolete-Attribut zu "{0}" hinzu.(Element √ºberschreibt veraltetes ElementeDas Ergebnis des Ausdrucks ist immer "{0}", da ein Wert vom Typ "{1}" niemals NULL vom Typ "{2}" ist.eDas Ergebnis des Ausdrucks ist immer "{0}", da ein Wert vom Typ "{1}" niemals NULL vom Typ "{2}" ist.aDas Ergebnis des Ausdrucks lautet immer gleich, da ein Wert dieses Typs niemals 'null' entsprichtaDas Ergebnis des Ausdrucks lautet immer gleich, da ein Wert dieses Typs niemals 'null' entsprichtPEin NULL-Literal kann nicht in einen Non-Nullable-Verweistyp konvertiert werden.PEin NULL-Literal kann nicht in einen Non-Nullable-Verweistyp konvertiert werden.XDer Parameter ‚Äû{0}‚Äú wurde auf NULL-Werte √ºberpr√ºft, ist aber standardm√§√üig NULL.NDer Parameter wurde auf NULL-Werte √ºberpr√ºft, ist aber standardm√§√üig NULL.YDer Nullable-Typ ‚Äû{0}‚Äú wurde auf NULL-Werte √ºberpr√ºft und wird bei NULL ausgel√∂st.ODer Nullable-Typ wurde auf NULL-Werte √ºberpr√ºft und wird bei NULL ausgel√∂st.AM√∂gliches Nullverweisargument f√ºr den Parameter "{0}" in "{1}".M√∂gliches Nullverweisargument.M√∂gliche Nullverweiszuweisung.M√∂gliche Nullverweiszuweisung.pDer Objekt- oder Sammlungsinitialisierer dereferenziert implizit den Member "{0}", der m√∂glicherweise NULL ist.lDer Objekt- oder Sammlungsinitialisierer dereferenziert implizit einen Member, der m√∂glicherweise NULL ist.0Dereferenzierung eines m√∂glichen Nullverweises.0Dereferenzierung eines m√∂glichen Nullverweises.M√∂gliche Nullverweisr√ºckgabe.M√∂gliche Nullverweisr√ºckgabe.≠Das Argument vom Typ "{0}" kann aufgrund von Unterschieden in der NULL-Zul√§ssigkeit von Verweistypen nicht f√ºr den Parameter "{2}" vom Typ "{1}" in "{3}" verwendet werden.∫Das Argument vom Typ "{0}" kann aufgrund von Unterschieden bei der NULL-Zul√§ssigkeit von Verweistypen nicht als Ausgabe vom Typ "{1}" f√ºr den Parameter "{2}" in "{3}" verwendet werden.èDas Argument kann aufgrund von Unterschieden bei der NULL-Zul√§ssigkeit von Verweistypen nicht als Ausgabe f√ºr den Parameter verwendet werden.ÉDas Argument kann aufgrund von Unterschieden bei der NULL-Zul√§ssigkeit von Verweistypen nicht f√ºr den Parameter verwendet werden.aDie NULL-Zul√§ssigkeit von Verweistypen im Wert vom Typ "{0}" entspricht nicht dem Zieltyp "{1}".MDie NULL-Zul√§ssigkeit von Verweistypen im Wert entspricht nicht dem Zieltyp.ÉDie NULL-Zul√§ssigkeit in Einschr√§nkungen f√ºr den Typparameter "{0}" der Methode "{1}" entspricht nicht den Einschr√§nkungen f√ºr den Typparameter "{2}" der Schnittstellenmethode "{3}". Verwenden Sie stattdessen eine explizite Schnittstellenimplementierung.≥Die NULL-Zul√§ssigkeit in Einschr√§nkungen f√ºr den Typparameter entspricht nicht den Einschr√§nkungen f√ºr den Typparameter in der implizit implementierten Schnittstellenmethode.îPartielle Methodendeklarationen von "{0}" weisen eine inkonsistente NULL-NULL-Zul√§ssigkeit in den Einschr√§nkungen f√ºr den Typparameter "{1}" auf.{Partielle Methodendeklarationen weisen eine inkonsistente NULL-Zul√§ssigkeit in Einschr√§nkungen f√ºr den Typparameter auf.çDie NULL-Zul√§ssigkeit von Verweistypen im expliziten Schnittstellenspezifizierer entspricht nicht der vom Typ implementierten Schnittstelle.çDie NULL-Zul√§ssigkeit von Verweistypen im expliziten Schnittstellenspezifizierer entspricht nicht der vom Typ implementierten Schnittstelle.™"{0}" implementiert den Schnittstellenmember "{1}" nicht. Die NULL-Zul√§ssigkeit von Verweistypen in der vom Basistyp implementierten Schnittstelle stimmt nicht √ºberein.¶Der Typ implementiert den Schnittstellenmember nicht. Die NULL-Zul√§ssigkeit von Verweistypen in der vom Basistyp implementierten Schnittstelle stimmt nicht √ºberein.ΩDie NULL-Zul√§ssigkeit von Verweistypen im Typ des Parameters "{0}" von "{1}" entspricht (m√∂glicherweise aufgrund von Attributen f√ºr die NULL-Zul√§ssigkeit) nicht dem Zieldelegaten "{2}".ßDie NULL-Zul√§ssigkeit von Verweistypen im Typ des Parameters entspricht (m√∂glicherweise aufgrund von Attributen f√ºr die NULL-Zul√§ssigkeit) nicht dem Zieldelegaten.vDie NULL-Zul√§ssigkeit von Verweistypen im Typ des Parameters "{0}" entspricht nicht dem implementierten Member "{1}".jDie NULL-Zul√§ssigkeit von Verweistypen im Typ des Parameters entspricht nicht dem implementierten Member.âDie NULL-Zul√§ssigkeit von Verweistypen im Typ des Parameters "{0}" von "{1}" entspricht nicht dem implizit implementierten Member "{2}".sDie NULL-Zul√§ssigkeit von Verweistypen im Typ des Parameters entspricht nicht dem implizit implementierten Member.wDie NULL-Zul√§ssigkeit von Verweistypen im Typ des Parameters "{0}" entspricht nicht dem au√üer Kraft gesetzten Member.qDie NULL-Zul√§ssigkeit von Verweistypen im Typ des Parameters entspricht nicht dem au√üer Kraft gesetzten Member.|Die NULL-Zul√§ssigkeit von Verweistypen im Typ des Parameters "{0}" entspricht nicht der Deklaration der partiellen Methode.vDie NULL-Zul√§ssigkeit von Verweistypen im Typ des Parameters entspricht nicht der Deklaration der partiellen Methode.≠Die NULL-Zul√§ssigkeit von Verweistypen im R√ºckgabetyp "{0}" entspricht (m√∂glicherweise aufgrund von Attributen f√ºr die NULL-Zul√§ssigkeit) nicht dem Zieldelegaten "{1}".°Die NULL-Zul√§ssigkeit von Verweistypen im R√ºckgabetyp entspricht (m√∂glicherweise aufgrund von Attributen f√ºr die NULL-Zul√§ssigkeit) nicht dem Zieldelegaten.jDie NULL-Zul√§ssigkeit von Verweistypen im R√ºckgabetyp entspricht nicht dem implementierten Member "{0}".dDie NULL-Zul√§ssigkeit von Verweistypen im R√ºckgabetyp entspricht nicht dem implementierten Member.}Die NULL-Zul√§ssigkeit von Verweistypen im R√ºckgabetyp von "{0}" entspricht nicht dem implizit implementierten Member "{1}".mDie NULL-Zul√§ssigkeit von Verweistypen im R√ºckgabetyp entspricht nicht dem implizit implementierten Member.kDie NULL-Zul√§ssigkeit von Verweistypen im R√ºckgabetyp entspricht nicht dem au√üer Kraft gesetzten Member.kDie NULL-Zul√§ssigkeit von Verweistypen im R√ºckgabetyp entspricht nicht dem au√üer Kraft gesetzten Member.pDie NULL-Zul√§ssigkeit von Verweistypen im R√ºckgabetyp entspricht nicht der Deklaration der partiellen Methode.pDie NULL-Zul√§ssigkeit von Verweistypen im R√ºckgabetyp entspricht nicht der Deklaration der partiellen Methode.aDie NULL-Zul√§ssigkeit von Verweistypen im Typ entspricht nicht dem implementierten Member "{0}".[Die NULL-Zul√§ssigkeit von Verweistypen im Typ entspricht nicht dem implementierten Member.pDie NULL-Zul√§ssigkeit von Verweistypen im Typ "{0}" entspricht nicht dem implizit implementierten Member "{1}".dDie NULL-Zul√§ssigkeit von Verweistypen im Typ entspricht nicht dem implizit implementierten Member.bDie NULL-Zul√§ssigkeit von Verweistypen im Typ entspricht nicht dem au√üer Kraft gesetzten Member.bDie NULL-Zul√§ssigkeit von Verweistypen im Typ entspricht nicht dem au√üer Kraft gesetzten Member.◊Der Typ "{3}" kann nicht als Typparameter "{2}" im generischen Typ oder in der generischen Methode "{0}" verwendet werden. Die NULL-Zul√§ssigkeit des Typarguments "{3}" entspricht nicht dem Einschr√§nkungstyp "{1}".πDer Typ kann nicht als Typparameter im generischen Typ oder in der generischen Methode verwendet werden. Die NULL-Zul√§ssigkeit des Typarguments entspricht nicht dem Einschr√§nkungstyp.’Der Typ "{2}" kann nicht als Typparameter "{1}" im generischen Typ oder in der generischen Methode "{0}" verwendet werden. Die NULL-Zul√§ssigkeit des Typarguments "{2}" entspricht nicht der notnull-Einschr√§nkung.ΩDer Typ kann nicht als Typparameter im generischen Typ oder in der generischen Methode verwendet werden. Die NULL-Zul√§ssigkeit des Typarguments entspricht nicht der notnull-Einschr√§nkung.”Der Typ "{2}" kann nicht als Typparameter "{1}" im generischen Typ oder in der generischen Methode "{0}" verwendet werden. Die NULL-Zul√§ssigkeit des Typarguments "{2}" entspricht nicht der class-Einschr√§nkung.ªDer Typ kann nicht als Typparameter im generischen Typ oder in der generischen Methode verwendet werden. Die NULL-Zul√§ssigkeit des Typarguments entspricht nicht der class-Einschr√§nkung./Ein Werttyp, der NULL zul√§sst, kann NULL sein./Ein Werttyp, der NULL zul√§sst, kann NULL sein.KDer veraltete Member "{0}" √ºberschreibt den nicht veralteten Member "{1}".9Veraltetes Element √ºberschreibt nicht veraltetes ElementiDer out-Parameter "{0}" muss eine Zuweisung erhalten, bevor die Steuerung die aktuelle Methode verl√§sst.^Zuweisen eines out-Parameters erforderlich, bevor die Steuerung die aktuelle Methode verl√§sstSDer Parameter "{0}" muss beim Beenden mit "{1}" einen Wert ungleich NULL aufweisen.bDer Parameter muss beim Beenden mit einer bestimmten Bedingung einen Wert ungleich NULL aufweisen.IDer Parameter "{0}" muss beim Beenden einen Wert ungleich NULL aufweisen.CDer Parameter muss beim Beenden einen Wert ungleich NULL aufweisen.D"{0}": Statische Typen k√∂nnen nicht als Parameter verwendet werden.<Statische Typen k√∂nnen nicht als Parameter verwendet werdennDer Parameter "{0}" muss beim Beenden einen Wert ungleich NULL aufweisen, weil Parameter "{1}" nicht NULL ist.âDer Parameter muss beim Beenden einen Wert ungleich NULL aufweisen, weil der von NotNullIfNotNull referenzierte Parameter nicht NULL ist.êDer Parameter ‚Äû{0}‚Äú tritt nach ‚Äû{1}‚Äú in der Parameterliste auf, wird jedoch als Argument f√ºr die Handler-Konvertierungen einer interpolierten Zeichenfolge verwendet. Dies erfordert, dass der Aufrufer Parameter mit benannten Argumenten an der Aufrufsite neu anordnen kann. Erw√§gen Sie, den Handler-Parameter einer interpolierten Zeichenfolge hinter alle beteiligten Argumenten zu platzieren.vDie Konvertierung eines Parameters eines Handlers einer interpolierten Zeichenfolgen erfolgt nach dem HandlerparameterUDie partiellen Methodendeklarationen "{0}" und "{1}" weisen Signaturunterschiede auf.EDie partiellen Methodendeklarationen weisen Signaturunterschiede auf.Q"{0}" implementiert das Muster "{1}" nicht. "{2}" weist die falsche Signatur auf.\Der Typ implementiert nicht das Sammlungsmuster. Das Element weist die falsche Signatur auf.P"{0}" implementiert das Muster "{1}" nicht. "{2}" ist mit "{3}" nicht eindeutig.SDer Typ implementiert nicht das Sammlungsmuster. Die Elemente sind nicht eindeutig.k"{0}" implementiert nicht das Muster "{1}". "{2}" ist keine √∂ffentliche Instanz- oder Erweiterungsmethode.uDer Typ implementiert nicht das Sammlungsmuster. Der Member ist keine √∂ffentliche Instanz- oder Erweiterungsmethode.qDer lokale Name "{0}" ist f√ºr PDB zu lang. K√ºrzen Sie ihn, oder f√ºhren Sie die Kompilierung ohne /debug durch.!Lokaler Name ist zu lang f√ºr PDB'M√∂glicherweise falsche leere Anweisung'M√∂glicherweise falsche leere AnweisungÇDer Operator "{0}" kann hier aufgrund der Rangfolge nicht verwendet werden. Verwenden Sie Klammern, um Eindeutigkeit zu erreichen.BOperators kann aufgrund der Rangfolge hier nicht verwendet werden.H{0}: Im versiegelten Typ wurde ein neuer gesch√ºtzter Member deklariert.8Neuer gesch√ºtzter Member in versiegeltem Typ deklariert3"{0}" definiert "Equals", aber nicht "GetHashCode".;Der Datensatz definiert "Equals", aber nicht "GetHashCode".<Typen und Aliase d√ºrfen nicht den Namen "record" aufweisen.<Typen und Aliase d√ºrfen nicht den Namen "record" aufweisen.LDie referenzierte {0}-Assembly besitzt eine andere Kultureinstellung: "{1}".5Referenzierte Assembly hat andere Kultureinstellungen>Die referenzierte Assembly "{0}" besitzt keinen starken Namen./Referenzierte Assembly hat keinen starken Namen¯Es wurde ein Verweis auf die eingebettete Interopassembly "{0}" aufgrund eines indirekten Verweises auf diese Assembly, der von Assembly "{1}" erstellt wurde, erstellt. √Ñndern Sie ggf. f√ºr beide Assemblys die Eigenschaft "Interoptypen einbetten".éSie haben einen Verweis zu einer Assembly hinzugef√ºgt mifhilte von /link (Einbetten der Interoptypen-Eigenschaft auf True festegelegt). Dadurch wird der Compiler angewiesen, die Interoptypeninformationen aus der Assembly einzubetten. Der Compiler kann jedoch keine Interoptypeninformationen aus der Assembly einbetten, da eine andere Assembly, auf die Sie verweisen, auch auf diese Assembly verweist mithilfe von /reference (Einbetten der Interoptypen-Eigenschaft auf False festegelegt.)

Um Interoptypeninformationen f√ºr beide Assemblys einzubetten, verwenden Sie /link f√ºr die Verweise zu den einzelnen Assemblys (Einbetten der Interoptypen-Eigenschaft auf True festlegen).

Um die Warnung zu beheben, k√∂nnen Sie stattdessen /reference verwenden (Einbetten der Interoptypen-Eigenschaft auf False festlegen). In diesem Fall stellt eine prim√§re Interop-Assembly (PIA) Interoptypeninformationen bereit.iAufgrund eines indirekten Assemblyverweises wurde ein Verweis zur eingebetteten Interop-Assembly erstelltSDer R√ºckgabewert muss ungleich NULL sein, weil der Parameter "{0}" nicht NULL ist.MDer R√ºckgabewert muss ungleich NULL sein, weil der Parameter nicht NULL ist.H'{0}: Statische Typen k√∂nnen nicht als R√ºckgabetypen verwendet werden.AStatische Typen k√∂nnen nicht als R√ºckgabetypen verwendet werdenÖDer Typ "{1}" in "{0}" verursacht einen Konflikt mit dem importierten Typ "{3}" in "{2}". Der in "{0}" definierte Typ wird verwendet.#Typenkonflikte mit importiertem TypãDer Typ "{1}" in "{0}" verursacht einen Konflikt mit dem importierten Namespace "{3}" in "{2}". Der in "{0}" definierte Typ wird verwendet.)Typenkonflikte mit importiertem NamespaceëDer Namespace "{1}" in "{0}" verursacht einen Konflikt mit dem importierten Typ "{3}" in "{2}". Der in "{0}" definierte Namespace wird verwendet.'Namespacekonflikte mit importiertem Typ’Es gibt keine festgelegte Reihenfolge f√ºr die Felder in mehreren Deklarationen der partiellen Struktur "{0}". Um eine Reihenfolge anzugeben, m√ºssen sich alle Instanzenfelder in der gleichen Deklaration befinden._Keine definierte Sortierung zwischen Feldern in mehreren Deklarationen der partiellen Struktur.REine mit [DoesNotReturn] gekennzeichnete Methode darf nicht zur√ºckgegeben werden.REine mit [DoesNotReturn] gekennzeichnete Methode darf nicht zur√ºckgegeben werden.]Der zweite Operand eines is- oder as-Operators darf nicht den statischen Typ "{0}" aufweisen.LDer zweite Operand eines is- oder as-Operators darf kein statischer Typ sein¨Der switch-Ausdruck verarbeitet nicht alle m√∂glichen Werte des zugeh√∂rigen Eingabetyps (nicht umfassender Ausdruck). Das Muster "{0}" wird beispielsweise nicht abgedeckt.ïEinige NULL-Eingaben werden vom switch-Ausdruck nicht verarbeitet (nicht umfassender Ausdruck). Das Muster "{0}" wird beispielsweise nicht abgedeckt.⁄Der switch-Ausdruck behandelt einige NULL-Eingaben nicht (er ist nicht umfassend). Das Muster "{0}" ist z.¬†B. nicht abgedeckt. Ein Muster mit einer when-Klausel kann jedoch erfolgreich mit diesem Wert √ºbereinstimmen.;Der switch-Ausdruck verarbeitet einige NULL-Eingaben nicht.;Der switch-Ausdruck verarbeitet einige NULL-Eingaben nicht.◊Der switch-Ausdruck verarbeitet einige Werte des zugeh√∂rigen Eingabetyps einschlie√ülich eines unbenannten Enumerationswerts nicht (nicht umfassender Ausdruck). Das Muster "{0}" wird beispielsweise nicht abgedeckt.°Der switch-Ausdruck verarbeitet einige Werte des zugeh√∂rigen Eingabetyps einschlie√ülich eines unbenannten Enumerationswerts nicht (nicht umfassender Ausdruck).ÓDer switch-Ausdruck behandelt nicht alle m√∂glichen Werte seines Eingabetyps (er ist nicht umfassend). Das Muster "{0}" ist z.¬†B. nicht abgedeckt. Ein Muster mit einer when-Klausel kann jedoch erfolgreich mit diesem Wert √ºbereinstimmen.kDer switch-Ausdruck verarbeitet nicht alle m√∂glichen Werte des zugeh√∂rigen Eingabetyps (nicht umfassend).kDer switch-Ausdruck verarbeitet nicht alle m√∂glichen Werte des zugeh√∂rigen Eingabetyps (nicht umfassend).sDie Methode "{0}" wird nicht als Einstiegspunkt verwendet, weil ein synchroner Einstiegspunkt "{1}" gefunden wurde.$Der ausgel√∂ste Wert darf NULL sein.$Der ausgel√∂ste Wert darf NULL sein.ëDie Quelldatei hat das Limit von 16.707.565 Zeilen √ºberschritten, die in der PDB dargestellt werden k√∂nnen. Die Debuginformationen sind falsch.ëDie Quelldatei hat das Limit von 16.707.565 Zeilen √ºberschritten, die in der PDB dargestellt werden k√∂nnen. Die Debuginformationen sind falsch.ºDie NULL-Zul√§ssigkeit von Verweistypen im Typ des Parameters "{0}" entspricht (m√∂glicherweise aufgrund von Attributen f√ºr die NULL-Zul√§ssigkeit) nicht dem implementierten Member "{1}".∞Die NULL-Zul√§ssigkeit von Verweistypen im Typ des Parameters entspricht (m√∂glicherweise aufgrund von Attributen f√ºr die NULL-Zul√§ssigkeit) nicht dem implementierten Member.œDie NULL-Zul√§ssigkeit von Verweistypen im Typ des Parameters "{0}" von "{1}" entspricht (m√∂glicherweise aufgrund von Attributen f√ºr die NULL-Zul√§ssigkeit) nicht dem implizit implementierten Member "{2}".πDie NULL-Zul√§ssigkeit von Verweistypen im Typ des Parameters entspricht (m√∂glicherweise aufgrund von Attributen f√ºr die NULL-Zul√§ssigkeit) nicht dem implizit implementierten Member.®Die NULL-Zul√§ssigkeit des Typs des Parameters "{0}" entspricht (m√∂glicherweise aufgrund von Attributen f√ºr die NULL-Zul√§ssigkeit) nicht dem √ºberschriebenen Member.¢Die NULL-Zul√§ssigkeit des Typs des Parameters entspricht (m√∂glicherweise aufgrund von Attributen f√ºr die NULL-Zul√§ssigkeit) nicht dem √ºberschriebenen Member.ºDie NULL-Zul√§ssigkeit von Verweistypen im R√ºckgabetyp entspricht nicht dem implementierten Member "{0}". Dies wird m√∂glicherweise durch Attribute f√ºr die NULL-Zul√§ssigkeit verursacht.™Die NULL-Zul√§ssigkeit von Verweistypen im R√ºckgabetyp entspricht (m√∂glicherweise aufgrund von Attributen f√ºr die NULL-Zul√§ssigkeit) nicht dem implementierten Member.øDie NULL-Zul√§ssigkeit von Verweistypen im R√ºckgabetyp "{0}" entspricht (m√∂glicherweise aufgrund von Attributen f√ºr die NULL-Zul√§ssigkeit) nicht dem implizit implementierten Member "{1}".≥Die NULL-Zul√§ssigkeit von Verweistypen im R√ºckgabetyp entspricht (m√∂glicherweise aufgrund von Attributen f√ºr die NULL-Zul√§ssigkeit) nicht dem implizit implementierten Member.úDie NULL-Zul√§ssigkeit des R√ºckgabetyps entspricht (m√∂glicherweise aufgrund von Attributen f√ºr die NULL-Zul√§ssigkeit) nicht dem √ºberschriebenen Member.úDie NULL-Zul√§ssigkeit des R√ºckgabetyps entspricht (m√∂glicherweise aufgrund von Attributen f√ºr die NULL-Zul√§ssigkeit) nicht dem √ºberschriebenen Member.îDer Tupelelementname "{0}" wird ignoriert, weil ein anderer oder gar kein Name auf der anderen Seite des ==- oder !=-Tupeloperators angegeben wurde.éDer Tupelelementname wird ignoriert, weil ein anderer oder gar kein Name auf der anderen Seite des ==- oder !=-Tupeloperators angegeben wurde.iDer Tupelelementname "{0}" wird ignoriert, da vom Zieltyp "{1}" ein anderer oder kein Name angegeben ist.dDer Tupelelementname wird ignoriert, da vom Zuweisungsziel ein anderer oder kein Name angegeben ist.kDer Name des Typparameters "{0}" und der Name des Typparameters der √§u√üeren Methode "{1}" sind identisch.UDer Typparameter und der Typparameter der √§u√üeren Methode weisen denselben Typ auf.YDer {0}-Typparameter hat den gleichen Namen wie der Typparameter des √§u√üeren Typs "{1}"HTypparameter hat denselben Namen wie der Typparameter des √§u√üeren Typs0Fehler beim Laden der Analyzer-Assembly {0}: {1}+Analyseassembly konnte nicht geladen werdenYDem Feld "{0}" wird nie etwas zugewiesen, und es hat immer seinen Standardwert von "{1}".<Feld wird niemals zugewiesen, und hat immer den StandardwertíControl is returned to caller before auto-implemented property '{0}' is explicitly assigned, causing a preceding implicit assignment of 'default'.åControl is returned to caller before auto-implemented property is explicitly assigned, causing a preceding implicit assignment of 'default'.™Auto-implemented property '{0}' must be fully assigned before control is returned to the caller. Consider updating to language version '{1}' to auto-default the property.¢An auto-implemented property must be fully assigned before control is returned to the caller. Consider updating the language version to auto-default the property.~Control is returned to caller before field '{0}' is explicitly assigned, causing a preceding implicit assignment of 'default'.xControl is returned to caller before field is explicitly assigned, causing a preceding implicit assignment of 'default'.ìField '{0}' must be fully assigned before control is returned to the caller. Consider updating to language version '{1}' to auto-default the field.¶Fields of a struct must be fully assigned in a constructor before control is returned to the caller. Consider updating the language version to auto-default the field.%Unboxing eines m√∂glichen NULL-Werts.%Unboxing eines m√∂glichen NULL-Werts.Das auf den Parameter "{0}" angewendete EnumeratorCancellationAttribute hat keine Auswirkungen. Das Attribut ist nur f√ºr einen Parameter vom Typ "CancellationToken" in einer async-iterator-Methode g√ºltig, die IAsyncEnumerable zur√ºckgibt.ÃDas EnumeratorCancellationAttribute hat keine Auswirkungen. Das Attribut ist nur f√ºr einen Parameter vom Typ "CancellationToken" in einer async-iterator-Methode g√ºltig, die IAsyncEnumerable zur√ºckgibt.°Der Async-Iterator "{0}" weist mindestens einen Parameter vom Typ "CancellationToken" auf, aber keiner der Parameter umfasst das Attribut "EnumeratorCancellation", deshalb wird der Parameter f√ºr das Abbruchtoken aus dem generierten "IAsyncEnumerable<>.GetAsyncEnumerator" nicht verwendet.¢Der Async-Iterator-Member weist mindestens einen Parameter vom Typ "CancellationToken" auf, aber keiner der Parameter umfasst das Attribut "EnumeratorCancellation", deshalb wird der Parameter f√ºr das Abbruchtoken aus dem generierten "IAsyncEnumerable<>.GetAsyncEnumerator" nicht verwendet.ÆEs wird angenommen, dass der von "{1}" verwendete Assemblyverweis "{0}" mit "{2}" von "{3}" √ºbereinstimmt. M√∂glicherweise m√ºssen Sie eine Laufzeitrichtlinie bereitstellen.àDie zwei Assemblys unterscheiden sich in Release- und/oder Versionsnummer. Damit eine Vereinheitlichung vorgenommen wird, m√ºssen Sie in der Konfigurationsdatei der Anwendung Direktiven angeben. Zudem m√ºssen Sie den korrekten starken Namen einer Assembly angeben.UEs wird davon ausgegangen, dass der Assemblyverweis mit der Identit√§t √ºbereinstimmtÆEs wird angenommen, dass der von "{1}" verwendete Assemblyverweis "{0}" mit "{2}" von "{3}" √ºbereinstimmt. M√∂glicherweise m√ºssen Sie eine Laufzeitrichtlinie bereitstellen.àDie zwei Assemblys unterscheiden sich in Release- und/oder Versionsnummer. Damit eine Vereinheitlichung vorgenommen wird, m√ºssen Sie in der Konfigurationsdatei der Anwendung Direktiven angeben. Zudem m√ºssen Sie den korrekten starken Namen einer Assembly angeben.UEs wird davon ausgegangen, dass der Assemblyverweis mit der Identit√§t √ºbereinstimmtQDer Befehlszeilenschalter '{0}' ist noch nicht implementiert und wurde ignoriert.9Der Befehlszeilenschalter wurde noch nicht implementiert.ìNon-Nullable-{0} "{1}" muss beim Beenden des Konstruktors einen Wert ungleich NULL enthalten. Erw√§gen Sie eine Deklaration von "{0}" als Nullable.áEin Non-Nullable-Feld muss beim Beenden des Konstruktors einen Wert ungleich NULL enthalten. Erw√§gen Sie die Deklaration als Nullable.pDer XML-Kommentar f√ºr "{1}" weist ein paramref-Tag f√ºr "{0}" auf, es gibt aber keinen Parameter mit dem Namen.XXML-Kommentar besitzt ein paramref-Tag, es gibt jedoch keinen Parameter mit diesem NamenbDer XML-Kommentar weist ein param-Tag f√ºr "{0}" auf, es gibt aber keinen Parameter mit dem Namen.UXML-Kommentar besitzt ein param-Tag, es gibt jedoch keinen Parameter mit diesem NamenwDer XML-Kommentar f√ºr "{1}" weist ein typeparamref-Tag f√ºr "{0}" auf, es gibt aber keinen Typparameter mit dem Namen._XML-Kommentar besitzt ein typeparamref-Tag, es gibt jedoch keinen Typparameter mit diesem NameniDer XML-Kommentar weist ein typeparam-Tag f√ºr "{0}" auf, es gibt aber keinen Typparameter mit dem Namen.\XML-Kommentar besitzt ein typeparam-Tag, es gibt jedoch keinen Typparameter mit diesem Namen”Da auf diesen Aufruf nicht gewartet wird, wird die Ausf√ºhrung der aktuellen Methode vor Abschluss des Aufrufs fortgesetzt. Ziehen Sie ein Anwenden des "Await"-Operators auf das Ergebnis des Aufrufs in Betracht.∑Die aktuelle Methode ruft eine asynchrone Methode auf, die ein Task- oder ein Task<TResult>-Objekt zur√ºckgibt und den await-Operator nicht auf das Ergebnis anwendet. Der Aufruf der asynchronen Methode beginnt als asynchroner Task. Da kein await-Operator angewendet wird, wird das Programm jedoch fortgesetzt, ohne dass auf den Abschluss des Tasks gewartet wird. In den meisten F√§llen entspricht dieses Verhalten nicht Ihren Erwartungen. Normalerweise h√§ngen andere Aspekte der aufrufenden Methode von den Ergebnissen des Aufrufs ab, oder es wird mindestens erwartet, dass die aufgerufene Methode abgeschlossen wird, bevor die R√ºckgabe von der Methode erfolgt, die den Aufruf enth√§lt.

Ebenso wichtig ist, was mit Ausnahmen geschieht, die in der aufgerufenen asynchronen Methode ausgel√∂st werden. Eine Ausnahme, die in einer Methode ausgel√∂st wird, die ein Task- oder Task<TResult>-Objekt zur√ºckgibt, wird im zur√ºckgegebenen Task gespeichert. Wenn Sie nicht auf den Abschluss des Tasks warten bzw. keine explizite √úberpr√ºfung auf Ausnahmen ausf√ºhren, geht die Ausnahme verloren. Wenn Sie auf den Abschluss des Tasks warten, wird die Ausnahme erneut ausgel√∂st.

Als bew√§hrte Methode sollten Sie immer auf den Abschluss des Aufrufs warten.

Sie sollten das Unterdr√ºcken der Warnung nur in Betracht ziehen, wenn Sie sicher sind, dass Sie nicht auf den Abschluss des asynchronen Aufrufs warten m√∂chten und die aufgerufene Methode keine Ausnahmen ausl√∂st. In diesem Fall k√∂nnen Sie die Warnung unterdr√ºcken, indem Sie das Taskergebnis des Aufrufs einer Variablen zuweisen.{Da auf diesen Aufruf nicht gewartet wird, wird die Ausf√ºhrung der aktuellen Methode vor Abschluss des Aufrufs fortgesetzt.BDer XML-Kommentar ist auf keinem g√ºltigen Sprachelement abgelegt.BDer XML-Kommentar ist auf keinem g√ºltigen Sprachelement abgelegt.OIn cref-Attributen sollten geschachtelte, generische Typen qualifiziert werden.aInnerhalb von cref-Attributen sollten geschachtelte Typen von generischen Typen qualifiziert sein#Unerreichbarer Code wurde entdeckt.#Unerreichbarer Code wurde entdeckt.ªEine vorherige Catch-Klausel hat bereits alle Ausnahmen abgefangen. Alle ausgel√∂sten Nicht-Ausnahmen werden von einer System.Runtime.CompilerServices.RuntimeWrappedException umschlossen.ñDiese Warnung wird verursacht, wenn bei einem catch()-Block nach einem catch (System.Exception e)-Block kein Ausnahmetyp angegeben ist. Die Warnung empfiehlt, dass der catch()-Block keine Ausnahmen erfasst.

Ein catch()-Block nach einem catch (System.Exception e)-Block kann nicht-CLS-Ausnahmen erfassen, wenn f√ºr das RuntimeCompatibilityAttribute false in der AssemblyInfo.cs-Datei festgelegt wird: [assembly: RuntimeCompatibilityAttribute(WrapNonExceptionThrows = false)]. Wenn f√ºr dieses Attribut nicht explizit false festgelegt wird, werden alle ausgel√∂sten nicht-CLS-Ausnahmen als Ausnahmen gepackt und der catch (System.Exception e)-Block erfasst sie.;Eine vorherige Catch-Klausel erfasst bereits alle AusnahmenáDer Parameter "{0}" wird nicht gelesen. M√∂glicherweise haben Sie ihn nicht zum Initialisieren der gleichnamigen Eigenschaft verwendet?ÅDer Parameter wird nicht gelesen. M√∂glicherweise haben Sie ihn nicht zum Initialisieren der gleichnamigen Eigenschaft verwendet?&Das Ereignis "{0}" wird nie verwendet.Ereignis wird niemals benutzt"Das Feld "{0}" wird nie verwendet.FDem Feld "{0}" wurde ein Wert zugewiesen, der aber nie verwendet wird.;Feld ist zugewiesen, der Wert wird jedoch niemals verwendetFeld wird niemals verwendet,Auf diese Bezeichnung wurde nicht verwiesen.,Auf diese Bezeichnung wurde nicht verwiesen.BDie lokale Funktion "{0}" ist deklariert, wird aber nie verwendet.<Die lokale Funktion ist deklariert, wird aber nie verwendet.;Die Variable "{0}" ist deklariert, wird aber nie verwendet.DDie Variable "{0}" ist zugewiesen, ihr Wert wird aber nie verwendet.?Variable ist zugewiesen, der Wert wird jedoch niemals verwendet6Variable ist deklariert, wird jedoch niemals verwendet:Verwendung der nicht zugewiesenen lokalen Variablen "{0}".>Verwendung des m√∂glicherweise nicht zugewiesenen Felds "{0}".kField '{0}' is read before being explicitly assigned, causing a preceding implicit assignment of 'default'.eField is read before being explicitly assigned, causing a preceding implicit assignment of 'default'.nUse of possibly unassigned field '{0}'. Consider updating to language version '{1}' to auto-default the field.cUse of possibly unassigned field. Consider updating the language version to auto-default the field.9Verwendung eines m√∂glicherweise nicht zugewiesenen Felds7Verwendung des nicht zugewiesenen out-Parameters "{0}".2Verwendung eines nicht zugewiesenen out-ParametersaVerwenden einer m√∂glicherweise nicht zugewiesenen, automatisch implementierten Eigenschaft "{0}"Auto-implemented property '{0}' is read before being explicitly assigned, causing a preceding implicit assignment of 'default'.yAuto-implemented property is read before being explicitly assigned, causing a preceding implicit assignment of 'default'.ÖUse of possibly unassigned auto-implemented property '{0}'. Consider updating to language version '{1}' to auto-default the property.zUse of possibly unassigned auto-implemented property. Consider updating the language version to auto-default the property.[Verwenden einer m√∂glicherweise nicht zugewiesenen, automatisch implementierten EigenschaftùThe 'this' object is read before all of its fields have been assigned, causing preceding implicit assignments of 'default' to non-explicitly assigned fields.ùThe 'this' object is read before all of its fields have been assigned, causing preceding implicit assignments of 'default' to non-explicitly assigned fields.†The 'this' object cannot be used before all of its fields have been assigned. Consider updating to language version '{0}' to auto-default the unassigned fields.¨The 'this' object cannot be used in a constructor before all of its fields have been assigned. Consider updating the language version to auto-default the unassigned fields.5Verwendung einer nicht zugewiesenen lokalen Variablen~Der Vergleich mit einer ganzzahligen Konstante ist nutzlos. Die Konstante befindet sich au√üerhalb des Bereichs vom Typ "{0}".ÖDer Vergleich zu einer integralen Konstante ist nutzlos; die Konstante befindet sich au√üerhalb des zul√§ssigen Bereichs f√ºr den TypO"{0}": Ein Verweis auf ein fl√ºchtiges Feld wird nicht als fl√ºchtig behandelt.œEin tempor√§res Feld sollte in der Regel nicht als ref- oder out-Wert verwendet werden, weil es nicht als tempor√§r behandelt wird. Es gibt jedoch Ausnahmen dazu, wie z. B. beim Aufruf einer Interlocked-API.GEin Verweis auf ein tempor√§res Feld wird nicht als tempor√§r behandelt#warning: "{0}"#Warnungsdirektive6Der XML-Kommentar enth√§lt ung√ºltigen XML-Code: "{0}".XML-Kommentar weist ein ung√ºltiges Format auf=Ung√ºltiger XML-Code in der enthaltenen Kommentardatei: "{0}"PXML-Dokument in der einbezogenen Kommentardatei weist ein ung√ºltiges Format auf!Falsche Anzahl von Typargumenten.SemanticModel "{0}" erwartet.GDie Literalzeichenfolge "]]>" ist in Inhaltselementen nicht zugelassen.Doppeltes Attribut "{0}".>Das Endtag "{0}" stimmt nicht mit dem Starttag "{1}" √ºberein.-Ein Endtag f√ºr Element "{0}" wurde erwartet.,An dieser Stelle wurde kein Endtag erwartet.;">" oder "/>" zum Schlie√üen des Tags "{0}" wurde erwartet.&Unerwartetes Zeichen an dieser Stelle.!Es wurde ein Bezeichner erwartet.1Im Kommentar wurde eine falsche Syntax verwendet.JInnerhalb eines Entit√§tsverweises wurde ein ung√ºltiges Zeichen gefunden.>Zeichen "{0}" k√∂nnen an dieser Stelle nicht verwendet werden.Ung√ºltiges Unicode-Zeichen.3An dieser Stelle sind keine Leerzeichen zugelassen.BDas Zeichen "<" kann in einem Attributwert nicht verwendet werden.@Das Gleichheitszeichen zwischen Attribut und Attributwert fehlt.,Verweis auf nicht definierte Entit√§t "{0}".HF√ºr das Zeichenfolgenliteral fehlt das schlie√üende Anf√ºhrungszeichen.cEin Zeichenfolgenliteral wurde erwartet, es wurde aber kein √∂ffnendes Anf√ºhrungszeichen gefunden.RZeichenfolgenliterale d√ºrfen nur von ASCII-Anf√ºhrungszeichen umschlossen werden.$Das erforderliche Leerzeichen fehlt.    tl¨¥Ê≥Ò&Å:f.∞¢cv ◊,∞üpÓyTE‡‰·'¡≤o∫Ï‰^î∏ dÃI…«≥Çnÿ}§!39oj
nﬂ-=ØÏﬂ’⁄ÓSÊ"Èm˘7„úbˆÊ“ó÷rêÂé–ögZÙ˘h[ó¬h:≤ôˆ6	3ç                           \         v                         h           _CorDllMain mscoree.dll     ˇ%                                                                                                                                           Ä                  0  Ä                   H   X  p          p4   V S _ V E R S I O N _ I N F O     ΩÔ˛   , ≈T         ?                         D    V a r F i l e I n f o     $    T r a n s l a t i o n       ∞–   S t r i n g F i l e I n f o   ¨   0 0 0 0 0 4 b 0   L   C o m p a n y N a m e     M i c r o s o f t   C o r p o r a t i o n   d   F i l e D e s c r i p t i o n     M i c r o s o f t . C o d e A n a l y s i s . C S h a r p   >   F i l e V e r s i o n     4 . 3 0 0 . 2 2 . 2 1 7 0 1     x ,  I n t e r n a l N a m e   M i c r o s o f t . C o d e A n a l y s i s . C S h a r p . r e s o u r c e s . d l l   Ä .  L e g a l C o p y r i g h t   ©   M i c r o s o f t   C o r p o r a t i o n .   A l l   r i g h t s   r e s e r v e d .   Ä ,  O r i g i n a l F i l e n a m e   M i c r o s o f t . C o d e A n a l y s i s . C S h a r p . r e s o u r c e s . d l l   \   P r o d u c t N a m e     M i c r o s o f t . C o d e A n a l y s i s . C S h a r p   ñ 9  P r o d u c t V e r s i o n   4 . 3 . 0 - 1 . 2 2 2 1 7 . 1 + 3 1 d 7 f 1 f 7 d a 0 0 f f c 8 a 6 a e a f 6 d e 9 7 1 5 9 e e 2 c a a 0 b a e     8   A s s e m b l y   V e r s i o n   4 . 3 . 0 . 0                                                                                                                                                                                                                                                                                                                                à1                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      Ä(    0Ç(p	*ÜHÜ˜†Ç(a0Ç(]10	`ÜHe 0\
+Ç7†N0L0
+Ç70	 †¢Ä 010	`ÜHe  YuBgÉä7Ω˝ÏÉ◊òÔÔÔ»≈–˜Êê,ﬁEÖäÈF—m†Ç0Çn0ÇV†3  ç~G√Ç~*    ç0	*ÜHÜ˜ 0~10	UUS10U
Washington10URedmond10U
Microsoft Corporation1(0&UMicrosoft Code Signing PCA 20110211014184514Z221013184514Z0c10	UUS10U
Washington10URedmond10U
Microsoft Corporation10U.NET0Ç¢0	*ÜHÜ˜ Çè 0ÇäÇÅ œßcÒêxE‹$∆€~≠2cÿçôˇØ¶≈Úøñ◊ã)mïòﬁ<√-¥X$VV\4{¸µk)Õ◊ÀˆÛ∞TË…”,àåÕOQ‘äÛy?‹ JS7˜/ˆoºjÁÑóó@Iı∆π∆6•∑¶Õç=›üºåµcˆ "k€ÁGëà˛V9Ñ∂ˇoÓΩ£nŸ%[é∞êµÂßÀÌ]ïØ"“„¸1´>`ñœÉÅÒ∏⁄{D„ÕE/.Ôä¡;Z5®N¥ıKÃìçGç"∑y93ù+^∂x‡Ø‡g–ä8**ì ;q´˘√NE5?97LËıIØç(.àŒ“™xËÂÕ∫áW9x:d¢dí´Û˘⁄£±<·˛œΩ$¸_:ˇ¶Z¿\ÖŸá^¸:ÏØòˆ&è]b˘Lx±¶AÎ¡·¯=Wà¶:˜-·Î]ìÀ¸¬R}ËÌ„Ò-®¢dù©¿{'Óg§ü#ÍU[ÿWío’Xü_2Ón›k»ë £Ç~0Çz0U%0
+Ç7L+0UØ1HE®	‡1Ëö«®†^^Œ0PUI0G§E0C1)0'U Microsoft Operations Puerto Rico10U464223+4686260U#0ÄHndÂP”Ç™77"µm® uï0TUM0K0I†G†EÜChttp://www.microsoft.com/pkiops/crl/MicCodSigPCA2011_2011-07-08.crl0a+U0S0Q+0ÜEhttp://www.microsoft.com/pkiops/certs/MicCodSigPCA2011_2011-07-08.crt0Uˇ0 0	*ÜHÜ˜ Ç *öFÓBä‹ø°ì^ ˇIÑÿ;IïùßÏmìƒÄémUá≥ÍÚo±—£Ö•
 Æñûù»1abÎÒ>ÛhöFÔπ1pﬁ¬¿<>w°¬sÆìñ"9ˇÆ~êx)˛DÀ^¨Ÿ	:ù4™˝ª Oûˆh)ˆ›ÂeÓí_πßZ~•EdDÖ ÄEÎÖö)9`?°Äñ`£{Õ5ÖQ 8ápÇ5Ã–¨BZ@TW¯3•oz{!h(TVâùR©ˇH˘iìÉ2ΩA+`O…ßû6òÔG¸˝◊*≥IÔ„
÷oç¸¡=qu‹à≠ÃúÊÿd*õÏêÕL˜—§™_)0ÖÄ$0ÔÛ6is˛˜Sèñ.–U€:rìäqú…Ä≈†]‡v>|–.Ñ0}§˚	qÀæ!%GH~((òÚÄ.lRod°&≈7u›ËMw‰¯ê˚/«yÌ…Í+m¿,ÖCàj¢Zô3ùZC_Â{BÑ√„ÏKkHÃçÊ∫{Ìùxü)2b7¯yG™@¿· 2µê◊ãZH™∫1•Õπ¡ö®,≈√Ú˛‚ùuÊ&[:éΩ¯ÎéÖµMkHf7ä`N–(•>îsÅïs&æ2Jªy›€√¬Ô~\ﬁu7µ|b€≠Ê<oj 5¢m√6ÈüT–Lx'$_)ÔCÃÄ95¨v0Çz0Çb†
aê“     0	*ÜHÜ˜ 0Åà10	UUS10U
Washington10URedmond10U
Microsoft Corporation1200U)Microsoft Root Certificate Authority 20110110708205909Z260708210909Z0~10	UUS10U
Washington10URedmond10U
Microsoft Corporation1(0&UMicrosoft Code Signing PCA 20110Ç"0	*ÜHÜ˜ Ç 0Ç
Ç ´˙r.≠ÿn™ÇM4∫Ú∂X!üB*kÈZP™∏8I∫√›7k∆ÿ8¬ô∞»9’1B”âydá~î`$lØûIúÈh^“ﬂõS≤
,√ØŸ©+Æz	Ø◊ñY `ÈfvË2R&/Á´Pœ≥D∑]ÿƒ.u´hÛÀmÛ:\°ÙF∫‡8d¨nd5x¶†c-”@ì¯„ﬁ’\y•I)Áæ†wæî=Ô˚„+ZMV(¢zr‡:∑I^ÿÌÌCëÉŸ{≤{ÜŸ>±å]ËâOÑÚ°/Y‰ê;-Æ3X≈∑>˛2”≥=±≤Øí8~“ùÄ,ıNVë!5%√9ndS∫ú≠#ÑÀÙ∫Üç˜_–Røåîáº¿!t%_(∂Ã'(8%ò9J6œ|±íÆ#ß©fÏaj·(Iù_à‚%]”!K>RƒµW?$—z[/’#„p]QFw≥¯ ·º¨Ç_€¿≥Ω‘UKÁ9°È#Iº∏D|E‰¡√rz‡rÁ$ﬂøFô≈Ô¬W€ÉçÏMI0ß´éﬂÏ[üØ¸›∞f‚¡óÅ{Ì÷ÌKÁI)ß(¶ß}gÄÊäbx_≤/Ñ◊Wú\øw((ÒÌm√(è,è@7O¡·ÖDâƒ	L≈‘•C/tï˜n¯x X,]`ïö>O3Ñ⁄∞àﬁûNÙñ∞ºF†lò“‡÷àå £ÇÌ0ÇÈ0	+Ç7 0UHndÂP”Ç™77"µm® uï0	+Ç7
 S u b C A0UÜ0Uˇ0ˇ0U#0Är-:1êCπN·Íß«1—#â40ZUS0Q0O†M†KÜIhttp://crl.microsoft.com/pki/crl/products/MicRooCerAut2011_2011_03_22.crl0^+R0P0N+0ÜBhttp://www.microsoft.com/pki/certs/MicRooCerAut2011_2011_03_22.crt0ÅüU Åó0Åî0Åë	+Ç7.0ÅÉ0?+3http://www.microsoft.com/pkiops/docs/primarycps.htm0@+042  L e g a l _ p o l i c y _ s t a t e m e n t . 0	*ÜHÜ˜ Ç gÚÜ•ò‡Ty.”ÿtg"õñ·cíôBñ}“yê¡e_.