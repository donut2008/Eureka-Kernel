 "{0}" wurde friend-Zugriff gew√§hrt, aber der starke Name zum Signieren der Ausgabeassembly stimmt nicht mit dem der gew√§hrenden Assembly √ºberein.pEin Funktionszeiger f√ºr "{0}" kann nicht erstellt werden, weil es sich nicht um eine statische Methode handelt.SFehlende √úbereinstimmung der Verweise zwischen "{0}" und dem Funktionszeiger "{1}"_Die Verwendung eines Funktionszeigertyps in "typeof" in einem Attribut wird nicht unterst√ºtzt.JEin Funktionszeiger kann nicht mit benannten Argumenten aufgerufen werden.F'{0}: Statische Typen k√∂nnen nicht als Typargumente verwendet werden.ÛDie Schnittstelle ‚Äû{3}‚Äú kann nicht als Typparameter ‚Äû{2}‚Äú im generischen Typ oder in der Methode ‚Äû{0}‚Äú verwendet werden. Die Einschr√§nkungsschnittstelle ‚Äû{1}‚Äú oder die Basisschnittstelle weist statische abstrakte Elemente auf.—Der Typ "{3}" kann nicht als Typparameter "{2}" im generischen Typ oder in der generischen Methode "{0}" verwendet werden. Der Typ "{3}", der NULL-Werte zul√§sst, entspricht nicht der Einschr√§nkung von "{1}".´Der Typ "{3}" kann nicht als Typparameter "{2}" im generischen Typ oder in der generischen Methode "{0}" verwendet werden. Der Typ "{3}", der NULL-Werte zul√§sst, entspricht nicht der Einschr√§nkung von "{1}". Typen, die NULL-Werte zulassen, k√∂nnen Schnittstelleneinschr√§nkungen nicht entsprechen.ƒDer Typ "{3}" kann nicht als Typparameter "{2}" im generischen Typ oder in der generischen Methode "{0}" verwendet werden. Es ist keine implizite Verweiskonvertierung von "{3}" in "{1}" vorhanden.ŸDer Typ "{3}" kann nicht als Typparameter "{2}" im generischen Typ oder in der generischen Methode "{0}" verwendet werden. Es ist keine Boxing-Konvertierung oder Typparameterkonvertierung von "{3}" in "{1}" vorhanden.∫Der Typ "{3}" kann nicht als Typparameter "{2}" im generischen Typ oder in der generischen Methode "{0}" verwendet werden. Es ist keine Boxing-Konvertierung von "{3}" in "{1}" vorhanden.√Der Typ "{0}" aus der Assembly "{1}" kann nicht√ºber Assemblygrenzen hinweg verwendet werden, da er ein generisches Typargument besitzt, bei dem es sich um einen eingebetteten Interoptyp handelt.ûDer Typ "{0}" kann nicht eingebettet werden, da er ein generisches Argument besitzt. Legen Sie die Eigenschaft "Interoptypen einbetten" ggf. auf "False" fest. get- oder set-Accessor erwartet.DAssembly- und Modulattribute sind in diesem Kontext nicht zul√§ssig.≠Assembly- und Modulattribute m√ºssen vor allen anderen in einer Datei definierten Elementen mit Ausnahme von using-Klauseln und externen Aliasdeklarationen angegeben werden.4Memberdefinition, Anweisung oder Dateiende erwartet.=Sie k√∂nnen den globalen externen Alias nicht neu definieren.yDer Typ- oder Namespacename "{0}" ist im globalen Namespace nicht vorhanden. (Fehlt m√∂glicherweise ein Assemblyverweis?)∞Der Typname "{0}" konnte nicht im globalen Namespace gefunden werden. Dieser Typ wurde an Assembly "{1}" weitergeleitet. Sie sollten einen Verweis auf die Assembly hinzuf√ºgen.QAusdr√ºcke und Anweisungen k√∂nnen nur in einem Methodenk√∂rper verwendet werden.WEine globale using-Anweisung kann nicht in einer Namespacedeklaration verwendet werden.TEine globale using-Anweisung muss allen nicht globalen using-Anweisungen vorangehen.eMit "goto" kann nicht an eine Position vor einer using-Deklaration im selben Block gesprungen werden.XMit "goto" kann nicht an eine Position hinter einer using-Deklaration gesprungen werden.V{1} "{0}" ist nicht generisch und kann daher nicht mit Typargumenten verwendet werden.TDas f√ºr diesen Parameter gefundene positionelle Element ‚Äû{0}‚Äú ist ausgeblendet.7"{0}" blendet den geerbten abstrakten Member "{1}" aus.Bezeichner erwartet.2Bezeichner erwartet; "{1}" ist ein Schl√ºsselwort.REin benutzerdefinierter Operator kann einen Typ nicht in sich selbst konvertieren.PEin __arglist-Ausdruck darf nur in einem call- oder new-Ausdruck enthalten sein.¥Die Sequenz von ‚Äû@‚Äú Zeichen ist nicht zul√§ssig. Eine ausf√ºhrliche Zeichenfolge oder ein Bezeichner darf nur ein ‚Äû@‚Äú-Zeichen und eine Rohzeichenfolge darf keine enthalten.Nicht erkannte Escapesequenz.≠Puffer fester Gr√∂√üe m√ºssen einen der folgenden Typen aufweisen: "bool", "byte", "short", "int", "long", "char", "sbyte", "ushort", "uint", "ulong", "float" oder "double".CUnsicherer Code wird m√∂glicherweise nicht in Iteratoren angezeigt.-"params" ist in diesem Kontext nicht g√ºltig.5"ref" und "out" sind in diesem Kontext nicht g√ºltig.wNur assignment-, call-, increment-, decrement-, await- und new-Objektausdr√ºcke k√∂nnen als Anweisung verwendet werden.>Ein Unterdr√ºckungsoperator ist in diesem Kontext unzul√§ssig.EUnsicherer Code wird nur angezeigt, wenn mit /unsafe kompiliert wird.0"__arglist" ist in diesem Kontext nicht g√ºltig.sUng√ºltiger Varianzmodifizierer. Nur Schnittstellen- und Delegattypparameter k√∂nnen als Variante angegeben werden.¯Die Einschr√§nkungen f√ºr den "{0}"-Typparameter der "{1}"-Methode m√ºssen mit den Einschr√§nkungen f√ºr den "{2}"-Typparameter der "{3}"-Schnittstellenmethode √ºbereinstimmen. Verwenden Sie stattdessen eine explizite Schnittstellenimplementierung.ßDie Tupelelementnamen in der Signatur der Methode "{0}" m√ºssen mit den Tupelelementnamen der Schnittstellenmethode "{1}" (auch f√ºr den R√ºckgabetyp) √ºbereinstimmen.IAn 'implicit' user-defined conversion operator cannot be declared checked¡"{0}" implementiert den Schnittstellenmember "{1}" nicht. "{2}" kann in C#-{3} nicht implizit einen nicht √∂ffentlichen Member implementieren. Verwenden Sie die Sprachversion "{4}" oder h√∂her.UDurch den Aufruf des impliziten Indexindexers kann das Argument nicht benannt werden.@Der Typ "{0}" darf nicht als Zieltyp von new() verwendet werden.&F√ºr "{0}" ist kein Zieltyp vorhanden.9Die Verwendung von new() ist in diesem Kontext ung√ºltig.XDurch den Aufruf des impliziten Bereichsindexers kann das Argument nicht benannt werden.HEs wurde kein optimaler Typ f√ºr das implizit typisierte Array gefunden.QImplizit typisierte lokale Variablen k√∂nnen nicht als "fixed" deklariert werden.jEin Verweis auf eine implizit typisierte out-Variable "{0}" ist in der gleichen Argumentliste unzul√§ssig.`Eine implizit typisierte Variable kann nicht mit einem Arrayinitialisierer initialisiert werden.H"{0}" kann einer implizit typisierten Variablen nicht zugewiesen werden.:Implizit typisierte Variablen k√∂nnen nicht konstant sein.KImplizit typisierte Variablen d√ºrfen nicht mehrere Deklaratoren aufweisen.;Implizit typisierte Variablen m√ºssen initialisiert werden.1Die referenzierte Datei "{0}" ist keine Assembly.UDer importierte Typ "{0}" ist ung√ºltig. Er enth√§lt eine Basistyp-Ringabh√§ngigkeit..Ein out-Parameter kann kein In-Attribut haben.gArgumente mit dem Modifizierer "in" k√∂nnen nicht in dynamisch gebundenen Ausdr√ºcken verwendet werden.'"in" erwartet.iDer erste Parameter der in-Erweiterungsmethode "{0}" muss ein konkreter (nicht generischer) Werttyp sein.åDie Eigenschaft oder der Indexer "{0}" kann in diesem Kontext nicht verwendet werden, da nicht auf den get-Accessor zugegriffen werden kann.åDie Eigenschaft oder der Indexer "{0}" kann in diesem Kontext nicht verwendet werden, da nicht auf den set-Accessor zugegriffen werden kann.ëZwei Indexer haben unterschiedliche Namen. Das IndexerName-Attribut muss f√ºr jeden Indexer in einem Typ mit dem gleichen Namen verwendet werden.qInkonsistente Verwendung des lambda-Parameters. Alle Parametertypen m√ºssen entweder explizit oder implizit sein.pDer Operand eines Inkrement- oder Dekrementoperators muss eine Variable, eine Eigenschaft oder ein Indexer sein.GAlle Argumente der indizierten Eigenschaft "{0}" m√ºssen optional sein.fDie indizierte Eigenschaft "{0}" besitzt nicht optionale Argumente, die bereitgestellt werden m√ºssen.(Indexer k√∂nnen keinen leeren Typ haben.J"{0}": Indexer k√∂nnen nicht in einer statischen Klasse deklariert werden.1Indexer m√ºssen mindestens einen Parameter haben.VDer Konstruktor "{0}" kann sich nicht √ºber einen anderen Konstruktor selbst aufrufen.úDas Erben von einem Datensatz mit einem versiegelten "Object.ToString" wird in C# {0} nicht unterst√ºtzt. Verwenden Sie die Sprachversion "{1}" oder h√∂her.Åinit-Zugriffsmethoden k√∂nnen nicht als schreibgesch√ºtzt markiert werden. Markieren Sie stattdessen "{0}" als schreibgesch√ºtzt.JEine by-reference-Variable kann nicht mit einem Wert initialisiert werden.IEine by-value-Variable kann nicht mit einem Verweis initialisiert werden.ﬂDie beste √úbereinstimmung f√ºr die √ºberladene {0}-Methode f√ºr das Sammlungsinitialisiererelement kann nicht verwendet werden. Die Add-Methoden von Sammlungsinitialisierern d√ºrfen keine ref- oder out-Parameter enthalten.“Die beste √úbereinstimmung f√ºr die √ºberladene "{0}"-Methode hat eine falsche Signatur f√ºr das Initialisiererelement. Das initialisierbare "Add" muss eine Instanzmethode sein, auf die zugegriffen werden kann.[Strukturen ohne explizite Konstruktoren k√∂nnen keine Member mit Initialisierern enthalten.NNur automatisch implementierte Eigenschaften k√∂nnen Initialisierer aufweisen.P"{0}": Instanzmember k√∂nnen nicht in einer statischen Klasse deklariert werden.NInstanzeigenschaften in Schnittstellen k√∂nnen keine Initialisierer aufweisen.BEs kann keine Instanz der statischen "{0}"-Klasse erstellt werden.@Ein Ausdruck ist zu lang oder zu komplex f√ºr eine Kompilierung."Division durch Konstante 0 (null).%Die integrale Konstante ist zu gro√ü.TTyp "byte", "sbyte", "short", "ushort", "int", "uint", "long" oder "ulong" erwartet.Ganzzahlwert erwartet.U{0}: Ein Instanzereignis in einer Schnittstelle kann keinen Initialisierer aufweisen.`Der bedingte Member "{0}" kann den Schnittstellenmember "{1}" im Typ "{2}" nicht implementieren.ÄDie Methode ‚ÄûUnmanagedCallersOnly‚Äú ‚Äû{0}‚Äú kann das Schnittstellenelement ‚Äû{1}‚Äú im Typ ‚Äû{2}‚Äú nicht implementieren.w"{0}" kann den Schnittstellenmember "{1}" in Typ "{2}" nicht implementieren, weil er einen __arglist-Parameter umfasst.}"{0}" in der expliziten Schnittstellendeklaration wurde unter den implementierbaren Membern der Schnittstelle nicht gefunden.<Schnittstellen k√∂nnen keine Instanzkonstruktoren enthalten.yKonvertierungs-, Gleichheits- oder Ungleichheitsoperatoren, die in Schnittstellen deklariert sind, m√ºssen abstrakt sein.5Schnittstellen k√∂nnen keine Instanzfelder enthalten.Interner Fehler im C#-Compiler.4Die eingebettete Interopmethode "{0}" enth√§lt Text.UDie eingebettete Interopstruktur "{0}" kann nur √∂ffentliche Instanzfelder enthalten.hDer Interoptyp "{0}" kann nicht eingebettet werden, da er nicht das erforderliche {1}-Attribut aufweist.¡Der Interoptyp "{0}", der sowohl in Assembly "{1}" als auch in Assembly "{2}" gefunden wurde, kann nicht eingebettet werden. Legen Sie die Eigenschaft "Interoptypen einbetten" auf "False" fest.√Das auf den Parameter ‚Äû{0}‚Äú angewendete InterpolatedStringHandlerArgumentAttribute ist falsch formatiert und kann nicht interpretiert werden. Erstellen Sie eine Instanz von ‚Äû{1}‚Äú manuell.ôDer Parameter "{0}" ist ein Argument f√ºr die interpolierte Zeichenfolgenhandlerkonvertierung f√ºr den Parameter "{1}", aber das entsprechende Argument wird nach dem Interpolierten Zeichenfolgenausdruck angegeben. Ordnen Sie die Argumente neu an, um "{0}" vor "{1}" zu verschieben.œDer Parameter "{0}" wird nicht explizit angegeben, sondern als Argument f√ºr die Interpolierte Zeichenfolgenhandlerkonvertierung f√ºr den Parameter "{1}" verwendet. Geben Sie den Wert von "{0}" vor "{1}" an.õEine Handlerkonstruktion einer interpolierten Zeichenfolgen kann keine dynamische Zeichenfolge verwenden. Erstellen Sie manuell eine Instanz von ‚Äû{0}‚Äú.íDie Interpolierte Zeichenfolgenhandlermethode "{0}" weist einen inkonsistenten R√ºckgabetyp auf. Es wird erwartet, dass "{1}" zur√ºckgegeben wird.åDie Handlermethode ‚Äû{0}‚Äú einer interpolierten Zeichenfolgen ist falsch formatiert. ‚ÄûVoid‚Äú oder ‚Äûbool‚Äú wird nicht zur√ºckgegeben.∞Handler-Konvertierungen interpolierter Zeichenfolgen die auf die Instanz verweisen, die gerade indiziert wird, k√∂nnen nicht in Indexer-Member-Initialisierern verwendet werden.DDie Adresse des angegebenen Ausdrucks kann nicht √ºbernommen werden.®Ung√ºltiger Deklarator eines anonymen Typmembers. Anonyme Typmember m√ºssen mit einer Memberzuweisung, einem einfachen Namen oder einem Memberzugriff deklariert werden.7Ung√ºltiger Rangbezeichner: Erwartet wird "," oder "]".OAssemblykultur-Zeichenfolgen d√ºrfen keine eingebetteten NUL-Zeichen enthalten.^Ausf√ºhrbare Dateien k√∂nnen keine Satellitenassemblys sein. Kulturen sollten immer leer sein.IDer Assemblyverweis "{0}" ist ung√ºltig und kann nicht aufgel√∂st werden.4Ung√ºltiger Wert f√ºr das Argument zum {0}-Attribut.˙"{0}" ist vom Typ "{1}". In einer Konstantendeklaration muss als Typ "sbyte", "byte", "short", "ushort", "int", "uint", "long", "ulong", "char", "float", "double", "decimal", "bool", "string", ein Enumerationstyp oder ein Verweistyp angegeben werden.nDie Debuginformationen der Methode "{0}" (Token 0x{1:X8}) k√∂nnen nicht aus der Assembly "{2}" gelesen werden./Ung√ºltiges Format f√ºr Debuginformationen: {0}ÇDer Delegat "{0}" weist keine Invoke-Methode oder eine Invoke-Methode mit nicht unterst√ºtzten R√ºckgabe- oder Parametertypen auf.äDer Ausdruck muss implizit in einen booleschen Ausdruck konvertiert werden k√∂nnen, oder der Typ "{0}" muss den Operator "{1}" definieren.Ung√ºltiger Ausdruck "{0}".*Ung√ºltige Dateiabschnittausrichtung "{0}"8Puffer fester Gr√∂√üe m√ºssen l√§nger als 0 (null) sein.PBefehlszeilen-Syntaxfehler: Ung√ºltiges GUID-Format "{0}" f√ºr die Option "{1}".}"{0}" ist kein g√ºltiger R√ºckgabetyp-Modifizierer f√ºr Funktionszeiger. G√ºltige Modifizierer sind "ref" und "ref readonly".S"{0}" ist kein g√ºltiger Aufrufkonventionsspezifizierer f√ºr einen Funktionszeiger.SEin ung√ºltiger Typ wurde als Argument f√ºr das TypeForwardedTo-Attribut angegeben.LEine "goto case"-Anweisung ist nur innerhalb einer switch-Anweisung g√ºltig.,Ung√ºltiger Name f√ºr Hashalgorithmus: "{0}"1Ung√ºltiger Deklarator des Initialisierermembers.%Ung√ºltiger Instrumentierungstyp: {0}1"{0}" ist kein g√ºltiger Parametername von "{1}".YDie Zeilennummer, die f√ºr die #line-Direktive angegeben wurde, fehlt oder ist ung√ºltig._Ung√ºltiges Token "{0}" in Klassen-, Datensatz-, Struktur- oder SchnittstellenmemberdeklarationpDer Modifizierer "{0}" ist f√ºr dieses Element in C# {1} ung√ºltig. Verwenden Sie Sprachversion {2} oder h√∂her.BDer Bezeichner oder ein einfacher Mitgliedszugriff wurde erwartet.:Ung√ºltiger Wert f√ºr das benannte Attributargument "{0}".Ung√ºltige Zahl.Ung√ºltige ObjekterstellungUng√ºltiger Ausgabename: {0})Die pathmap-Option war falsch formatiert."Ung√ºltiger Pr√§prozessorausdruck.VUng√ºltiger Name f√ºr ein Vorverarbeitungssymbol; "{0}" ist kein g√ºltiger Bezeichner.mDer Zugriffsmodifizierer des {0}-Accessors muss restriktiver sein als die Eigenschaft oder der Indexer "{1}".°readonly-Modifizierer k√∂nnen nicht sowohl f√ºr die Eigenschaft oder den Indexer "{0}" und den zugeh√∂rigen Accessor angegeben werden. Entfernen Sie einen davon.ÄDer Typ des bedingten Ausdrucks kann nicht bestimmt werden, weil keine implizite Konvertierung zwischen "{0}" und "{1}" erfolgt.'Ung√ºltiges Literal f√ºr reelle Zahlen.gIm AssemblySignatureKeyAttribute wurde ein √∂ffentlicher Schl√ºssel mit ung√ºltiger Signatur angegeben.*"{0}" ist kein g√ºltiger Formatbezeichner.0"Ung√ºltiger Rangspezifizierer: Erwartet wurde ]îUng√ºltige Version "{0}" f√ºr /subsystemversion. Die Version muss 6.02 oder h√∂her f√ºr ARM oder AppContainerExe sein, andernfalls 4.00 oder h√∂her.J"{0}" ist kein g√ºltiger Aufrufkonventionstyp f√ºr "UnmanagedCallersOnly".~Die angegebene Versionszeichenfolge entspricht nicht dem erforderlichen Format: Hauptversion[.Nebenversion[.Build[.Revision]]]âDie angegebene Versionszeichenfolge weist nicht das erforderliche Format auf: Hauptversion.Nebenversion.Build.Revision (ohne Platzhalter)ﬂDie angegebene Versionszeichenfolge enth√§lt Platzhalter, die mit Determinismus nicht kompatibel sind. Entfernen Sie die Platzhalter aus der Versionszeichenfolge, oder deaktivieren Sie Determinismus f√ºr diese Kompilierung.VDer Empf√§nger eines with-Ausdrucks muss einen g√ºltigen Typ (nicht "void") aufweisen.ëEs ist unzul√§ssig, den Nullable-Verweistyp "{0}?" in einem is-Ausdruck zu verwenden. Verwenden Sie stattdessen den zugrunde liegenden Typ "{0}".KEin Ausdruck vom Typ "{0}" kann niemals dem angegebenen Muster entsprechen.WDie Methode "{0}" mit einem Iteratorblock muss "async" lauten, um "{1}" zur√ºckzugeben.HDie Bezeichnung "{0}" ist im Bereich der goto-Anweisung nicht vorhanden.áDie Bezeichnung "{0}" f√ºhrt Shadowing f√ºr eine andere Bezeichnung mit demselben Namen in einem enthaltenen G√ºltigkeitsbereich durch.kDas kontextbezogene Schl√ºsselwort ‚Äûvar‚Äú kann nicht als expliziter Lambdar√ºckgabetyp verwendet werden.~Der erste Operand des "is"- oder "as"-Operators darf kein Lambdaausdruck, keine anonyme Methode und keine Methodengruppe sein.^Ein Lambdaausdruck mit Attributen kann nicht in eine Ausdrucksbaumstruktur konvertiert werden.JDie angegebene Sprachversion "{0}" darf keine f√ºhrenden Nullen enthalten.∞"{0}" kann den Schnittstellenmember "{1}" im Typ "{2}" nicht implementieren, weil das Feature "{3}" in C# {4} nicht verf√ºgbar ist. Verwenden Sie Sprachversion {5} oder h√∂her.{ erwartet.L'Syntax "id#" wird nicht mehr unterst√ºtzt. Verwenden Sie stattdessen "$id".}Die Zeile enth√§lt andere Leerzeichen als die schlie√üende Zeile des rohen Zeichenfolgenliterals: '{0}' im Vergleich zu '{1}'gDie Zeile beginnt nicht mit demselben Leerraum wie die schlie√üende Zeile des Rohzeichenfolgenliterals.TDie Endposition der #line-Anweisung muss gr√∂√üer oder gleich der Startposition seinPDer Wert der #line-Anweisung fehlt oder liegt au√üerhalb des g√ºltigen Bereichs.ZVerkn√ºpfte NETMODULE-Metadaten m√ºssen ein vollst√§ndiges PE-Abbild bereitstellen: "{0}".íListenmuster d√ºrfen nicht f√ºr einen Wert vom Typ ‚Äû{0}‚Äú verwendet werden. Es wurde keine geeignete L√§ngen- oder Anzahl-Eigenschaft gefunden.üLiterale vom Typ "double" k√∂nnen nicht implizit in den Typ "{1}" konvertiert werden. Verwenden Sie ein {0}-Suffix, um ein Literal mit diesem Typ zu erstellen.%"#load" ist nur in Skripts zul√§ssig.°Die Adressen von "{0}" (lokal) oder der entsprechenden Member k√∂nnen nicht √ºbernommen und in einer anonymen Methode oder einem Lambdaausdruck verwendet werden._Eine lokale Variable oder Funktion mit dem Namen "{0}" ist bereits in diesem Bereich definiert.tDie lokale Funktion "{0}" muss einen Textk√∂rper deklarieren, weil sie nicht als "static extern" gekennzeichnet ist.ÁEine lokale Variable oder ein Parameter namens "{0}" kann in diesem Bereich nicht deklariert werden, da der Name in einem einschlie√üenden lokalen Bereich zur Definition einer lokalen Variablen oder eines Parameters verwendet wird.ç"{0}": Ein Parameter, eine lokale Variable oder eine lokale Funktion kann nicht denselben Namen aufweisen wie der Typparameter einer Methode.ƒDurch Einbetten des Interoptyps "{0}" aus der Assembly "{1}" wird ein Namenskonflikt in der aktuellen Assembly verursacht. Legen Sie die Eigenschaft "Interoptypen einbetten" ggf. auf "False" fest.L"{0}" ist kein Referenztyp, wie er f√ºr die lock-Anweisung erforderlich ist.]In "{0}" kann kein Memberlookup ausgef√ºhrt werden, da es sich um einen Typparameter handelt.U"{0}" wurde importiert und kann deshalb nicht f√ºr die Main-Methode verwendet werden.ë"{0}", angegeben f√ºr die Main-Methode, muss ein nicht generischer Datensatz oder eine nicht generische Klasse, Struktur oder Schnittstelle sein.E"{0}", angegeben f√ºr die Main-Methode, konnte nicht gefunden werden.Es ist nicht m√∂glich, einen Zeiger f√ºr den verwalteten Typ ("{0}") zu deklarieren oder dessen Adresse oder Gr√∂√üe abzurufen.7Der verwaltete Typ "{0}" ist f√ºr Felder nicht g√ºltig.5Der verwaltete Typ "{0}" ist nur f√ºr Felder g√ºltig.EEin Ausdrucksbaumstruktur-Lambda darf keine Methodengruppe enthalten.ZDer Typ "{1}" definiert bereits einen Member namens "{0}" mit den gleichen Parametertypen.+Doppelte Initialisierung des Members "{0}".YDer Member "{0}" kann nicht initialisiert werden. Er ist kein Feld und keine Eigenschaft.F"{0}": Membernamen d√ºrfen nicht dem einschlie√üenden Typ entsprechen.-Die Methode muss einen R√ºckgabetyp besitzen.[Der Typ "{1}" reserviert bereits einen Member namens "{0}" mit den gleichen Parametertypen.Mergekonfliktmarker gefundenIDer Name "{0}" √ºberschreitet die maximal zul√§ssige L√§nge in Metadaten.,Metadatenverweise werden nicht unterst√ºtzt.EKeine √úberladung f√ºr "{0}" stimmt mit dem Delegaten "{1}" √ºberein.KKeine √úberladung f√ºr "{0}" stimmt mit dem Funktionszeiger "{1}" √ºberein.vDie Methodengruppe "{0}" kann nicht in den Nichtdelegattyp "{1}" konvertiert werden. Wollten Sie die Methode aufrufen?JEin Verweis auf die Variable mit dem Typ "{0}" kann nicht erstellt werden.êMethode "{0}" kann Schnittstellenaccessor "{1}" f√ºr Typ "{2}" nicht implementieren. Verwenden Sie eine explizite Schnittstellenimplementierung.Methodenname erwartet.bDer R√ºckgabetyp einer Methode, eines Delegaten oder eines Funktionszeigers kann nicht "{0}" sein.uBranches eines bedingten ref-Operators k√∂nnen nicht auf Variablen mit inkompatiblen Deklarationsbereichen verweisen.lUnerwartetes Schl√ºsselwort ‚ÄûDatensatz‚Äú. Meinten Sie ‚ÄûDatensatzstruktur‚Äú oder ‚ÄûDatensatzklasse‚Äú?[Segmentmuster d√ºrfen nur einmal und direkt innerhalb eines Listenmusters verwendet werden.XDie Methodengruppe kann nicht in den Funktionszeiger konvertiert werden (fehlt ein "&"?)Fehlendes Argument.YF√ºr die Arrayerstellung ist eine Arraygr√∂√üe oder ein Arrayinitialisierer erforderlich.ìDie verwaltete Co-Klassen-Wrapperklasse "{0}" f√ºr die "{1}"-Schnittstelle kann nicht gefunden werden. (M√∂glicherweise fehlt ein Assemblyverweis.)LBei Verwendung der /pdb-Option muss auch die /debug-Option verwendet werden.îF√ºr den Typ "{0}" mit {1} out-Parametern und einem void-R√ºckgabetyp wurde keine passende Dekonstruktionsinstanz oder Erweiterungsmethode gefunden.<Befehlszeilen-Syntaxfehler: Fehlende GUID f√ºr Option "{1}".qF√ºr die Quellschnittstelle "{0}" fehlt die Methode "{1}", die zum Einbetten des Ereignisses "{2}" notwendig ist.&Ein Verweis auf NETMODULE "{0}" fehlt.ODateiname in Anf√ºhrungszeichen, einzeilige Anmerkung oder Zeilenende erwartet.ÅEin partial-Modifizierer in der Deklaration des Typs "{0}" fehlt. Es ist eine andere partielle Deklaration dieses Typs vorhanden.Muster fehlt.5Der vom Compiler angeforderte Member "{0}.{1}" fehlt.vSchnittstelle "{0}" besitzt eine ung√ºltige Quellschnittstelle, die zum Einbetten von Ereignis "{1}" erforderlich ist.Ñ{0}: Das Instanzenfeld in Typen, die mit "StructLayout(LayoutKind.Explicit)" markiert sind, muss ein FieldOffset-Attribut aufweisen.cDer Verweis auf Typ "{0}" wurde angeblich in "{1}" deklariert, konnte jedoch nicht gefunden werden.öDer Verweis auf Typ "{0}" wurde angeblich in dieser Assembly definiert, aber er ist weder in der Quelle noch in einem der hinzugef√ºgten Module definiert.x"{0}" kann "{1}" nicht implementieren, da "{2}" ein Windows-Runtime-Ereignis und "{3}" ein regul√§res .NET-Ereignis ist.)Fehler beim Ausgeben von Modul "{0}": {1}[Der Modulinitialisierer kann nicht mit dem Attribut "UnmanagedCallersOnly" versehen werden.vDie Modulinitialisierermethode "{0}" darf nicht generisch sein und darf nicht in einem generischen Typ enthalten sein.JDie Modulinitialisierermethode "{0}" muss auf Modulebene zug√§nglich sein.=Ein Modulinitialisierer muss eine normale Membermethode sein.uDie Modulinitialisierermethode "{0}" muss statisch sein, darf keine Parameter enthalten und muss "void" zur√ºckgeben.|Der Schnittstellenmember "{0}" weist keine spezifischste Implementierung auf. Weder "{1}" noch "{2}" sind am spezifischsten.[In einer for-, using-, fixed- oder declaration-Anweisung kann nur ein Typ verwendet werden._Dasselbe Verzeichnis ({0}) darf nicht mehrere Konfigurationsdateien des Analysetools enthalten.ãF√ºr das Programm sind mehrere Einstiegspunkte definiert. Kompilieren Sie mit /main, um den Typ anzugeben, der den Einstiegspunkt enth√§lt.YDas Attribut [EnumeratorCancellation] kann nicht f√ºr mehrere Parameter verwendet werden.MDie Quelldatei darf nur eine Namespacedeklaration mit Dateibereich enthalten.‰Die asynchrone foreach-Anweisung kann f√ºr Variablen vom Typ "{0}" nicht verwendet werden, da sie mehrere Instanziierungen von "{1}" implementiert. Nehmen Sie eine Umwandlung in eine spezifische Schnittstelleninstanziierung vor.ŸDie foreach-Anweisung kann f√ºr Variablen vom Typ "{0}" nicht verwendet werden, da sie mehrere Instanziierungen von "{1}" implementiert. Nehmen Sie eine Umwandlung in eine spezifische Schnittstelleninstanziierung vor.^Nur eine partielle Deklaration eines einzelnen Datensatzes darf eine Parameterliste aufweisen.?Eine Foreach-Schleife muss die Iterationsvariablen deklarieren.êDamit "{0}" als Kurzschlussoperator anwendbar ist, muss der deklarierende Typ "{1}" einen Operator "true" und einen Operator "false" definieren.`By-value-R√ºckgaben k√∂nnen nur in Methoden verwendet werden, deren R√ºckgabe nach Wert erfolgt.fBy-reference-R√ºckgaben k√∂nnen nur in Methoden verwendet werden, deren R√ºckgabe als Verweis erfolgt.rDer Parameter ‚Äû{0}‚Äú kann nur eine Ausrufezeichen-NULL-√úberpr√ºfung in den Implementierungsmethoden aufweisen.VDie Kompilierungsoptionen "{0}" und "{1}" d√ºrfen nicht gleichzeitig verwendet werden.8Der Name "{0}" ist im aktuellen Kontext nicht vorhanden.pDer Name "{0}" ist im aktuellen Kontext nicht vorhanden. (M√∂glicherweise fehlt ein Verweis auf Assembly "{1}".)$Benanntes Attributargument erwartet.\Ein Arrayzugriff verf√ºgt m√∂glicherweise nicht √ºber einen benannten Argumentspezifizierer.ÃDie Spezifikationen f√ºr benannte Argumente m√ºssen nach Angabe aller festen Argumente aufgef√ºhrt werden. Verwenden Sie Sprachversion {0} oder h√∂her, um nicht nachfolgende benannte Argumente zuzulassen.ÜDie Spezifikationen f√ºr benannte Argumente m√ºssen in einem dynamischen Aufruf nach Angabe aller festen Argumente aufgef√ºhrt werden.qDas benannte {0}-Argument legt einen Parameter fest, f√ºr den bereits ein positionelles Argument angegeben wurde.LErweiterungsmethodengruppen sind als Argument f√ºr 'nameof' nicht zul√§ssig.UTypparameter sind in einer Methodengruppe als Argument f√ºr "nameof" nicht zul√§ssig.<Sie k√∂nnen einen Namespace nicht im Skriptcode deklarieren.kMember, wie z. B. Felder, Methoden oder Anweisungen k√∂nnen nicht direkt in einem Namespace enthalten sein.AEin Array mit einer negativen Gr√∂√üe kann nicht erstellt werden.>Mit "stackalloc" kann keine negative Gr√∂√üe verwendet werden.UDer in "{1}" gespeicherte Modulname "{0}" muss mit seinem Dateinamen √ºbereinstimmen.sDas Modul "{0}" wurde in dieser Assembly bereits definiert. Alle Module m√ºssen einen eindeutigen Dateinamen haben.7Die new()-Einschr√§nkung muss zuletzt angegeben werden.VDie new()-Einschr√§nkung kann nicht mit der unmanaged-Einschr√§nkung verwendet werden.SDie new()-Einschr√§nkung kann nicht mit der struct-Einschr√§nkung verwendet werden.nDer Interoptyp "{0}" kann nicht eingebettet werden. Verwenden Sie stattdessen die entsprechende Schnittstelle.≈"{2}" muss ein nicht abstrakter Typ mit einem √∂ffentlichen parameterlosen Konstruktor sein, um im generischen Typ oder in der generischen {0}-Methode als {1}-Parameter verwendet werden zu k√∂nnen.f"{0}": Beim Erstellen einer Instanz eines Variablentyps k√∂nnen keine Argumente bereitgestellt werden.@"{0}" ist ein neuer virtueller Member im versiegelten Typ "{1}".m'Mit dem Tupeltyp kann "new" nicht verwendet werden. Verwenden Sie stattdessen einen literalen Tupelausdruck.Zeilenvorschub in Konstante.¶Zeilenumbr√ºche innerhalb einer nicht ausf√ºhrlichen interpolierten Zeichenfolge werden in C#-{0} nicht unterst√ºtzt. Verwenden Sie die Sprachversion {1} oder h√∂her.Susing static-Anweisungen k√∂nnen nicht zum Deklarieren eines Alias verwendet werden:F√ºr einen base-Verweis ist eine Basisklasse erforderlich.PKeine einschlie√üende Schleife, aus der angehalten und fortgefahren werden kann.ãDer Interoptyp, der mit dem eingebetteten Interoptyp "{0}" √ºbereinstimmt, wurde nicht gefunden. M√∂glicherweise fehlt ein Assemblyverweis.4F√ºr den {0}-Typ sind keine Konstruktoren definiert.Ω"{0}": Der in einer asynchronen using-Anweisung verwendete Typ muss implizit in "System.IAsyncDisposable" konvertiert werden k√∂nnen oder eine geeignete DisposeAsync-Methode implementieren.Ì"{0}": Der in einer asynchronen using-Anweisung verwendete Typ muss implizit in "System.IAsyncDisposable" konvertiert werden k√∂nnen oder eine geeignete DisposeAsync-Methode implementieren. Meinten Sie "using" anstelle von "await using"?l"{0}": Der in einer using-Anweisung verwendete Typ muss implizit in "System.IDisposable" konvertierbar sein.ú"{0}": Der in einer using-Anweisung verwendete Typ muss implizit in "System.IDisposable" konvertierbar sein. Meinten Sie "await using" anstelle von "using"?òDas CallerArgumentExpressionAttribute kann nicht angewendet werden, da keine Standardkonvertierungen von Typ ‚Äû{0}‚Äú in Typ ‚Äû{1}‚Äú verf√ºgbar sind.ÇCallerFilePathAttribute kann nicht angewendet werden, da keine Standardkonvertierungen von Typ "{0}" in Typ "{1}" verf√ºgbar sind.ÑCallerLineNumberAttribute kann nicht angewendet werden, da keine Standardkonvertierungen von Typ "{0}" in Typ "{1}" verf√ºgbar sind.ÑCallerMemberNameAttribute kann nicht angewendet werden, da keine Standardkonvertierungen von Typ "{0}" in Typ "{1}" verf√ºgbar sind.ãEin Wert vom Typ "{0}" kann nicht als Standardparameter verwendet werden, da keine Standardkonvertierungen in den Typ "{1}" vorhanden sind.üEin Wert vom Typ "{0}" kann nicht als Standardparameter f√ºr den Parameter "{1}", der NULL-Werte zul√§sst, verwendet werden, weil "{0}" kein einfacher Typ ist.FIm Basistyp "{0}" wurde kein zug√§nglicher Kopierkonstruktor gefunden.XEs wurde kein Argument angegeben, das dem formalen Parameter "{0}" von "{1}" entspricht.nDas delegate-Schl√ºsselwort kann nicht als Einschr√§nkung verwendet werden. Meinten Sie ‚ÄûSystem.Delegate‚Äú?‰Der Aufruf von Methode "{0}" muss dynamisch gebunden werden, was jedoch nicht m√∂glich ist, da die Methode Teil eines Basiszugriffsausdrucks ist. Wandeln Sie ggf. die dynamischen Argumente um, oder l√∂schen Sie den Basiszugriff.ÆDer Konstruktoraufruf muss dynamisch gebunden werden. Dies ist aber nicht m√∂glich, da er Teil eines Konstruktorinitialisierers ist. Wandeln Sie die dynamischen Argumente um.ÀDer Indexerzugriff muss dynamisch gebunden werden. Dies ist aber nicht m√∂glich, da er Teil eines Basiszugriffsausdrucks ist. Wandeln Sie die dynamischen Argumente um, oder l√∂schen Sie den Basiszugriff.PDas Programm enth√§lt keine als Einstiegspunkt geeignete statische Main-Methode.tDas Schl√ºsselwort ‚Äûenum‚Äú kann nicht als Einschr√§nkung verwendet werden. Meinten Sie ‚Äûstruct, System.Enum‚Äú?ÀDer Typ "{0}" kann nicht mit einer Verweiskonvertierung, einer Boxing-Konvertierung, einer Unboxing-Konvertierung, einer Umbruchkonvertierung oder einer NULL-Typkonvertierung in "{1}" konvertiert werden.5Der Typ "{0}" kann nicht in "{1}" konvertiert werden.2Fehlende Dateispezifikation f√ºr die Option "{0}".["{0}": √úberschreiben nicht m√∂glich, weil "{1}" keinen √ºberschreibbaren get-Accessor hat.>Der Typ "{0}" kann nicht implizit in "{1}" konvertiert werden.ùDer Typ "{0}" kann nicht implizit in "{1}" konvertiert werden. Es ist bereits eine explizite Konvertierung vorhanden (m√∂glicherweise fehlt eine Umwandlung).ıDer bedingte Ausdruck ist in der Sprachversion {0} nicht g√ºltig, da zwischen ‚Äû{1}‚Äú und ‚Äû{2}‚Äú kein allgemeiner Typ gefunden wurde. Um eine Zielkonvertierung zu verwenden, f√ºhren Sie ein Upgrade auf die Sprachversion {3} oder h√∂her aus.0"{0}" hat keine passende statische Main-Methode.T/main kann beim Erstellen eines Moduls oder einer Bibliothek nicht angegeben werden.*Metadatendatei "{0}" wurde nicht gefunden.MModifizierer k√∂nnen nicht in Ereignisaccessordeklarationen platziert werden.IDie {0}-Klasse kann nicht mehrere Basisklassen aufweisen: "{1}" und "{2}"üDie in einem Namespace definierten Elemente d√ºrfen nicht explizit als "private", "protected", "protected internal" oder "private protected" deklariert werden.RNetzmodule k√∂nnen nicht mithilfe von "/refout" oder "/refonly" kompiliert werden.dEine Instanz des abstrakten Typs oder der abstrakten Schnittstelle "{0}" kann nicht erstellt werden.kEs kann keine Instanz des Variablentyps "{0}" erstellt werden, weil er keine new()-Einschr√§nkung aufweist.4Das Ausgabeverzeichnis konnte nicht bestimmt werden.\Aus Assembly "{0}" k√∂nnen keine Interoptypen eingebettet werden, da das {1}-Attribut fehlt.{Aus Assembly "{0}" k√∂nnen keine Interoptypen eingebettet werden, da entweder das {1}-Attribut oder das {2}-Attribut fehlt.¶Der Typ "{0}" kann nicht eingebettet werden, da es sich um einen geschachtelten Typ handelt. Legen Sie die Eigenschaft "Interoptypen einbetten" ggf. auf "False" fest.;Verwenden Sie "refout" nicht, wenn Sie "refonly" verwenden.["{0}": √úberschreiben nicht m√∂glich, weil "{1}" keinen √ºberschreibbaren set-Accessor hat.7Die Quelldatei "{0}" konnte nicht ge√∂ffnet werden: {1}+"{0}" enth√§lt keine Definition f√ºr "{1}".Ì"{0}" enth√§lt keine Definition f√ºr "{1}", und es konnte keine zug√§ngliche {1}-Erweiterungsmethode gefunden werden, die ein erstes Argument vom Typ "{0}" akzeptiert (m√∂glicherweise fehlt eine using-Direktive oder ein Assemblyverweis).“"{0}" enth√§lt keine Definition f√ºr "{1}", und es konnte keine {1}-Erweiterungsmethode gefunden werden, die ein erstes Argument vom Typ "{0}" akzeptiert (m√∂glicherweise fehlt eine using-Direktive f√ºr "{2}").zDer Typ "{0}" ist in einer nicht referenzierten Assembly definiert. F√ºgen Sie einen Verweis auf die Assembly "{1}" hinzu.kDer Typ "{0}" wurde in einem nicht hinzugef√ºgten Modul definiert. Sie m√ºssen das Modul "{1}" hinzuf√ºgen.FDas void-Schl√ºsselwort kann in diesem Kontext nicht verwendet werden. Ung√ºltiger Parametertyp "void".ADer Typ "{0}" in der Schnittstellenliste ist keine Schnittstelle.ODer nicht aufrufbare Member "{0}" kann nicht wie eine Methode verwendet werden.fDer Parameter ‚Äû{0}‚Äú ist ein Non-Nullable-Werttyp und kann nicht auf NULL-Werte √ºberpr√ºft werden.+Der Datensatzmember "{0}" muss privat sein./Der Datensatzmember "{0}" muss gesch√ºtzt sein.0Der Datensatzmember "{0}" muss √∂ffentlich sein.9Der parameterlose Strukturkonstruktor muss "public" sein.QEin Einstiegspunkt, der "void" oder "int" zur√ºckgibt, kann nicht asynchron sein."{0}" ist keine Attributklasse.2Der "{0}" zugewiesene Ausdruck muss konstant sein.≠Die Interpolation muss mit derselben Anzahl schlie√üender geschweiften Klammern enden wie die Anzahl von ‚Äû$‚Äú-Zeichen, mit denen das Rohzeichenfolgenliteral begonnen hat.LNicht gen√ºgend Anf√ºhrungszeichen f√ºr unformatierte Zeichenfolgenliterale.t‚Äû{0}‚Äú ist keine Instanzmethode, der Empf√§nger kann kein Handlerargument einer interpolierten Zeichenfolge sein.~"{0}" hat den Typ "{1}". Ein Konstantenfeld mit einem anderen Referenztyp als "String" kann nur mit NULL initialisiert werden.ã"{0}" hat den Typ "{1}". Ein standardm√§√üiger Parameterwert eines anderen Verweistyps als "String" kann nur mit NULL initialisiert werden.["{0}" muss √úberschreibungen zulassen, weil der enthaltende Datensatz nicht versiegelt ist.:Diese Sprachfunktion ("{0}") ist noch nicht implementiert.CDer out-Parameter ‚Äû{0}‚Äú kann nicht auf NULL √ºberpr√ºft werden.óNULL ist kein g√ºltiger Parametername. Um auf den Empf√§nger einer Instanzmethode zuzugreifen, verwenden Sie die leere Zeichenfolge als Parameternamen.8Die Verwendung von NULL ist in diesem Kontext ung√ºltig.TEin Ausdrucksbaumstruktur-Lambda darf keinen null propagierenden Operator enthalten.,"enable", "disable" oder "restore" erwartet.EErwartet wurde "warnings", "annotations" oder das Ende der Anweisung.\Ung√ºltiger Wert f√ºr "{0}": "{1}" f√ºr C# {2}. Verwenden Sie Sprachversion {3} oder h√∂her.äEin Parameter mit Nullable-Typ muss als Werttyp oder Nicht-Nullable-Verweistyp bekannt sein, es sei denn, die Sprachversion "{0}" oder h√∂her wird verwendet. Erw√§gen Sie, die Sprachversion zu √§ndern oder eine class-, struct- oder type-Einschr√§nkung hinzuzuf√ºgen.F"{0}" hat keine Basisklasse und kann keinen Basiskonstruktor aufrufen.]Die System.Object-Klasse kann keine Basisklasse haben oder eine Schnittstelle implementieren.sObjekt- und Sammlungsinitialisiererausdr√ºcke d√ºrfen nicht auf einen Delegaterstellungsausdruck angewendet werden.ÇAuf den Member "{0}" kann nicht mit einem Instanzverweis zugegriffen werden. Qualifizieren Sie ihn stattdessen mit einem Typnamen.iF√ºr das nicht statische Feld, die Methode oder die Eigenschaft "{0}" ist ein Objektverweis erforderlich.HDas Auslassen des Typarguments ist im aktuellen Kontext nicht zul√§ssig.∑Eine /reference-Option, die einen externen Alias deklariert, kann nur einen Dateinamen haben. Um mehrere Aliase oder Dateinamen festzulegen, verwenden Sie mehrere /reference-Optionen.0Nur Klassentypen k√∂nnen Destruktoren enthalten.CDer R√ºckgabetyp des True- oder False-Operators muss boolesch sein."Dateiende gefunden. "*/" erwartet.+Fehler beim √ñffnen der Antwortdatei "{0}".6User-defined operator '{0}' cannot be declared checked@Benutzerdefinierte Operatoren k√∂nnen nicht "void" zur√ºckgeben.P"{0}": Statische Klassen k√∂nnen keine benutzerdefinierten Operatoren enthalten.^F√ºr den Operator "{0}" muss au√üerdem ein √ºbereinstimmender Operator "{1}" definiert werden.VDer benutzerdefinierte {0}-Operator muss als statisch und √∂ffentlich deklariert sein..Die Option "{0}" muss ein absoluter Pfad sein.2Ein in-Parameter kann kein Out-Attribut aufweisen.cDas Out-Attribut kann f√ºr einen ref-Parameter nicht ohne Angabe des In-Attributs angegeben werden.GEine out-Variable kann nicht als lokales ref-Element deklariert werden.>F√ºr Ausgaben ohne Quelle muss die Option /out angeben werden.@In die Ausgabedatei "{0}" konnte nicht geschrieben werden: "{1}"~"{0}" kann kein √ºberladenes {1}-Element definieren, das sich nur in den Parametermodifizierern "{2}" und "{3}" unterscheidet.ÙDie Methode "{0}" gibt eine default-Einschr√§nkung f√ºr den Typparameter "{1}" an, aber der zugeh√∂rige Typparameter "{2}" der √ºberschriebenen oder explizit implementierten Methode "{3}" ist auf einen Verweistyp oder einen Werttyp beschr√§nkt.V√úberschreiben Sie nicht object.Finalize, sondern stellen Sie einen Destruktor bereit.C"{0}": Es wurde keine passende Methode zum √úberschreiben gefunden.gEin Member "{0}", der als "override" markiert ist, kann nicht als "new" oder "virtual" markiert werden.‘Die Methode "{0}" gibt eine class-Einschr√§nkung f√ºr den Typparameter "{1}" an, aber der zugeh√∂rige Typparameter "{2}" der au√üer Kraft gesetzten oder explizit implementierten Methode "{3}" ist kein Verweistyp.ﬂDie Methode "{0}" gibt eine struct-Einschr√§nkung f√ºr den Typparameter "{1}" an, aber der zugeh√∂rige Typparameter "{2}" der au√üer Kraft gesetzten oder explizit implementierten Methode "{3}" ist kein Non-Nullable-Werttyp.‚Einschr√§nkungen f√ºr Au√üerkraftsetzungs- und explizite Schnittstellenimplementierungsmethoden werden von der Basismethode geerbt und k√∂nnen daher nur f√ºr eine class- oder eine struct-Einschr√§nkung direkt angegeben werden.)√úberladbarer bin√§rer Operator erwartet. √úberladbarer Operator erwartet.(√úberladbarer un√§rer Operator erwartet.rDie Definition von Pr√§prozessorsymbolen kann nur vor dem ersten Token in der Datei vorgenommen/aufgehoben werden. Pr√§prozessordirektive erwartet.G"#Load" kann nicht nach dem ersten Token in der Datei verwendet werden.B#r kann nicht nach dem ersten Token in der Datei verwendet werden.9Der Parameter weist mehrere eindeutige Standardwerte auf.iDer out-Parameter "{0}" muss eine Zuweisung erhalten, bevor die Steuerung die aktuelle Methode verl√§sst.D"{0}": Statische Typen k√∂nnen nicht als Parameter verwendet werden.KDer Parameter ist f√ºr den angegebenen nicht verwalteten Typ nicht g√ºltig.<Der params-Parameter kann nicht als "{0}" deklariert werden.VEin params-Parameter muss der letzte Parameter in einer formellen Parameterliste sein.:Der params-Parameter muss ein eindimensionales Array sein.YBeide partiellen Methodendeklarationen m√ºssen identische Zugriffsmodifizierer aufweisen.çBeide partiellen Methodendeklarationen m√ºssen identische Kombinationen der Modifizierer "virtual", "override", "sealed" und "new" verwenden.ÉBeide partiellen Methodendeklarationen m√ºssen Erweiterungsmethoden sein, oder keine von beiden darf eine Erweiterungsmethode sein.èIn Ausdrucksb√§umen d√ºrfen weder partielle Methoden mit nur einer definierenden Deklaration noch entfernte bedingte Methoden verwendet werden.pPartielle Methodendeklarationen von "{0}" weisen inkonsistente Einschr√§nkungen f√ºr den Typparameter "{1}" auf.oDie beiden partiellen Methodendeklarationen ("{0}" und "{1}") m√ºssen die gleichen Tupelelementnamen verwenden.HEine partielle Methode darf nicht den Modifizierer "abstract" aufweisen.qF√ºr die implementierende Deklaration der partiellen Methode "{0}" wurde keine definierende Deklaration gefunden.QEine partielle Methode darf Schnittstellenmethoden nicht explizit implementieren.LEine partielle Methode muss innerhalb eines partiellen Typs deklariert sein.YEine partielle Methode darf nicht √ºber mehrere implementierende Deklarationen verf√ºgen.UEine partielle Methode darf nicht √ºber mehrere definierende Deklarationen verf√ºgen.çBeide partiellen Methodendeklarationen m√ºssen einen params-Parameter verwenden, oder keine von beiden darf einen params-Parameter verwenden.hEntweder beide oder keine der partiellen Methodendeklarationen m√ºssen als "readonly" festgelegt werden.YDeklarationen partieller Methoden m√ºssen √ºbereinstimmende Ref-R√ºckgabewerte aufweisen.WBeide Deklarationen der partiellen Methode m√ºssen den gleichen R√ºckgabetyp aufweisen.gBeide partiellen Methodendeklarationen m√ºssen statisch sein, oder keine von beiden darf statisch sein.ÜAus der {0}-Methode kann kein Delegat erstellt werden, da es sich um eine partielle Methode ohne implementierende Deklaration handelt.gBeide partiellen Methodendeklarationen m√ºssen unsicher sein, oder keine von beiden darf unsicher sein.oDie partielle Methode "{0}" muss einen Implementierungsteil aufweisen, weil sie Zugriffsmodifizierer verwendet.úDie partielle Methode "{0}" muss Zugriffsmodifizierer aufweisen, weil sie einen Modifizierer "virtual", "override", "sealed", "new" oder "extern" verwendet.yDie partielle Methode "{0}" muss Zugriffsmodifizierer aufweisen, weil sie einen R√ºckgabetyp mit R√ºckgabewert verwendet.bDie partielle Methode "{0}" muss Zugriffsmodifizierer aufweisen, weil sie out-Parameter verwendet.åDer partial-Modifizierer kann nur unmittelbar vor "class", "record", "struct", "interface" oder einem Methodenr√ºckgabetyp verwendet werden.iPartielle Deklarationen von "{0}" haben Zugriffsmodifizierer, die miteinander einen Konflikt verursachen.WPartielle Deklarationen von "{0}" d√ºrfen keine unterschiedlichen Basisklassen angeben.õPartielle Deklarationen von "{0}" m√ºssen entweder nur Klassen, nur Datensatzklassen, nur Strukturen, nur Datensatzstrukturen oder nur Schnittstellen sein.fPartielle Deklarationen von "{0}" weisen inkonsistente Einschr√§nkungen f√ºr den {1}-Typparameter auf.oPartielle Deklarationen von "{0}" m√ºssen die gleichen Typparameternamen in der gleichen Reihenfolge aufweisen.áPartielle Deklarationen von "{0}" m√ºssen die gleichen Typparameternamen und Varianzmodifizierer in der gleichen Reihenfolge aufweisen.>Der Typ "dynamic" darf nicht in einem Muster verwendet werden.ÖEs ist unzul√§ssig, den Nullable-Typ "{0}?" in einem Muster zu verwenden. Verwenden Sie stattdessen den zugrunde liegenden Typ "{0}".^A string 'null' constant is not supported as a pattern for '{0}'. Use an empty string instead.ëEin Ausdruck des Typs "{0}" kann nicht von einem Muster des Typs "{1}" in C# {2} verarbeitet werden. Verwenden Sie Sprachversion {3} oder h√∂her.XEin Ausdruck vom Typ "{0}" kann nicht von einem Muster vom Typ "{1}" verarbeitet werden.,Fehler beim Schreiben der Ausgabedatei: {0}.~Fehler beim Lesen der Datei "{0}", die f√ºr das benannte Argument "{1}" f√ºr das PermissionSet-Attribut angegeben wurde: "{2}"ÅFehler beim Aufl√∂sen des Dateipfads "{0}", der f√ºr das benannte Argument "{1}" f√ºr das PermissionSet-Attribut angegeben wurde./"is" und "as" sind keine g√ºltigen Zeigertypen.4Der Musterabgleich ist f√ºr Zeigertypen unzul√§ssig.JDer Text einer async-iterator-Methode muss eine yield-Anweisung enthalten.πDer Text einer async-iterator-Methode muss eine yield-Anweisung enthalten. Erw√§gen Sie das Entfernen von "async" aus der Methodendeklaration oder das Hinzuf√ºgen einer yield-Anweisung.RNegative Werte m√ºssen in runde Klammern gesetzt werden, um umgewandelt zu werden.ODer Member "{0}" wurde f√ºr den Typ "{1}" in der Assembly "{2}" nicht gefunden.@Der vordefinierte Typ "{0}" ist nicht definiert oder importiert.bDer vordefinierte Typ "{0}" wurde in mehreren referenzierten Assemblys deklariert: "{1}" und "{2}"4Der vordefinierte Typ "{0}" muss eine Struktur sein.@Der vordefinierte Typ "{0}" ist nicht definiert oder importiert.RDer SecurityAction-Wert "{0}" ist f√ºr das PrincipalPermission-Attribut ung√ºltig.F"{0}": Abstrakte Eigenschaften k√∂nnen keine private-Accessoren haben.O"{0}": Eigenschaften oder Indexer k√∂nnen nicht √ºber einen void-Typ verf√ºgen.rDie Eigenschaft oder der Indexer "{0}" kann in diesem Kontext nicht verwendet werden, weil der get-Accessor fehlt.èEin Eigenschaftsteilmuster erfordert einen Verweis auf die abzugleichende Eigenschaft oder das abzugleichende Feld. Beispiel: "{{ Name: {0} }}"M"{0}": Die Eigenschaft oder der Indexer muss mindestens einen Accessor haben.E"{0}": Statische Klassen d√ºrfen keine gesch√ºtzten Member enthalten.F"{0}": In der Struktur wurde ein neuer gesch√ºtzter Member deklariert.LDer *-Operator oder der ->-Operator muss auf einen Zeiger angewendet werden.4Ein Zeiger darf nur von einem Wert indiziert werden.aFehler beim Signieren der Ausgabe mit einem √∂ffentlichen Schl√ºssel aus dem Container "{0}": {1}]Fehler beim Signieren der Ausgabe mit einem √∂ffentlichen Schl√ºssel aus der Datei "{0}": {1}ô√ñffentliche Signierung wurde angegeben. F√ºr diese ist ein √∂ffentlicher Schl√ºssel erforderlich. Es wurde aber kein √∂ffentlicher Schl√ºssel angegeben.?√ñffentliche Signierung wird f√ºr Netmodule nicht unterst√ºtzt.2Die Bereichsvariable "{0}" ist bereits deklariert.ÜDer Name "{0}" ist auf der rechten Seite von "equals" nicht im Bereich. Vertauschen Sie die Ausdr√ºcke auf beiden Seiten von "equals".tF√ºr den Quelltyp "{0}" wurden mehrere Implementierungen des Abfragemusters gefunden. Mehrdeutiger Aufruf von "{1}".wEs konnte keine Implementierung des Abfragemusters f√ºr den Quelltyp "{0}" gefunden werden. "{1}" wurde nicht gefunden.≤Es konnte keine Implementierung des Abfragemusters f√ºr den Quelltyp "{0}" gefunden werden. "{1}" wurde nicht gefunden. Geben Sie den Typ der Bereichsvariablen "{2}" explizit an.€Es konnte keine Implementierung des Abfragemusters f√ºr den Quelltyp "{0}" gefunden werden. "{1}" wurde nicht gefunden. Fehlen m√∂glicherweise erforderliche Assemblyverweise oder eine using-Anweisung f√ºr "System.Linq"?TDie Bereichsvariable "{0}" kann nicht als out- oder ref-Parameter √ºbergeben werden.ÖDer Name "{0}" ist auf der linken Seite von "equals" nicht im Bereich. Vertauschen Sie die Ausdr√ºcke auf beiden Seiten von "equals".6"{0}" kann keiner Bereichsvariablen zugewiesen werden._Die Bereichsvariable "{0}" verursacht einen Konflikt mit einer fr√ºheren Deklaration von "{0}".UDer Bereichsvariablen "{0}" kann nichts zugewiesen werden, sie ist schreibgesch√ºtzt.cDie Bereichsvariable "{0}" darf nicht denselben Namen wie der Typparameter einer Methode aufweisen.eDer Typ des Ausdrucks in der {0}-Klausel ist falsch. Fehler beim Typr√ºckschluss im Aufruf von "{1}".gDer Typ eines Ausdrucks in der {0}-Klausel ist falsch. Fehler beim Typr√ºckschluss im Aufruf von "{1}".∞Ein Ausdruck vom Typ "{0}" ist in einer nachfolgenden from-Klausel in einem Abfrageausdruck mit dem Quelltyp "{1}" unzul√§ssig. Fehler beim Typr√ºckschluss im Aufruf von "{2}".RDas Rohzeichenfolgenliteraltrennzeichen muss sich in einer eigenen Zeile befindet.iMehrzeilige rohe Zeichenfolgenliterale sind nur in ausf√ºhrlichen interpolierten Zeichenfolgen zul√§ssig.TMehrzeilige Rohzeichenfolgenliterale m√ºssen mindestens eine Inhaltszeile enthalten.IRohzeichenfolgenliterale sind in Pr√§prozessordirektiven nicht zul√§ssig.} erwartet.√Der Typ "{0}" kann nicht eingebettet werden, weil er eine Neuabstraktion eines Members aus der Basisschnittstelle aufweist. Legen Sie die Eigenschaft "Interoptypen einbetten" ggf. auf FALSE fest.ò{0}: "readonly" kann f√ºr Accessoren nur verwendet werden, wenn die Eigenschaft oder der Indexer sowohl einen get- als auch einen set-Accessor aufweist.ùMember des schreibgesch√ºtzten Felds "{0}" vom Typ "{1}" k√∂nnen nicht mit einem Objektinitialisierer zugewiesen werden, da es sich um einen Werttyp handelt.]Der prim√§re Konstruktor verursacht einen Konflikt mit dem synthetisierten Kopierkonstruktor.–Ein in ‚Äûrecord struct‚Äú mit Parameterliste deklarierter Konstruktor muss √ºber einen ‚Äûthis‚Äú-Initialisierer verf√ºgen, der den prim√§ren Konstruktor oder einen explizit deklarierten Konstruktor aufruft.6Der Konstruktor "{0}" kann sich nicht selbst aufrufen.wDer Typ von "{0}" kann nicht abgeleitet werden, da der Initialisierer direkt oder indirekt auf die Definition verweist.oref-assign von "{1}" zu "{0}" ist nicht m√∂glich, weil "{1}" einen geringeren Escapebereich als "{0}" aufweist.JDer Ausdruck muss vom Typ "{0}" sein, weil er als Verweis zugewiesen wird.X'"await" kann nicht in einem Ausdruck mit einem bedingten ref-Operator verwendet werden.RDer Ausdruck muss vom Typ "{0}" sein, um dem alternativen ref-Wert zu entsprechen.UEntweder beide bedingten Operatorwerte m√ºssen ref-Werte sein oder keiner von beiden.ìDer Typ "{2}" muss ein Referenztyp sein, damit er als {1}-Parameter im generischen Typ oder in der generischen Methode "{0}" verwendet werden kann.êDer erste Parameter einer ref-Erweiterungsmethode "{0}" muss ein Werttyp oder ein generischer Typ sein, der auf die Struktur eingeschr√§nkt ist.UDie linke Seite einer ref-Zuweisung muss ein lokaler Verweis oder ein Parameter sein.:Ein ref- oder out-Wert muss eine zuweisbare Variable sein.?Ein ref- oder out-Parameter kann keinen Standardwert aufweisen.[Eine Eigenschaft oder ein Indexer kann nicht als out- oder ref-Parameter √ºbergeben werden.ZEigenschaften, deren R√ºckgabe als Verweis erfolgt, d√ºrfen keine set-Accessoren besitzen.WEigenschaften, deren R√ºckgabe als Verweis erfolgt, m√ºssen einen get-Accessor besitzennEin schreibgesch√ºtztes Feld kann (au√üer in einem Konstruktor) nicht als ref- oder out-Wert verwendet werden.Member des schreibgesch√ºtzten Felds "{0}" k√∂nnen (au√üer in einem Konstruktor) nicht als ref- oder out-Wert verwendet werden.Y"{0}" darf nicht als ref- oder out-Wert verwendet werden, weil ein Schreibschutz besteht.oFelder von "{0}" d√ºrfen nicht als ref- oder out-Wert verwendet werden, weil es sich um ein {1}-Objekt handelt.a"{0}" kann nicht als ref- oder out-Wert verwendet werden, weil es sich um ein {1}-Objekt handelt.w{0} "{1}" kann nicht als ref- oder out-Wert verwendet werden, weil es sich um eine schreibgesch√ºtzte Variable handelt.ÖMember von {0} "{1}" k√∂nnen nicht als ref- oder out-Wert verwendet werden, weil es sich um eine schreibgesch√ºtzte Variable handelt.ÑEin statisches schreibgesch√ºtztes Feld kann (au√üer in einem statischen Konstruktor) nicht als ref- oder out-Wert verwendet werden.ïFelder des statischen schreibgesch√ºtzten Felds "{0}" k√∂nnen (au√üer in einem statischen Konstruktor) nicht als ref- oder out-Wert verwendet werden.nDas lokale Element "{0}" kann nicht als Verweis zur√ºckgegeben werden, weil es kein lokales ref-Elelement ist.{Ein Member des lokalen Elements "{0}" kann nicht als Verweis zur√ºckgegeben werden, weil es kein lokales ref-Elelement ist.äEin Ausdruck kann in diesem Kontext nicht verwendet werden, weil er m√∂glicherweise nicht als Verweis √ºbergeben oder zur√ºckgegeben wird.eDer R√ºckgabeausdruck muss vom Typ "{0}" sein, weil die R√ºckgabe dieser Methode als Verweis erfolgt.ö"{0}" kann nicht als Verweis zur√ºckgegeben werden, weil das Element mit einem Wert initialisiert wurde, der nicht als Verweis zur√ºckgegeben werden kann.†Ein Member von "{0}" kann nicht als Verweis zur√ºckgegeben werden, weil er mit einem Wert initialisiert wurde, der nicht als Verweis zur√ºckgegeben werden kann.~Ein Parameter kann nicht als Verweis "{0}" zur√ºckgegeben werden, weil es sich nicht um einen ref- oder out-Parameter handelt.äEin Member des Parameters "{0}" kann nicht als Verweis zur√ºckgegeben werden, weil es sich nicht um einen ref- oder out-Parameter handelt.HDie Bereichsvariable "{0}" kann nicht als Verweis zur√ºckgegeben werden.WEin schreibgesch√ºtztes Feld kann nicht als schreibbarer Verweis zur√ºckgegeben werden.hMember des schreibgesch√ºtzten Felds "{0}" k√∂nnen nicht als schreibbarer Verweis zur√ºckgegeben werden.S"{0}" kann nicht als Verweis zur√ºckgegeben werden, weil ein Schreibschutz besteht.jFelder von "{0}" k√∂nnen nicht als Verweis zur√ºckgegeben werden, weil es sich um ein {1}-Element handelt.\"{0}" kann nicht als Verweis zur√ºckgegeben werden, weil es sich um ein {1}-Element handelt.ÇDie R√ºckgabe von {0} "{1}" als schreibbarer Verweis ist nicht m√∂glich, weil es sich um eine schreibgesch√ºtzte Variable handelt.åMember von {0} "{1}" k√∂nnen nicht als schreibbarer Verweis zur√ºckgegeben werden, weil es sich um eine schreibgesch√ºtzte Variable handelt.bEin statisches schreibgesch√ºtztes Feld kann nicht als schreibbarer Verweis zur√ºckgegeben werden.uFelder eines statischen schreibgesch√ºtzten Felds "{0}" k√∂nnen nicht als schreibbarer Verweis zur√ºckgegeben werden.WStrukturmember k√∂nnen nicht "this" oder andere Instanzmember als Verweis zur√ºckgeben.4"this" kann nicht als Verweis zur√ºckgegeben werden.Ñ'"await" kann nicht in einem Ausdruck verwendet werden, der einen Aufruf von "{0}" enth√§lt, weil die R√ºckgabe als Verweis erfolgt.´Der Lambdaausdruck eines Ausdrucksbaums darf keinen Aufruf einer Methode, einer Eigenschaft oder eines Indexers enthalten, deren bzw. dessen R√ºckgabe als Verweis erfolgt.E'{0}: Referenzstrukturen k√∂nnen keine Schnittstellen implementieren.w"{0}": Eine Einschr√§nkungsklasse kann nicht gleichzeitig mit einer class- oder struct-Einschr√§nkung angegeben werden. #r ist nur in Skripts zul√§ssig.GRelationale Muster d√ºrfen nicht f√ºr Gleitkomma-NaNs verwendet werden.pDer Assemblyname "{0}" ist reserviert und kann nicht als Verweis in einer interaktiven Sitzung verwendet werden.HDer Enumeratorname "{0}" ist reserviert und kann nicht verwendet werden.îAlle verkn√ºpften Ressourcen und Module m√ºssen einen eindeutigen Dateinamen haben. Der Dateiname "{0}" wurde in dieser Assembly mehrfach angegeben.JDer Ressourcenbezeichner "{0}" wurde in dieser Assembly bereits verwendet.]Da "{0}" "void" zur√ºckgibt, darf auf ein R√ºckgabeschl√ºsselwort kein Objektausdruck folgen.vEine anonyme Funktion, die in einen "void" zur√ºckgebenden Delegaten konvertiert wurde, kann keinen Wert zur√ºckgeben.KEin Objekt oder Typ ist erforderlich, der in "{0}" konvertiert werden kann.5"{0}": Nicht alle Codepfade geben einen Wert zur√ºck.ΩVon Iteratoren kann kein Wert zur√ºckgegeben werden. Verwenden Sie die "yield return"-Anweisung, um einen Wert zur√ºckzugeben, oder die "yield break"-Anweisung, um die Iteration zu beenden.UDer R√ºckgabewert von "{0}" ist keine Variable und kann daher nicht ge√§ndert werden.H'{0}: Statische Typen k√∂nnen nicht als R√ºckgabetypen verwendet werden.ù{0}: Die Zielruntime unterst√ºtzt keine covarianten Typen in √úberschreibungen. Der Typ muss "{2}" sein, um dem √ºberschriebenen Member "{1}" zu entsprechen.Ø{0}: Die Zielruntime unterst√ºtzt keine covarianten R√ºckgabetypen in √úberschreibungen. Der R√ºckgabetyp muss "{2}" sein, um dem √ºberschriebenen Member "{1}" zu entsprechen.VDie Standardschnittstellenimplementierung wird von der Zielruntime nicht unterst√ºtzt.ü"{0}" kann den Schnittstellenmember "{1}" im Typ "{2}" nicht implementieren, weil die Zielruntime die Standardschnittstellenimplementierung nicht unterst√ºtzt.§Die Zugriffsoptionen "protected", "protected internal" oder "private protected" werden von der Zielruntime f√ºr einen Member einer Schnittstelle nicht unterst√ºtzt.TDie Zielruntime unterst√ºtzt keine statischen abstrakten Elemente in Schnittstellen.≥‚Äû{0}‚Äú kann das Schnittstellenelement ‚Äû{1}‚Äú im Typ ‚Äû{2}‚Äú nicht implementieren, weil die Zielruntime keine statischen abstrakten Elemente in Schnittstellen unterst√ºtzt.yDie Zielruntime unterst√ºtzt keine erweiterbaren Aufrufkonventionen oder Standardaufrufkonventionen der Runtime-Umgebung./Der Typ "{1}" ist in "{0}" und "{2}" vorhanden.JDer Namespace "{1}" in "{0}" steht in Konflikt mit dem Typ "{3}" in "{2}".JDer Typ "{1}" in "{0}" steht in Konflikt mit dem Namespace "{3}" in "{2}".X"{0}" kann nicht versiegelt werden, weil der enthaltende Datensatz nicht versiegelt ist.G"{0}" ist keine √úberschreibung und kann daher nicht versiegelt werden.B{0}: Ein Typ kann nicht gleichzeitig statisch und versiegelt sein.TDas Sicherheitsattribut "{0}" weist einen ung√ºltigen SecurityAction-Wert "{1}" auf.oDer SecurityAction-Wert "{0}" ist ung√ºltig f√ºr Sicherheitsattribute, die auf eine Assembly angewendet werden.}Der SecurityAction-Wert "{0}" ist ung√ºltig f√ºr Sicherheitsattribute, die auf einen Typ oder eine Methode angewendet werden.¢Das Sicherheitsattribut "{0}" ist f√ºr diesen Deklarationstyp nicht g√ºltig. Sicherheitsattribute sind nur f√ºr Assembly-, Typ- und Methodendeklarationen g√ºltig.UDas erste Argument eines Sicherheitsattributs muss eine g√ºltige SecurityAction sein.RDas Sicherheitsattribut "{0}" kann nicht auf eine Async-Methode angewendet werden.òAsync-Methoden sind in Schnittstellen, Klassen, Strukturen, die die Attribute "SecurityCritical" oder "SecuritySafeCritical" aufweisen, nicht zul√§ssig.{ oder ; erwartet.{ oder ; oder => erwartet; erwartet.\In der Schl√ºsseldatei "{0}" fehlt der f√ºr die Signierung erforderliche private Schl√ºssel.2Der Datensatzmember "{0}" muss "{1}" zur√ºckgeben.u"/main" kann nicht angegeben werden, wenn eine Kompilierungseinheit mit Anweisungen der obersten Ebene vorhanden ist.BMindestens eine Anweisung der obersten Ebene darf nicht leer sein.ûDie lokale Variable oder die lokale Funktion "{0}", die in einer Anweisung der obersten Ebene in diesem Kontext deklariert wurde, kann nicht verwendet werden.LNur eine Kompilierungseinheit kann Anweisungen der obersten Ebene aufweisen.RDas Programm mit Anweisungen der obersten Ebene muss eine ausf√ºhrbare Datei sein.‡Ein aus einem Element bestehendes deconstruct-Muster erfordert zur Vermeidung einer Mehrdeutigkeit eine etwas andere Syntax. Es wird empfohlen, nach der schlie√üenden Klammer ")" einen discard-Kennzeichner "_" hinzuzuf√ºgen.[Ein einzeiliger Kommentar darf in einer interpolierten Zeichenfolge nicht verwendet werden.}Der Typ- oder Namespacename "{0}" wurde nicht gefunden (m√∂glicherweise fehlt eine using-Direktive oder ein Assemblyverweis).íDer Typname "{0}" wurde nicht gefunden. Dieser Typ wurde an Assembly "{1}" weitergeleitet. Sie sollten einen Verweis auf die Assembly hinzuf√ºgen.s"{0}" enth√§lt keine vordefinierte Gr√∂√üe, sizeof kann daher nur in einem ungesch√ºtzten Kontext verwendet werden.-Quelldateiverweise werden nicht unterst√ºtzt.GDer Schalter "/sourcelink" wird nur beim Ausgeben von PDB unterst√ºtzt.ûEine Instanz des Typs "{0}" kann nicht in einer geschachtelten Funktion, einem Abfrageausdruck, einem Iteratorblock oder einer Async-Methode verwendet werden.<Die Einschr√§nkung kann nicht die spezielle {0}-Klasse sein.\Die Umwandlung eines stackalloc-Ausdrucks vom Typ "{0}" in den Typ "{1}" ist nicht m√∂glich.L"stackalloc" darf nicht in einem catch- oder finally-Block verwendet werden.aEin Lambdaausdruck mit einem Anweisungstext kann nicht in einen Ausdrucksbaum konvertiert werden.3Der Datensatzmember "{0}" darf nicht statisch sein.UEine statische anonyme Funktion kann keinen Verweis auf "this" oder "base" enthalten.HEine statische anonyme Funktion kann keinen Verweis auf "{0}" enthalten.B"{1}": Von der statischen {0}-Klasse kann nicht abgeleitet werden.E"{0}": Statische Klassen k√∂nnen keine Schnittstellen implementieren.9"{0}": Ein statischer Konstruktor muss parameterlos sein.:Die Konstante "{0}" kann nicht als statisch markiert sein.N"{0}": Zugriffsmodifizierer sind bei statischen Konstruktoren nicht zul√§ssig.e"{0}": Ein statischer Konstruktor kann keinen expliziten this- oder base-Konstruktoraufruf enthalten.ÇDie statische {0}-Klasse kann nicht vom Typ "{1}" abgeleitet werden. Statische Klassen m√ºssen von einem Objekt abgeleitet werden.TEine statische lokale Funktion kann keinen Verweis auf "this" oder "base" enthalten.GEine statische lokale Funktion kann keinen Verweis auf "{0}" enthalten.EDer statische Member "{0}" kann nicht als "readonly" markiert werden.sDas statische Feld oder die statische Eigenschaft "{0}" kann nicht in einem Objektinitialisierer zugewiesen werden.;Ein statischer Member kann nicht als "{0}" markiert werden.hDas stdin-Argument "-" ist angegeben, aber die Eingabe wurde nicht vom Standardeingabestream umgeleitet.4Zeichenfolge muss mit Anf√ºhrungszeichen beginnen: "cEine ‚ÄûStruktur‚Äú mit Feldinitialisierern muss einen explizit deklarierten Konstruktor enthalten.RDer Strukturmember "{0}" vom Typ "{1}" verursacht eine Schleife im Strukturlayout.RDas FieldOffset-Attribut ist f√ºr statische oder konstante Felder nicht zul√§ssig.|Das FieldOffset-Attribut kann nur f√ºr Member des mit "StructLayout(LayoutKind.Explicit)" markierten Typs festgelegt werden.C"{0}": Strukturen k√∂nnen keine Basisklassenkonstruktoren aufrufen.JUnterausdruck kann nicht in einem Argument f√ºr "nameof" verwendet werden.©Das Muster kann nicht erreicht werden. Es wurde bereits von einem vorherigen Verzweigungsarm des Switch-Ausdrucks behandelt, oder es ist keine √úbereinstimmung m√∂glich.éDer Switch-Case kann nicht erreicht werden. Er wurde bereits von einem vorherigen Fall behandelt, oder es ist keine √úbereinstimmung m√∂glich.>Es wurde kein optimaler Typ f√ºr den switch-Ausdruck gefunden.=Der switch-Ausdruck muss ein Wert sein. Gefunden wurde "{0}".tDie Steuerung kann nicht von der abschlie√üenden case-Bezeichnung ("{0}") aus dem switch-Ausdruck √ºbergeben werden.YDas Steuerelement kann nicht von einer case-Bezeichnung ("{0}") zur n√§chsten fortfahren.PDer Ausdruck zur Steuerung von Schaltern muss in Klammern eingeschlossen werden.CBefehlszeilen-Syntaxfehler: In der Option "{0}" fehlt ":< Nummer>".<Befehlszeilen-Syntaxfehler: In der Option "{1}" fehlt "{0}".['"MethodImplOptions.Synchronized" kann nicht auf eine asynchrone Methode angewendet werden.Syntaxfehler. "{0}" erwartet.hSystem.Void kann nicht in C# verwendet werden. Sie k√∂nnen das void-Typobjekt mit typeof(void) abfragen.†Da "{0}" eine Async-Methode ist, die "Task" zur√ºckgibt, darf nach einem R√ºckgabeschl√ºsselwort kein Objektausdruck folgen. Wollten Sie "Task<T>" zur√ºckgeben?ùEin Async-Lambdaausdruck, der in einen "Task" zur√ºckgebenden Delegaten konvertiert wurde, kann keinen Wert zur√ºckgeben. Wollten Sie "Task<T>" zur√ºckgeben?BDas this-Schl√ºsselwort ist im aktuellen Kontext nicht verf√ºgbar.{Das this-Schl√ºsselwort ist in einer statischen Eigenschaft/Methode oder einem statischen Feldinitialisierer nicht g√ºltig.+Schl√ºsselwort "this" oder "base" erwartet.”Anonyme Methoden, Lambdaausdr√ºcke, Abfrageausdr√ºcke und lokale Funktionen innerhalb von Strukturen k√∂nnen nicht auf Instanzmember von "this" zugreifen. Kopieren Sie "this" in eine lokale Variable au√üerhalb der anonymen Methode, des Lambdaausdrucks, des Abfrageausdrucks oder der lokalen Funktion, und verwenden Sie die lokale Variable.5Ein throw-Ausdruck ist in diesem Kontext unzul√§ssig.YCatch-Klauseln k√∂nnen nicht auf die allgemeine catch-Klausel einer try-Anweisung folgen.#Zu viele Zeichen im Zeichenliteral.ØDas interpolierte Rohzeichenfolgenliteral beginnt nicht mit gen√ºgend ‚Äû$‚Äú-Zeichen, um so viele aufeinanderfolgende schlie√üende geschweifte Klammern als Inhalt zuzulassen.YNur 65534 lokale Variablen, einschlie√ülich der vom Compiler generierten, sind zul√§ssig.¨Das interpolierte Rohzeichenfolgenliteral beginnt nicht mit gen√ºgend ‚Äû$‚Äú-Zeichen, um so viele aufeinanderfolgende √∂ffnende geschweifte Klammern als Inhalt zuzulassen.ïDas Rohzeichenfolgenliteral beginnt nicht mit gen√ºgend Anf√ºhrungszeichen, um so viele aufeinanderfolgende Anf√ºhrungszeichen als Inhalt zuzulassen.ªDie kombinierte L√§nge der vom Programm verwendeten Benutzerzeichenfolgen √ºberschreitet den zul√§ssigen Grenzwert. Versuchen Sie, die Verwendung von Zeichenfolgenliteralen zu verringern.RAnweisungen der obersten Ebene m√ºssen vor Namespace- und Typdeklarationen stehen.DFormatbezeichner d√ºrfen keine nachgestellten Leerzeichen enthalten.Unerwartete Zeichenfolge "...".)Tupelelementnamen m√ºssen eindeutig sein.:Der Name "{0}" identifiziert nicht das Tupelelement "{1}".∂Es kann keine Klasse bzw. kein Member definiert werden, die oder der Tupel verwendet, weil der f√ºr den Compiler erforderliche Typ "{0}" nicht gefunden wurde. Fehlt ggf. ein Verweis?QTupelelementnamen sind auf der linken Seite einer Dekonstruktion nicht zul√§ssig.ìDer Tupelelementname "{0}" ist abgeleitet. Verwenden Sie Sprachversion {1} oder h√∂her, um nach dem abgeleiteten Namen auf ein Element zuzugreifen.=Der Tupelelementname "{0}" ist nur an Position {1} zul√§ssig.<Der Tupelelementname "{0}" ist an keiner Position zul√§ssig.ÛTupeltypen, die als Operanden eines ==- oder !=-Operators verwendet werden, m√ºssen √ºbereinstimmende Kardinalit√§ten aufweisen. Dieser Operator enth√§lt jedoch Tupeltypen der Kardinalit√§t "{0}" auf der linken und "{1}" auf der rechten Seite.2Das Tupel muss mindestens zwei Elemente enthalten.,"{1}" definiert nicht den Typparameter "{0}"8{1} "{0}" kann nicht mit Typargumenten verwendet werden.ΩDie Einschr√§nkungen "class", "struct", "unmanaged", "notnull" und "default" k√∂nnen nicht kombiniert oder dupliziert werden und m√ºssen in der Einschr√§nkungsliste zuerst angegeben werden.Typ erwartet.hDas Modul "{0}" in der Assembly "{1}" leitet den Typ "{2}" an mehrere Assemblys weiter: "{3}" und "{4}".]Der Typ der implizit typisierten Dekonstruktionsvariablen "{0}" kann nicht abgeleitet werden.RDer Typ der implizit typisierten out-Variablen "{0}" kann nicht abgeleitet werden.6"{0}" ist kein interpolierter Zeichenfolgenhandlertyp.YDer Typ "{0}" muss √∂ffentlich sein, damit er als Aufrufkonvention verwendet werden kann."Der Typ "{0}" ist nicht definiert.@Eine Typparameterdeklaration muss ein Bezeichner sein, kein Typ.HDer Typname "{0}" ist f√ºr die Verwendung durch den Compiler reserviert.¨NULL kann nicht in den {0}-Typparameter konvertiert werden, weil es sich m√∂glicherweise um einen Non-Nullable-Werttyp handelt. Verwenden Sie stattdessen ggf. default({0}).~Das kontextabh√§ngige Schl√ºsselwort "var" darf nur in einer lokalen Variablendeklaration oder im Skriptcode verwendet werden.rDas kontextabh√§ngige Schl√ºsselwort "var" darf nicht in der Deklaration einer Bereichsvariablen verwendet werden.aDer {0}-Typparameter hat den gleichen Namen wie der enthaltende Typ bzw. die enthaltende Methode.jDer erste Operand eines "as"-Operators ist unter Umst√§nden kein Tupelliteral ohne einen nat√ºrlichen Typ.™Auto-implemented property '{0}' must be fully assigned before control is returned to the caller. Consider updating to language version '{1}' to auto-default the property.ìField '{0}' must be fully assigned before control is returned to the caller. Consider updating to language version '{1}' to auto-default the field.EDas Ergebnis einer Unboxingkonvertierung kann nicht ge√§ndert werden.^Das schlie√üende Trennzeichen "}" fehlt f√ºr den interpolierten Ausdruck, der mit "{" beginnt.W{0}-Zeichen m√ºssen in interpolierten Zeichenfolgen (durch Verdoppeln) maskiert werden.)Unerwartetes Verwenden eines Aliasnamens.Unerwartete Argumentliste.1Typargumente sind im nameof-Operator unzul√§ssig.Unerwartetes Zeichen "{0}".#Unerwartete Pr√§prozessordirektive.0Unerwartete Verwendung eines generischen Namens.ÖEin Konstruktor, der in einem Datensatz mit Parameterliste deklariert ist, muss √ºber den Konstruktorinitialisierer "this" verf√ºgen.@Unzul√§ssiges Semikolon nach der Methode oder dem Accessorblock.Unerwartetes Token "{0}"=Unerwartete Verwendung eines ungebundenen generischen Namens._Ung√ºltige Varianz: Der Typparameter "{1}" muss {3} und g√ºltig f√ºr "{0}" sein. "{1}" ist {2}.£Ung√ºltige Varianz: Der Typparameter "{1}" muss "{3}" lauten und g√ºltig f√ºr "{0}" sein, sofern nicht Sprachversion {4} oder h√∂her verwendet wird. "{1}" ist {2}.ã"{0}" kann nicht gleichzeitig "{1}" und "{2}" implementieren, da diese f√ºr einige Typparameterersetzungen zusammengef√ºhrt werden k√∂nnen.?"{0}" implementiert den geerbten abstrakten Member "{1}" nicht.V"{0}" implementiert den Schnittstellenmember "{1}" nicht. "{2}" ist nicht √∂ffentlich.9"{0}" implementiert den Schnittstellenmember "{1}" nicht.n"{0}": Eine Einschr√§nkungsklasse kann nicht gleichzeitig mit einer unmanaged-Einschr√§nkung angegeben werden.üMethoden mit dem Attribut "UnmanagedCallersOnly" k√∂nnen keine generischen Typparameter aufweisen und d√ºrfen nicht in einem generischen Typ deklariert werden.ô"{0}" ist mit dem Attribut "UnmanagedCallersOnly" versehen und kann nicht direkt aufgerufen werden. Rufen Sie einen Funktionszeiger auf diese Methode ab.ß"{0}" ist mit dem Attribut "UnmanagedCallersOnly" versehen und kann nicht in einen Delegattyp konvertiert werden. Rufen Sie einen Funktionszeiger auf diese Methode ab.à"UnmanagedCallersOnly" kann nur auf gew√∂hnliche statische, nicht abstrakte Methoden oder statische lokale Funktionen angewendet werden.”Der Typ "{2}" muss, ebenso wie s√§mtliche Felder auf jeder Schachtelungsebene, ein Non-Nullable-Typ sein, wenn er als {1}-Parameter im generischen Typ oder in der generischen Methode "{0}" verwendet werden soll.rEine vorherige Catch-Klausel hat bereits alle Ausnahmen dieses oder eines √ºbergeordneten Typs abgefangen ("{0}").VAsync-Methoden d√ºrfen √ºber keine unsicheren Parameter oder R√ºckgabetypen verf√ºgen.IIteratoren d√ºrfen keine unsicheren Parameter oder yield-Typen aufweisen.ZZeiger und Puffer fester Gr√∂√üe k√∂nnen nur in einem unsicheren Kontext verwendet werden.MDer unsichere Typ "{0}" darf bei der Objekterstellung nicht verwendet werden.GDie Aufrufkonvention von "{0}" wird von der Sprache nicht unterst√ºtzt.ÑFehler beim transparenten Bezeichnermemberzugriff f√ºr Feld "{0}" von "{1}". Implementieren die abgefragten Daten das Abfragemuster?NListenmuster d√ºrfen nicht f√ºr einen Wert vom Typ ‚Äû{0}‚Äú verwendet werden.PRelationale Muster d√ºrfen nicht f√ºr einen Wert vom Typ "{0}" verwendet werden.OSegmentmuster d√ºrfen nicht f√ºr einen Wert vom Typ ‚Äû{0}‚Äú verwendet werden.+Nicht abgeschlossenes Zeichenfolgenliteral.%Nicht beendetes Zeichenfolgenliteral.:Verwendung der nicht zugewiesenen lokalen Variablen "{0}".>Verwendung des m√∂glicherweise nicht zugewiesenen Felds "{0}".nUse of possibly unassigned field '{0}'. Consider updating to language version '{1}' to auto-default the field.7Verwendung des nicht zugewiesenen out-Parameters "{0}".aVerwenden einer m√∂glicherweise nicht zugewiesenen, automatisch implementierten Eigenschaft "{0}"ÖUse of possibly unassigned auto-implemented property '{0}'. Consider updating to language version '{1}' to auto-default the property.†The 'this' object cannot be used before all of its fields have been assigned. Consider updating to language version '{0}' to auto-default the unassigned fields.}Eine using-Klausel muss allen anderen im Namespace definierten Elementen mit Ausnahme externer Aliasdeklarationen vorangehen.âEine using-Variable kann nicht direkt in einem switch-Abschnitt verwendet werden (erw√§gen Sie die Verwendung von geschweiften Klammern).ØEin switch-Ausdruck oder eine case-Bezeichnung muss den Typ "bool", "char", "string", "integral", "enum" oder einen entsprechenden Nullable-Typ in C# 6 oder fr√ºher aufweisen.õDer Typ "{2}" muss ein Non-Nullable-Werttyp sein, wenn er als {1}-Parameter im generischen Typ oder in der generischen Methode "{0}" verwendet werden soll.^NULL kann nicht in {0} konvertiert werden, weil es sich um einen Non-Nullable-Werttyp handelt.Syntaxfehler. Wert erwartet.rDie im Werttyp "{1}" definierte Erweiterungsmethode "{0}" kann nicht zum Erstellen von Delegaten verwendet werden.çMember der {0}-Eigenschaft vom Typ "{1}" k√∂nnen nicht mit einem Objektinitialisierer zugewiesen werden, da es sich um einen Werttyp handelt.VEin Ausdrucksbaumstruktur-Lambda darf keine Methode mit Variablenargumenten enthalten.DDie Variable des statischen Typs "{0}" kann nicht deklariert werden.1Die Syntax "var (...)" als lvalue ist reserviert.ÄDie Syntax "var" f√ºr ein Muster darf nicht zum Verweis auf einen Typen verwendet werden, "{0}" ist jedoch im Bereich enthalten.G__arglist ist in der Parameterliste von Async-Methoden nicht zul√§ssig.E"__arglist" ist in der Parameterliste von Iteratoren nicht zul√§ssig.YEin __arglist-Parameter muss der letzte Parameter in einer formellen Parameterliste sein.SDie lokale Variable "{0}" kann erst verwendet werden, nachdem sie deklariert wurde.úDie lokale Variable "{0}" kann erst verwendet werden, nachdem sie deklariert wurde. Bei der Deklaration der lokalen Variablen wird das Feld "{1}" verborgen.Enumerationen, Klassen und Strukturen k√∂nnen nicht in Schnittstellen mit Parametern vom Typ "in" oder "out" deklariert werden.A"{0}": Virtuelle oder abstrakte Member k√∂nnen nicht privat sein.5Ein Wert vom Typ "void" darf nicht zugewiesen werden.1Der Vorgang ist f√ºr void-Zeiger nicht definiert.4Ein Tupel darf keinen Wert vom Typ "void" enthalten.M"{0}": Ein Feld kann nicht gleichzeitig fl√ºchtig und schreibgesch√ºtzt sein.9"{0}": Ein fl√ºchtiges Feld kann nicht vom Typ "{1}" seinVEin Windows-Runtime-Ereignis darf nicht als out- oder ref-Parameter √ºbergeben werden.∫Ein generischer aufgaben√§hnlicher R√ºckgabetyp wurde erwartet, aber der Typ ‚Äû{0}‚Äú, der im Attribut ‚ÄûAsyncMethodBuilder‚Äú gefunden wurde, war nicht geeignet. Es muss sich um einen ungebundenen generischen Typ von Stelligkeit Eins handelt, und der enthaltende Typ (falls vorhanden) muss nicht generisch sein.>Die Aufrufkonvention von "{0}" ist nicht mit "{1}" kompatibel.mF√ºr den Abgleich von Tupeltyp "{0}" sind {1} Teilmuster erforderlich, aber es sind {2} Teilmuster vorhanden.dDie yield-Anweisung kann nicht in einer anonymen Methode oder einem Lambdaausdruck verwendet werden.EIn Skriptcode der obersten Ebene darf "yield" nicht verwendet werden.!Elemente k√∂nnen nicht NULL sein.)Algorithmus "{0}" wird nicht unterst√ºtzt8Die Codepage "{0}" ist ung√ºltig oder nicht installiert.AUnerwarteter Fehler beim Schreiben der Debuginformationen: "{0}".~Der Dateiname "{0}" ist leer, enth√§lt ung√ºltige Zeichen, weist eine Laufwerkangabe ohne absoluten Pfad auf oder ist zu lang.`Ung√ºltiger Zieltyp f√ºr /target: Sie m√ºssen "exe", "winexe", "library", oder "module" angeben.7Metadatendatei "{0}" konnte nicht ge√∂ffnet werden: {1}âDer kurze Dateiname "{0}" kann nicht erstellt werden, wenn bereits ein langer Dateiname mit dem gleichen kurzen Dateinamen vorhanden ist.MDer generische Parameter ist eine Definition, erwartet wurde ein Verweis {0}.WDie Verwenden-Anweisung f√ºr ‚Äû{0}‚Äú wurde zuvor als ‚ÄûGlobal verwenden‚Äú angezeigtHDie Verwenden-Anweisung wurde zuvor als ‚ÄûGlobal verwenden‚Äú angezeigt!Nicht verwendeter externer Alias. Nicht verwendeter externer Alias$Nicht erforderliche using-Direktive.#Nicht erforderliche using-Direktive5"{0}" ist kein g√ºltiger C#-Verbundzuweisungsvorgang.3"{0}" ist kein g√ºltiger C#-Konvertierungsausdruck.&Methodengruppeanonyme Methode6Au√üerkraftsetzung des asynchronen Methoden-Generators."await" in Catch-Bl√∂cken und Finally-Bl√∂ckenÇU
                             Visual C#-Compileroptionen

                       ‚Äì AUSGABEDATEIEN ‚Äì
-out:<Datei>                   Gibt den Namen der Ausgabedatei an (Standardeinstellung: Basisname der
                              Datei mit der Hauptklasse oder der ersten Datei).
-target:exe                   Erstellt eine ausf√ºhrbare Konsolendatei (Standardeinstellung)
                              (Kurzform: -t:exe).
-target:winexe                Erstellt eine ausf√ºhrbare Windows-Datei
                              (Kurzform: -t:winexe).
-target:library               Erstellt eine Bibliothek (Kurzform: -t:library).
-target:module                Erstellt ein Modul, das einer anderen Assembly
                              hinzugef√ºgt werden kann (Kurzform: -t:module).
-target:appcontainerexe       Erstellt eine ausf√ºhrbare App-Containerdatei
                              (Kurzform: -t:appcontainerexe).
-target:winmdobj              Erstellt eine Windows-Runtime-Zwischendatei, die
                              von WinMDExp verwendet wird (Kurzform: -t:winmdobj).
-doc:<Datei>                   Die zu generierende XML-Dokumentationsdatei.
-refout:<Datei>                Die zu generierende Referenzassemblyausgabe.
-platform:<Zeichenfolge>            Schr√§nkt ein, auf welchen Plattformen dieser Code ausgef√ºhrt werden kann: x86,
                              Itanium, x64, arm, arm64, anycpu32bitpreferred oder
                              anycpu. Die Standardeinstellung ist "anycpu".

                       ‚Äì EINGABEDATEIEN ‚Äì
-recurse:<Platzhalter>           Schlie√üt alle Dateien im aktuellen Verzeichnis und
                              in Unterverzeichnissen gem√§√ü Platzhalter-
                              spezifikationen ein.
-reference:<Alias>=<Datei>     Verweist auf Metadaten aus der angegebenen Assembly-
                              datei mithilfe eines angegebenen Alias (Kurzform: -r).
-reference:<Dateiliste>        Verweist auf Metadaten aus den angegebenen Assembly-
                              dateien (Kurzform: -r).
-addmodule:<Dateiliste>        Verkn√ºpft die angegebenen Module in dieser Assembly.
-link:<Dateiliste>             Bettet Metadaten der angegebenen Interop-
                              assemblydateien ein (Kurzform: -l).
-analyzer:<Dateiliste>         F√ºhrt die Analyse aus dieser Assembly aus
                              (Kurzform: -a).
-additionalfile:<Dateiliste>   Zus√§tzliche Dateien, die sich nicht direkt auf die Code-
                              generierung auswirken, aber von der Analyse zum Generieren von
                              Fehlern oder Warnungen verwendet werden k√∂nnen.
-embed                        Bettet alle Quelldateien in die PDB-Datei ein.
-embed:<Dateiliste>            Bettet bestimmte Dateien in die PDB-Datei ein.

                       ‚Äì RESSOURCEN ‚Äì
-win32res:<Datei>              Gibt eine Win32-Ressourcendatei (RES-Datei) an.
-win32icon:<Datei>             Verwendet dieses Symbol f√ºr die Ausgabe.
-win32manifest:<Datei>         Gibt eine Win32-Manifestdatei (XML-Datei) an.
-nowin32manifest              Schlie√üt das Win32-Standardmanifest nicht ein.
-resource:<resinfo>           Bettet die angegebene Ressource ein (Kurzform: -res).
-linkresource:<resinfo>       Verkn√ºpft die angegebene Ressource mit dieser Assembly
                              (Kurzform: -linkres). Dabei lautet das resinfo-Format
                              <Datei>[,<Zeichenfolgenname>[,public|private]]

                       ‚Äì CODEGENERIERUNG ‚Äì
-debug[+|-]                   Gibt Debuginformationen aus.
-debug:{full|pdbonly|portable|embedded}
                              Gibt den Debugtyp an ("full" ist der Standardwert,
                              "portable" ist ein plattform√ºbergreifendes Format,
                              "embedded" ist ein plattform√ºbergreifendes Format, das in die
                              Ziel-DLL oder -EXE eingebettet ist).
-optimize[+|-]                Aktiviert Optimierungen (Kurzform: -o)
-deterministic                Generiert eine deterministische Assembly
                              (einschlie√ülich Modulversion-GUID und Zeitstempel).
-refonly                      Generiert eine Referenzassembly anstelle der Hauptausgabe.
-instrument:TestCoverage      Generiert eine Assembly, die f√ºr die Erfassung
                              von Code Coverage-Informationen instrumentiert ist.
-sourcelink:<Datei>            Quelllinkinformationen zum Einbetten in PDB-Dateien.

                       ‚Äì FEHLER UND WARNUNGEN ‚Äì
-warnaserror[+|-]             Meldet alle Warnungen als Fehler.
-warnaserror[+|-]:<Warnungsliste> Meldet bestimmte Warnungen als Fehler 
                              (Verwendung von "nullable" f√ºr alle Warnungen zur NULL-Zul√§ssigkeit).
-warn:<n>                     Legt die Warnstufe fest (0¬†oder h√∂her) (Kurzform: -w).
-nowarn:<Warnungsliste>           Deaktiviert bestimmte Warnmeldungen
                              (Verwendung von "nullable" f√ºr alle Warnungen zur NULL-Zul√§ssigkeit).
-ruleset:<Datei>               Gibt eine Regelsatzdatei an, die bestimmte Diagnosevorg√§nge
                              deaktiviert.
-errorlog:<Datei>[,version=<sarif_version>]
                              Gibt eine Datei zur Protokollierung aller Diagnosevorg√§nge von Compiler und
                              Analyzer an.
                              sarif_version:{1|2|2.1} Standardwerte sind 1. 2 und 2.1,
                              beide beziehen sich auf SARIF-Version 2.1.0.
-reportanalyzer               Meldet zus√§tzliche Analyseinformationen wie etwa die
                              Ausf√ºhrungszeit.
-skipanalyzers[+|-]           √úberspringt die Ausf√ºhrung von Diagnoseanalysen.

                       ‚Äì SPRACHE ‚Äì
-checked[+|-]                 Generiert √úberlauf√ºberpr√ºfungen.
-unsafe[+|-]                  L√§sst "unsicheren" Code zu.
-define:<Symbolliste>         Definiert bedingte Kompilationssymbole (Kurz-
                              form: -d).
-langversion:?                Zeigt die zul√§ssigen Werte f√ºr die Sprachversion an.
-langversion:<Zeichenfolge>         Gibt die Sprachversion an:
                              "latest" (neueste Version, einschlie√ülich Nebenversionen),
                              "default" (die gleiche Version wie bei "latest"),
                              "latestmajor" (neueste Version, au√üer Nebenversionen),
                              "preview" (neueste Version, einschlie√ülich Features in der nicht unterst√ºtzten Vorschauversion)
                              oder bestimmte Versionen wie "6" oder "7.1".
-nullable[+|-]                Legt die Option f√ºr Nullw