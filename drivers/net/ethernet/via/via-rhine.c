konvertiert werden k√∂nnen, oder der Typ "{0}" muss den Operator "{1}" definieren.Ung√ºltiger Ausdruck "{0}".*Ung√ºltige Dateiabschnittausrichtung "{0}"8Puffer fester Gr√∂√üe m√ºssen l√§nger als 0 (null) sein.PBefehlszeilen-Syntaxfehler: Ung√ºltiges GUID-Format "{0}" f√ºr die Option "{1}".}"{0}" ist kein g√ºltiger R√ºckgabetyp-Modifizierer f√ºr Funktionszeiger. G√ºltige Modifizierer sind "ref" und "ref readonly".S"{0}" ist kein g√ºltiger Aufrufkonventionsspezifizierer f√ºr einen Funktionszeiger.SEin ung√ºltiger Typ wurde als Argument f√ºr das TypeForwardedTo-Attribut angegeben.LEine "goto case"-Anweisung ist nur innerhalb einer switch-Anweisung g√ºltig.,Ung√ºltiger Name f√ºr Hashalgorithmus: "{0}"1Ung√ºltiger Deklarator des Initialisierermembers.%Ung√ºltiger Instrumentierungstyp: {0}1"{0}" ist kein g√ºltiger Parametername von "{1}".YDie Zeilennummer, die f√ºr die #line-Direktive angegeben wurde, fehlt oder ist ung√ºltig._Ung√ºltiges Token "{0}" in Klassen-, Datensatz-, Struktur- oder SchnittstellenmemberdeklarationpDer Modifizierer "{0}" ist f√ºr dieses Element in C# {1} ung√ºltig. Verwenden Sie Sprachversion {2} oder h√∂her.BDer Bezeichner oder ein einfacher Mitgliedszugriff wurde erwartet.:Ung√ºltiger Wert f√ºr das benannte Attributargument "{0}".Ung√ºltige Zahl.Ung√ºltige ObjekterstellungUng√ºltiger Ausgabename: {0})Die pathmap-Option war falsch formatiert."Ung√ºltiger Pr√§prozessorausdruck.VUng√ºltiger Name f√ºr ein Vorverarbeitungssymbol; "{0}" ist kein g√ºltiger Bezeichner.ZDer prim√§re Konstruktorparameter ‚Äû{0}‚Äú kann in diesem Kontext nicht verwendet werden.mDer Zugriffsmodifizierer des {0}-Accessors muss restriktiver sein als die Eigenschaft oder der Indexer "{1}".°readonly-Modifizierer k√∂nnen nicht sowohl f√ºr die Eigenschaft oder den Indexer "{0}" und den zugeh√∂rigen Accessor angegeben werden. Entfernen Sie einen davon.ÄDer Typ des bedingten Ausdrucks kann nicht bestimmt werden, weil keine implizite Konvertierung zwischen "{0}" und "{1}" erfolgt.'Ung√ºltiges Literal f√ºr reelle Zahlen.gIm AssemblySignatureKeyAttribute wurde ein √∂ffentlicher Schl√ºssel mit ung√ºltiger Signatur angegeben.*"{0}" ist kein g√ºltiger Formatbezeichner.0"Ung√ºltiger Rangspezifizierer: Erwartet wurde ]îUng√ºltige Version "{0}" f√ºr /subsystemversion. Die Version muss 6.02 oder h√∂her f√ºr ARM oder AppContainerExe sein, andernfalls 4.00 oder h√∂her.J"{0}" ist kein g√ºltiger Aufrufkonventionstyp f√ºr "UnmanagedCallersOnly".ÑDie angegebene Versionszeichenfolge '{0}' entspricht nicht dem erforderlichen Format: Hauptversion[.Nebenversion[.Build[.Revision]]]èDie angegebene Versionszeichenfolge '{0}' weist nicht das erforderliche Format auf: Hauptversion.Nebenversion.Build.Revision (ohne Platzhalter)ÂDie angegebene Versionszeichenfolge '{0}' enth√§lt Platzhalter, die mit Determinismus nicht kompatibel sind. Entfernen Sie die Platzhalter aus der Versionszeichenfolge, oder deaktivieren Sie Determinismus f√ºr diese Kompilierung.VDer Empf√§nger eines with-Ausdrucks muss einen g√ºltigen Typ (nicht "void") aufweisen.ëEs ist unzul√§ssig, den Nullable-Verweistyp "{0}?" in einem is-Ausdruck zu verwenden. Verwenden Sie stattdessen den zugrunde liegenden Typ "{0}".KEin Ausdruck vom Typ "{0}" kann niemals dem angegebenen Muster entsprechen.WDie Methode "{0}" mit einem Iteratorblock muss "async" lauten, um "{1}" zur√ºckzugeben.HDie Bezeichnung "{0}" ist im Bereich der goto-Anweisung nicht vorhanden.áDie Bezeichnung "{0}" f√ºhrt Shadowing f√ºr eine andere Bezeichnung mit demselben Namen in einem enthaltenen G√ºltigkeitsbereich durch.kDas kontextbezogene Schl√ºsselwort ‚Äûvar‚Äú kann nicht als expliziter Lambdar√ºckgabetyp verwendet werden.~Der erste Operand des "is"- oder "as"-Operators darf kein Lambdaausdruck, keine anonyme Methode und keine Methodengruppe sein.^Ein Lambdaausdruck mit Attributen kann nicht in eine Ausdrucksbaumstruktur konvertiert werden.JDie angegebene Sprachversion "{0}" darf keine f√ºhrenden Nullen enthalten.∞"{0}" kann den Schnittstellenmember "{1}" im Typ "{2}" nicht implementieren, weil das Feature "{3}" in C# {4} nicht verf√ºgbar ist. Verwenden Sie Sprachversion {5} oder h√∂her.{ erwartet.L'Syntax "id#" wird nicht mehr unterst√ºtzt. Verwenden Sie stattdessen "$id".}Die Zeile enth√§lt andere Leerzeichen als die schlie√üende Zeile des rohen Zeichenfolgenliterals: '{0}' im Vergleich zu '{1}'gDie Zeile beginnt nicht mit demselben Leerraum wie die schlie√üende Zeile des Rohzeichenfolgenliterals.TDie Endposition der #line-Anweisung muss gr√∂√üer oder gleich der Startposition seinPDer Wert der #line-Anweisung fehlt oder liegt au√üerhalb des g√ºltigen Bereichs.tDie Direktive #line span erfordert Leerzeichen vor der ersten Klammer, vor dem Zeichen Offset und vor dem DateinamenZVerkn√ºpfte NETMODULE-Metadaten m√ºssen ein vollst√§ndiges PE-Abbild bereitstellen: "{0}".íListenmuster d√ºrfen nicht f√ºr einen Wert vom Typ ‚Äû{0}‚Äú verwendet werden. Es wurde keine geeignete L√§ngen- oder Anzahl-Eigenschaft gefunden.üLiterale vom Typ "double" k√∂nnen nicht implizit in den Typ "{1}" konvertiert werden. Verwenden Sie ein {0}-Suffix, um ein Literal mit diesem Typ zu erstellen.%"#load" ist nur in Skripts zul√§ssig.°Die Adressen von "{0}" (lokal) oder der entsprechenden Member k√∂nnen nicht √ºbernommen und in einer anonymen Methode oder einem Lambdaausdruck verwendet werden._Eine lokale Variable oder Funktion mit dem Namen "{0}" ist bereits in diesem Bereich definiert.tDie lokale Funktion "{0}" muss einen Textk√∂rper deklarieren, weil sie nicht als "static extern" gekennzeichnet ist.ÁEine lokale Variable oder ein Parameter namens "{0}" kann in diesem Bereich nicht deklariert werden, da der Name in einem einschlie√üenden lokalen Bereich zur Definition einer lokalen Variablen oder eines Parameters verwendet wird.ç"{0}": Ein Parameter, eine lokale Variable oder eine lokale Funktion kann nicht denselben Namen aufweisen wie der Typparameter einer Methode.ƒDurch Einbetten des Interoptyps "{0}" aus der Assembly "{1}" wird ein Namenskonflikt in der aktuellen Assembly verursacht. Legen Sie die Eigenschaft "Interoptypen einbetten" ggf. auf "False" fest.L"{0}" ist kein Referenztyp, wie er f√ºr die lock-Anweisung erforderlich ist.sDie Suche nach nicht virtuellen Elementen in ‚Äö{0}‚Äò ist nicht m√∂glich, da es sich um einen Typparameter handeltU"{0}" wurde importiert und kann deshalb nicht f√ºr die Main-Methode verwendet werden.ë"{0}", angegeben f√ºr die Main-Methode, muss ein nicht generischer Datensatz oder eine nicht generische Klasse, Struktur oder Schnittstelle sein.E"{0}", angegeben f√ºr die Main-Methode, konnte nicht gefunden werden.Es ist nicht m√∂glich, einen Zeiger f√ºr den verwalteten Typ ("{0}") zu deklarieren oder dessen Adresse oder Gr√∂√üe abzurufen.7Der verwaltete Typ "{0}" ist f√ºr Felder nicht g√ºltig.5Der verwaltete Typ "{0}" ist nur f√ºr Felder g√ºltig.EEin Ausdrucksbaumstruktur-Lambda darf keine Methodengruppe enthalten.ZDer Typ "{1}" definiert bereits einen Member namens "{0}" mit den gleichen Parametertypen.+Doppelte Initialisierung des Members "{0}".YDer Member "{0}" kann nicht initialisiert werden. Er ist kein Feld und keine Eigenschaft.F"{0}": Membernamen d√ºrfen nicht dem einschlie√üenden Typ entsprechen.-Die Methode muss einen R√ºckgabetyp besitzen.[Der Typ "{1}" reserviert bereits einen Member namens "{0}" mit den gleichen Parametertypen.Mergekonfliktmarker gefundenIDer Name "{0}" √ºberschreitet die maximal zul√§ssige L√§nge in Metadaten.,Metadatenverweise werden nicht unterst√ºtzt.EKeine √úberladung f√ºr "{0}" stimmt mit dem Delegaten "{1}" √ºberein.KKeine √úberladung f√ºr "{0}" stimmt mit dem Funktionszeiger "{1}" √ºberein.vDie Methodengruppe "{0}" kann nicht in den Nichtdelegattyp "{1}" konvertiert werden. Wollten Sie die Methode aufrufen?JEin Verweis auf die Variable mit dem Typ "{0}" kann nicht erstellt werden.êMethode "{0}" kann Schnittstellenaccessor "{1}" f√ºr Typ "{2}" nicht implementieren. Verwenden Sie eine explizite Schnittstellenimplementierung.Methodenname erwartet.bDer R√ºckgabetyp einer Methode, eines Delegaten oder eines Funktionszeigers kann nicht "{0}" sein.uBranches eines bedingten ref-Operators k√∂nnen nicht auf Variablen mit inkompatiblen Deklarationsbereichen verweisen.lUnerwartetes Schl√ºsselwort ‚ÄûDatensatz‚Äú. Meinten Sie ‚ÄûDatensatzstruktur‚Äú oder ‚ÄûDatensatzklasse‚Äú?[Segmentmuster d√ºrfen nur einmal und direkt innerhalb eines Listenmusters verwendet werden./Unerwartetes Schl√ºsselwort "nicht √ºberpr√ºft"XDie Methodengruppe kann nicht in den Funktionszeiger konvertiert werden (fehlt ein "&"?)Fehlendes Argument.YF√ºr die Arrayerstellung ist eine Arraygr√∂√üe oder ein Arrayinitialisierer erforderlich.ìDie verwaltete Co-Klassen-Wrapperklasse "{0}" f√ºr die "{1}"-Schnittstelle kann nicht gefunden werden. (M√∂glicherweise fehlt ein Assemblyverweis.)LBei Verwendung der /pdb-Option muss auch die /debug-Option verwendet werden.îF√ºr den Typ "{0}" mit {1} out-Parametern und einem void-R√ºckgabetyp wurde keine passende Dekonstruktionsinstanz oder Erweiterungsmethode gefunden.<Befehlszeilen-Syntaxfehler: Fehlende GUID f√ºr Option "{1}".qF√ºr die Quellschnittstelle "{0}" fehlt die Methode "{1}", die zum Einbetten des Ereignisses "{2}" notwendig ist.&Ein Verweis auf NETMODULE "{0}" fehlt.ODateiname in Anf√ºhrungszeichen, einzeilige Anmerkung oder Zeilenende erwartet.ÅEin partial-Modifizierer in der Deklaration des Typs "{0}" fehlt. Es ist eine andere partielle Deklaration dieses Typs vorhanden.Muster fehlt.5Der vom Compiler angeforderte Member "{0}.{1}" fehlt.vSchnittstelle "{0}" besitzt eine ung√ºltige Quellschnittstelle, die zum Einbetten von Ereignis "{1}" erforderlich ist.Ñ{0}: Das Instanzenfeld in Typen, die mit "StructLayout(LayoutKind.Explicit)" markiert sind, muss ein FieldOffset-Attribut aufweisen.cDer Verweis auf Typ "{0}" wurde angeblich in "{1}" deklariert, konnte jedoch nicht gefunden werden.öDer Verweis auf Typ "{0}" wurde angeblich in dieser Assembly definiert, aber er ist weder in der Quelle noch in einem der hinzugef√ºgten Module definiert.x"{0}" kann "{1}" nicht implementieren, da "{2}" ein Windows-Runtime-Ereignis und "{3}" ein regul√§res .NET-Ereignis ist.)Fehler beim Ausgeben von Modul "{0}": {1}[Der Modulinitialisierer kann nicht mit dem Attribut "UnmanagedCallersOnly" versehen werden.vDie Modulinitialisierermethode "{0}" darf nicht generisch sein und darf nicht in einem generischen Typ enthalten sein.JDie Modulinitialisierermethode "{0}" muss auf Modulebene zug√§nglich sein.=Ein Modulinitialisierer muss eine normale Membermethode sein.tDie Modulinitialisierermethode "{0}" muss statisch sein, darf keine Parameter enthalten und muss "void" zur√ºckgeben|Der Schnittstellenmember "{0}" weist keine spezifischste Implementierung auf. Weder "{1}" noch "{2}" sind am spezifischsten.[In einer for-, using-, fixed- oder declaration-Anweisung kann nur ein Typ verwendet werden._Dasselbe Verzeichnis ({0}) darf nicht mehrere Konfigurationsdateien des Analysetools enthalten.ãF√ºr das Programm sind mehrere Einstiegspunkte definiert. Kompilieren Sie mit /main, um den Typ anzugeben, der den Einstiegspunkt enth√§lt.YDas Attribut [EnumeratorCancellation] kann nicht f√ºr mehrere Parameter verwendet werden.MDie Quelldatei darf nur eine Namespacedeklaration mit Dateibereich enthalten.‰Die asynchrone foreach-Anweisung kann f√ºr Variablen vom Typ "{0}" nicht verwendet werden, da sie mehrere Instanziierungen von "{1}" implementiert. Nehmen Sie eine Umwandlung in eine spezifische Schnittstelleninstanziierung vor.ŸDie foreach-Anweisung kann f√ºr Variablen vom Typ "{0}" nicht verwendet werden, da sie mehrere Instanziierungen von "{1}" implementiert. Nehmen Sie eine Umwandlung in eine spezifische Schnittstelleninstanziierung vor.NNur eine einzelne partielle Typdeklaration darf eine Parameterliste aufweisen.?Eine Foreach-Schleife muss die Iterationsvariablen deklarieren.êDamit "{0}" als Kurzschlussoperator anwendbar ist, muss der deklarierende Typ "{1}" einen Operator "true" und einen Operator "false" definieren.`By-value-R√ºckgaben k√∂nnen nur in Methoden verwendet werden, deren R√ºckgabe nach Wert erfolgt.fBy-reference-R√ºckgaben k√∂nnen nur in Methoden verwendet werden, deren R√ºckgabe als Verweis erfolgt.VDie Kompilierungsoptionen "{0}" und "{1}" d√ºrfen nicht gleichzeitig verwendet werden.8Der Name "{0}" ist im aktuellen Kontext nicht vorhanden.pDer Name "{0}" ist im aktuellen Kontext nicht vorhanden. (M√∂glicherweise fehlt ein Verweis auf Assembly "{1}".)$Benanntes Attributargument erwartet.\Ein Arrayzugriff verf√ºgt m√∂glicherweise nicht √ºber einen benannten Argumentspezifizierer.ÃDie Spezifikationen f√ºr benannte Argumente m√ºssen nach Angabe aller festen Argumente aufgef√ºhrt werden. Verwenden Sie Sprachversion {0} oder h√∂her, um nicht nachfolgende benannte Argumente zuzulassen.ÜDie Spezifikationen f√ºr benannte Argumente m√ºssen in einem dynamischen Aufruf nach Angabe aller festen Argumente aufgef√ºhrt werden.qDas benannte {0}-Argument legt einen Parameter fest, f√ºr den bereits ein positionelles Argument angegeben wurde.LErweiterungsmethodengruppen sind als Argument f√ºr 'nameof' nicht zul√§ssig.UTypparameter sind in einer Methodengruppe als Argument f√ºr "nameof" nicht zul√§ssig.<Sie k√∂nnen einen Namespace nicht im Skriptcode deklarieren.kMember, wie z. B. Felder, Methoden oder Anweisungen k√∂nnen nicht direkt in einem Namespace enthalten sein.AEin Array mit einer negativen Gr√∂√üe kann nicht erstellt werden.>Mit "stackalloc" kann keine negative Gr√∂√üe verwendet werden.UDer in "{1}" gespeicherte Modulname "{0}" muss mit seinem Dateinamen √ºbereinstimmen.sDas Modul "{0}" wurde in dieser Assembly bereits definiert. Alle Module m√ºssen einen eindeutigen Dateinamen haben.7Die new()-Einschr√§nkung muss zuletzt angegeben werden.VDie new()-Einschr√§nkung kann nicht mit der unmanaged-Einschr√§nkung verwendet werden.SDie new()-Einschr√§nkung kann nicht mit der struct-Einschr√§nkung verwendet werden.nDer Interoptyp "{0}" kann nicht eingebettet werden. Verwenden Sie stattdessen die entsprechende Schnittstelle.¨'{2}' kann die 'new()'-Einschr√§nkung f√ºr Parameter '{1}' im generischen Typ oder in der generischen Methode '{0}' nicht erf√ºllen, da '{2}' erforderliche Member aufweist.≈"{2}" muss ein nicht abstrakter Typ mit einem √∂ffentlichen parameterlosen Konstruktor sein, um im generischen Typ oder in der generischen {0}-Methode als {1}-Parameter verwendet werden zu k√∂nnen.f"{0}": Beim Erstellen einer Instanz eines Variablentyps k√∂nnen keine Argumente bereitgestellt werden.@"{0}" ist ein neuer virtueller Member im versiegelten Typ "{1}".m'Mit dem Tupeltyp kann "new" nicht verwendet werden. Verwenden Sie stattdessen einen literalen Tupelausdruck.Zeilenvorschub in Konstante.¶Zeilenumbr√ºche innerhalb einer nicht ausf√ºhrlichen interpolierten Zeichenfolge werden in C#-{0} nicht unterst√ºtzt. Verwenden Sie die Sprachversion {1} oder h√∂her.Susing static-Anweisungen k√∂nnen nicht zum Deklarieren eines Alias verwendet werden:F√ºr einen base-Verweis ist eine Basisklasse erforderlich.PKeine einschlie√üende Schleife, aus der angehalten und fortgefahren werden kann.ãDer Interoptyp, der mit dem eingebetteten Interoptyp "{0}" √ºbereinstimmt, wurde nicht gefunden. M√∂glicherweise fehlt ein Assemblyverweis.4F√ºr den {0}-Typ sind keine Konstruktoren definiert.Ω"{0}": Der in einer asynchronen using-Anweisung verwendete Typ muss implizit in "System.IAsyncDisposable" konvertiert werden k√∂nnen oder eine geeignete DisposeAsync-Methode implementieren.Ì"{0}": Der in einer asynchronen using-Anweisung verwendete Typ muss implizit in "System.IAsyncDisposable" konvertiert werden k√∂nnen oder eine geeignete DisposeAsync-Methode implementieren. Meinten Sie "using" anstelle von "await using"?l"{0}": Der in einer using-Anweisung verwendete Typ muss implizit in "System.IDisposable" konvertierbar sein.ú"{0}": Der in einer using-Anweisung verwendete Typ muss implizit in "System.IDisposable" konvertierbar sein. Meinten Sie "await using" anstelle von "using"?òDas CallerArgumentExpressionAttribute kann nicht angewendet werden, da keine Standardkonvertierungen von Typ ‚Äû{0}‚Äú in Typ ‚Äû{1}‚Äú verf√ºgbar sind.ÇCallerFilePathAttribute kann nicht angewendet werden, da keine Standardkonvertierungen von Typ "{0}" in Typ "{1}" verf√ºgbar sind.ÑCallerLineNumberAttribute kann nicht angewendet werden, da keine Standardkonvertierungen von Typ "{0}" in Typ "{1}" verf√ºgbar sind.ÑCallerMemberNameAttribute kann nicht angewendet werden, da keine Standardkonvertierungen von Typ "{0}" in Typ "{1}" verf√ºgbar sind.ãEin Wert vom Typ "{0}" kann nicht als Standardparameter verwendet werden, da keine Standardkonvertierungen in den Typ "{1}" vorhanden sind.üEin Wert vom Typ "{0}" kann nicht als Standardparameter f√ºr den Parameter "{1}", der NULL-Werte zul√§sst, verwendet werden, weil "{0}" kein einfacher Typ ist.FIm Basistyp "{0}" wurde kein zug√§nglicher Kopierkonstruktor gefunden.^Es wurde kein Argument angegeben, das dem erforderlichen Parameter "{0}" von "{1}" entspricht.nDas delegate-Schl√ºsselwort kann nicht als Einschr√§nkung verwendet werden. Meinten Sie ‚ÄûSystem.Delegate‚Äú?‰Der Aufruf von Methode "{0}" muss dynamisch gebunden werden, was jedoch nicht m√∂glich ist, da die Methode Teil eines Basiszugriffsausdrucks ist. Wandeln Sie ggf. die dynamischen Argumente um, oder l√∂schen Sie den Basiszugriff.ÆDer Konstruktoraufruf muss dynamisch gebunden werden. Dies ist aber nicht m√∂glich, da er Teil eines Konstruktorinitialisierers ist. Wandeln Sie die dynamischen Argumente um.ÀDer Indexerzugriff muss dynamisch gebunden werden. Dies ist aber nicht m√∂glich, da er Teil eines Basiszugriffsausdrucks ist. Wandeln Sie die dynamischen Argumente um, oder l√∂schen Sie den Basiszugriff.PDas Programm enth√§lt keine als Einstiegspunkt geeignete statische Main-Methode.tDas Schl√ºsselwort ‚Äûenum‚Äú kann nicht als Einschr√§nkung verwendet werden. Meinten Sie ‚Äûstruct, System.Enum‚Äú?ÀDer Typ "{0}" kann nicht mit einer Verweiskonvertierung, einer Boxing-Konvertierung, einer Unboxing-Konvertierung, einer Umbruchkonvertierung oder einer NULL-Typkonvertierung in "{1}" konvertiert werden.5Der Typ "{0}" kann nicht in "{1}" konvertiert werden.2Fehlende Dateispezifikation f√ºr die Option "{0}".["{0}": √úberschreiben nicht m√∂glich, weil "{1}" keinen √ºberschreibbaren get-Accessor hat.>Der Typ "{0}" kann nicht implizit in "{1}" konvertiert werden.ùDer Typ "{0}" kann nicht implizit in "{1}" konvertiert werden. Es ist bereits eine explizite Konvertierung vorhanden (m√∂glicherweise fehlt eine Umwandlung).ıDer bedingte Ausdruck ist in der Sprachversion {0} nicht g√ºltig, da zwischen ‚Äû{1}‚Äú und ‚Äû{2}‚Äú kein allgemeiner Typ gefunden wurde. Um eine Zielkonvertierung zu verwenden, f√ºhren Sie ein Upgrade auf die Sprachversion {3} oder h√∂her aus.0"{0}" hat keine passende statische Main-Methode.T/main kann beim Erstellen eines Moduls oder einer Bibliothek nicht angegeben werden.*Metadatendatei "{0}" wurde nicht gefunden.MModifizierer k√∂nnen nicht in Ereignisaccessordeklarationen platziert werden.IDie {0}-Klasse kann nicht mehrere Basisklassen aufweisen: "{1}" und "{2}"üDie in einem Namespace definierten Elemente d√ºrfen nicht explizit als "private", "protected", "protected internal" oder "private protected" deklariert werden.RNetzmodule k√∂nnen nicht mithilfe von "/refout" oder "/refonly" kompiliert werden.dEine Instanz des abstrakten Typs oder der abstrakten Schnittstelle "{0}" kann nicht erstellt werden.kEs kann keine Instanz des Variablentyps "{0}" erstellt werden, weil er keine new()-Einschr√§nkung aufweist.4Das Ausgabeverzeichnis konnte nicht bestimmt werden.\Aus Assembly "{0}" k√∂nnen keine Interoptypen eingebettet werden, da das {1}-Attribut fehlt.{Aus Assembly "{0}" k√∂nnen keine Interoptypen eingebettet werden, da entweder das {1}-Attribut oder das {2}-Attribut fehlt.¶Der Typ "{0}" kann nicht eingebettet werden, da es sich um einen geschachtelten Typ handelt. Legen Sie die Eigenschaft "Interoptypen einbetten" ggf. auf "False" fest.;Verwenden Sie "refout" nicht, wenn Sie "refonly" verwenden.["{0}": √úberschreiben nicht m√∂glich, weil "{1}" keinen √ºberschreibbaren set-Accessor hat.7Die Quelldatei "{0}" konnte nicht ge√∂ffnet werden: {1}+"{0}" enth√§lt keine Definition f√ºr "{1}".Ì"{0}" enth√§lt keine Definition f√ºr "{1}", und es konnte keine zug√§ngliche {1}-Erweiterungsmethode gefunden werden, die ein erstes Argument vom Typ "{0}" akzeptiert (m√∂glicherweise fehlt eine using-Direktive oder ein Assemblyverweis).“"{0}" enth√§lt keine Definition f√ºr "{1}", und es konnte keine {1}-Erweiterungsmethode gefunden werden, die ein erstes Argument vom Typ "{0}" akzeptiert (m√∂glicherweise fehlt eine using-Direktive f√ºr "{2}").zDer Typ "{0}" ist in einer nicht referenzierten Assembly definiert. F√ºgen Sie einen Verweis auf die Assembly "{1}" hinzu.kDer Typ "{0}" wurde in einem nicht hinzugef√ºgten Modul definiert. Sie m√ºssen das Modul "{1}" hinzuf√ºgen.FDas void-Schl√ºsselwort kann in diesem Kontext nicht verwendet werden. Ung√ºltiger Parametertyp "void".ADer Typ "{0}" in der Schnittstellenliste ist keine Schnittstelle.ODer nicht aufrufbare Member "{0}" kann nicht wie eine Methode verwendet werden.+Der Datensatzmember "{0}" muss privat sein./Der Datensatzmember "{0}" muss gesch√ºtzt sein.0Der Datensatzmember "{0}" muss √∂ffentlich sein.9Der parameterlose Strukturkonstruktor muss "public" sein.QEin Einstiegspunkt, der "void" oder "int" zur√ºckgibt, kann nicht asynchron sein."{0}" ist keine Attributklasse.2Der "{0}" zugewiesene Ausdruck muss konstant sein.≠Die Interpolation muss mit derselben Anzahl schlie√üender geschweiften Klammern enden wie die Anzahl von ‚Äû$‚Äú-Zeichen, mit denen das Rohzeichenfolgenliteral begonnen hat.LNicht gen√ºgend Anf√ºhrungszeichen f√ºr unformatierte Zeichenfolgenliterale.t‚Äû{0}‚Äú ist keine Instanzmethode, der Empf√§nger kann kein Handlerargument einer interpolierten Zeichenfolge sein.~"{0}" hat den Typ "{1}". Ein Konstantenfeld mit einem anderen Referenztyp als "String" kann nur mit NULL initialisiert werden.ã"{0}" hat den Typ "{1}". Ein standardm√§√üiger Parameterwert eines anderen Verweistyps als "String" kann nur mit NULL initialisiert werden.["{0}" muss √úberschreibungen zulassen, weil der enthaltende Datensatz nicht versiegelt ist.:Diese Sprachfunktion ("{0}") ist noch nicht implementiert.óNULL ist kein g√ºltiger Parametername. Um auf den Empf√§nger einer Instanzmethode zuzugreifen, verwenden Sie die leere Zeichenfolge als Parameternamen.8Die Verwendung von NULL ist in diesem Kontext ung√ºltig.TEin Ausdrucksbaumstruktur-Lambda darf keinen null propagierenden Operator enthalten.,"enable", "disable" oder "restore" erwartet.EErwartet wurde "warnings", "annotations" oder das Ende der Anweisung.\Ung√ºltiger Wert f√ºr "{0}": "{1}" f√ºr C# {2}. Verwenden Sie Sprachversion {3} oder h√∂her.äEin Parameter mit Nullable-Typ muss als Werttyp oder Nicht-Nullable-Verweistyp bekannt sein, es sei denn, die Sprachversion "{0}" oder h√∂her wird verwendet. Erw√§gen Sie, die Sprachversion zu √§ndern oder eine class-, struct- oder type-Einschr√§nkung hinzuzuf√ºgen.F"{0}" hat keine Basisklasse und kann keinen Basiskonstruktor aufrufen.]Die System.Object-Klasse kann keine Basisklasse haben oder eine Schnittstelle implementieren.sObjekt- und Sammlungsinitialisiererausdr√ºcke d√ºrfen nicht auf einen Delegaterstellungsausdruck angewendet werden.ÇAuf den Member "{0}" kann nicht mit einem Instanzverweis zugegriffen werden. Qualifizieren Sie ihn stattdessen mit einem Typnamen.iF√ºr das nicht statische Feld, die Methode oder die Eigenschaft "{0}" ist ein Objektverweis erforderlich.HDas Auslassen des Typarguments ist im aktuellen Kontext nicht zul√§ssig.∑Eine /reference-Option, die einen externen Alias deklariert, kann nur einen Dateinamen haben. Um mehrere Aliase oder Dateinamen festzulegen, verwenden Sie mehrere /reference-Optionen.0Nur Klassentypen k√∂nnen Destruktoren enthalten.CDer R√ºckgabetyp des True- oder False-Operators muss boolesch sein."Dateiende gefunden. "*/" erwartet.+Fehler beim √ñffnen der Antwortdatei "{0}".SDer benutzerdefinierte Operator "{0}" kann nicht als √ºberpr√ºft deklariert werden.@Benutzerdefinierte Operatoren k√∂nnen nicht "void" zur√ºckgeben.P"{0}": Statische Klassen k√∂nnen keine benutzerdefinierten Operatoren enthalten.^F√ºr den Operator "{0}" muss au√üerdem ein √ºbereinstimmender Operator "{1}" definiert werden.VDer benutzerdefinierte {0}-Operator muss als statisch und √∂ffentlich deklariert sein..Die Option "{0}" muss ein absoluter Pfad sein.2Ein in-Parameter kann kein Out-Attribut aufweisen.cDas Out-Attribut kann f√ºr einen ref-Parameter nicht ohne Angabe des In-Attributs angegeben werden.GEine out-Variable kann nicht als lokales ref-Element deklariert werden.>F√ºr Ausgaben ohne Quelle muss die Option /out angeben werden.@In die Ausgabedatei "{0}" konnte nicht geschrieben werden: "{1}"~"{0}" kann kein √ºberladenes {1}-Element definieren, das sich nur in den Parametermodifizierern "{2}" und "{3}" unterscheidet.ÙDie Methode "{0}" gibt eine default-Einschr√§nkung f√ºr den Typparameter "{1}" an, aber der zugeh√∂rige Typparameter "{2}" der √ºberschriebenen oder explizit implementierten Methode "{3}" ist auf einen Verweistyp oder einen Werttyp beschr√§nkt.V√úberschreiben Sie nicht object.Finalize, sondern stellen Sie einen Destruktor bereit.U"{0}" muss erforderlich sein, da das erforderliche Mitglied "{1}" √ºberschrieben wirdC"{0}": Es wurde keine passende Methode zum √úberschreiben gefunden.gEin Member "{0}", der als "override" markiert ist, kann nicht als "new" oder "virtual" markiert werden.‘Die Methode "{0}" gibt eine class-Einschr√§nkung f√ºr den Typparameter "{1}" an, aber der zugeh√∂rige Typparameter "{2}" der au√üer Kraft gesetzten oder explizit implementierten Methode "{3}" ist kein Verweistyp.ﬂDie Methode "{0}" gibt eine struct-Einschr√§nkung f√ºr den Typparameter "{1}" an, aber der zugeh√∂rige Typparameter "{2}" der au√üer Kraft gesetzten oder explizit implementierten Methode "{3}" ist kein Non-Nullable-Werttyp.‚Einschr√§nkungen f√ºr Au√üerkraftsetzungs- und explizite Schnittstellenimplementierungsmethoden werden von der Basismethode geerbt und k√∂nnen daher nur f√ºr eine class- oder eine struct-Einschr√§nkung direkt angegeben werden.)√úberladbarer bin√§rer Operator erwartet. √úberladbarer Operator erwartet.(√úberladbarer un√§rer Operator erwartet.rDie Definition von Pr√§prozessorsymbolen kann nur vor dem ersten Token in der Datei vorgenommen/aufgehoben werden. Pr√§prozessordirektive erwartet.G"#Load" kann nicht nach dem ersten Token in der Datei verwendet werden.B#r kann nicht nach dem ersten Token in der Datei verwendet werden.9Der Parameter weist mehrere eindeutige Standardwerte auf.iDer out-Parameter "{0}" muss eine Zuweisung erhalten, bevor die Steuerung die aktuelle Methode verl√§sst.D"{0}": Statische Typen k√∂nnen nicht als Parameter verwendet werden.KDer Parameter ist f√ºr den angegebenen nicht verwalteten Typ nicht g√ºltig.>Das "Parameter null-checking"-Feature wird nicht unterst√ºtzt.<Der params-Parameter kann nicht als "{0}" deklariert werden.LEin params-Parameter muss der letzte Parameter in einer Parameterliste sein.:Der params-Parameter muss ein eindimensionales Array sein.YBeide partiellen Methodendeklarationen m√ºssen identische Zugriffsmodifizierer aufweisen.çBeide partiellen Methodendeklarationen m√ºssen identische Kombinationen der Modifizierer "virtual", "override", "sealed" und "new" verwenden.ÉBeide partiellen Methodendeklarationen m√ºssen Erweiterungsmethoden sein, oder keine von beiden darf eine Erweiterungsmethode sein.èIn Ausdrucksb√§umen d√ºrfen weder partielle Methoden mit nur einer definierenden Deklaration noch entfernte bedingte Methoden verwendet werden.pPartielle Methodendeklarationen von "{0}" weisen inkonsistente Einschr√§nkungen f√ºr den Typparameter "{1}" auf.oDie beiden partiellen Methodendeklarationen ("{0}" und "{1}") m√ºssen die gleichen Tupelelementnamen verwenden.HEine partielle Methode darf nicht den Modifizierer "abstract" aufweisen.qF√ºr die implementierende Deklaration der partiellen Methode "{0}" wurde keine definierende Deklaration gefunden.QEine partielle Methode darf Schnittstellenmethoden nicht explizit implementieren.LEine partielle Methode muss innerhalb eines partiellen Typs deklariert sein.YEine partielle Methode darf nicht √ºber mehrere implementierende Deklarationen verf√ºgen.UEine partielle Methode darf nicht √ºber mehrere definierende Deklarationen verf√ºgen.çBeide partiellen Methodendeklarationen m√ºssen einen params-Parameter verwenden, oder keine von beiden darf einen params-Parameter verwenden.hEntweder beide oder keine der partiellen Methodendeklarationen m√ºssen als "readonly" festgelegt werden.YDeklarationen partieller Methoden m√ºssen √ºbereinstimmende Ref-R√ºckgabewerte aufweisen.WBeide Deklarationen der partiellen Methode m√ºssen den gleichen R√ºckgabetyp aufweisen.gBeide partiellen Methodendeklarationen m√ºssen statisch sein, oder keine von beiden darf statisch sein.ÜAus der {0}-Methode kann kein Delegat erstellt werden, da es sich um eine partielle Methode ohne implementierende Deklaration handelt.gBeide partiellen Methodendeklarationen m√ºssen unsicher sein, oder keine von beiden darf unsicher sein.oDie partielle Methode "{0}" muss einen Implementierungsteil aufweisen, weil sie Zugriffsmodifizierer verwendet.úDie partielle Methode "{0}" muss Zugriffsmodifizierer aufweisen, weil sie einen Modifizierer "virtual", "override", "sealed", "new" oder "extern" verwendet.yDie partielle Methode "{0}" muss Zugriffsmodifizierer aufweisen, weil sie einen R√ºckgabetyp mit R√ºckgabewert verwendet.bDie partielle Methode "{0}" muss Zugriffsmodifizierer aufweisen, weil sie out-Parameter verwendet.åDer partial-Modifizierer kann nur unmittelbar vor "class", "record", "struct", "interface" oder einem Methodenr√ºckgabetyp verwendet werden.iPartielle Deklarationen von "{0}" haben Zugriffsmodifizierer, die miteinander einen Konflikt verursachen.WPartielle Deklarationen von "{0}" d√ºrfen keine unterschiedlichen Basisklassen angeben.õPartielle Deklarationen von "{0}" m√ºssen entweder nur Klassen, nur Datensatzklassen, nur Strukturen, nur Datensatzstrukturen oder nur Schnittstellen sein.fPartielle Deklarationen von "{0}" weisen inkonsistente Einschr√§nkungen f√ºr den {1}-Typparameter auf.oPartielle Deklarationen von "{0}" m√ºssen die gleichen Typparameternamen in der gleichen Reihenfolge aufweisen.áPartielle Deklarationen von "{0}" m√ºssen die gleichen Typparameternamen und Varianzmodifizierer in der gleichen Reihenfolge aufweisen.>Der Typ "dynamic" darf nicht in einem Muster verwendet werden.ÖEs ist unzul√§ssig, den Nullable-Typ "{0}?" in einem Muster zu verwenden. Verwenden Sie stattdessen den zugrunde liegenden Typ "{0}".ÖEine Nullkonstante der Zeichenfolge wird nicht als Muster f√ºr "{0}" unterst√ºtzt. Verwenden Sie stattdessen eine leere Zeichenfolge.ëEin Ausdruck des Typs "{0}" kann nicht von einem Muster des Typs "{1}" in C# {2} verarbeitet werden. Verwenden Sie Sprachversion {3} oder h√∂her.XEin Ausdruck vom Typ "{0}" kann nicht von einem Muster vom Typ "{1}" verarbeitet werden.,Fehler beim Schreiben der Ausgabedatei: {0}.~Fehler beim Lesen der Datei "{0}", die f√ºr das benannte Argument "{1}" f√ºr das PermissionSet-Attribut angegeben wurde: "{2}"ÅFehler beim Aufl√∂sen des Dateipfads "{0}", der f√ºr das benannte Argument "{1}" f√ºr das PermissionSet-Attribut angegeben wurde./"is" und "as" sind keine g√ºltigen Zeigertypen.4Der Musterabgleich ist f√ºr Zeigertypen unzul√§ssig.JDer Text einer async-iterator-Methode muss eine yield-Anweisung enthalten.πDer Text einer async-iterator-Methode muss eine yield-Anweisung enthalten. Erw√§gen Sie das Entfernen von "async" aus der Methodendeklaration oder das Hinzuf√ºgen einer yield-Anweisung.RNegative Werte m√ºssen in runde Klammern gesetzt werden, um umgewandelt zu werden.ODer Member "{0}" wurde f√ºr den Typ "{1}" in der Assembly "{2}" nicht gefunden.@Der vordefinierte Typ "{0}" ist nicht definiert oder importiert.bDer vordefinierte Typ "{0}" wurde in mehreren referenzierten Assemblys deklariert: "{1}" und "{2}"4Der vordefinierte Typ "{0}" muss eine Struktur sein.@Der vordefinierte Typ "{0}" ist nicht definiert oder importiert.RDer SecurityAction-Wert "{0}" ist f√ºr das PrincipalPermission-Attribut ung√ºltig.F"{0}": Abstrakte Eigenschaften k√∂nnen keine private-Accessoren haben.O"{0}": Eigenschaften oder Indexer k√∂nnen nicht √ºber einen void-Typ verf√ºgen.rDie Eigenschaft oder der Indexer "{0}" kann in diesem Kontext nicht verwendet werden, weil der get-Accessor fehlt.èEin Eigenschaftsteilmuster erfordert einen Verweis auf die abzugleichende Eigenschaft oder das abzugleichende Feld. Beispiel: "{{ Name: {0} }}"M"{0}": Die Eigenschaft oder der Indexer muss mindestens einen Accessor haben.E"{0}": Statische Klassen d√ºrfen keine gesch√ºtzten Member enthalten.F"{0}": In der Struktur wurde ein neuer gesch√ºtzter Member deklariert.LDer *-Operator oder der ->-Operator muss auf einen Zeiger angewendet werden.4Ein Zeiger darf nur von einem Wert indiziert werden.aFehler beim Signieren der Ausgabe mit einem √∂ffentlichen Schl√ºssel aus dem Container "{0}": {1}]Fehler beim Signieren der Ausgabe mit einem √∂ffentlichen Schl√ºssel aus der Datei "{0}": {1}ô√ñffentliche Signierung wurde angegeben. F√ºr diese ist ein √∂ffentlicher Schl√ºssel erforderlich. Es wurde aber kein √∂ffentlicher Schl√ºssel angegeben.?√ñffentliche Signierung wird f√ºr Netmodule nicht unterst√ºtzt.2Die Bereichsvariable "{0}" ist bereits deklariert.ÜDer Name "{0}" ist auf der rechten Seite von "equals" nicht im Bereich. Vertauschen Sie die Ausdr√ºcke auf beiden Seiten von "equals".tF√ºr den Quelltyp "{0}" wurden mehrere Implementierungen des Abfragemusters gefunden. Mehrdeutiger Aufruf von "{1}".wEs konnte keine Implementierung des Abfragemusters f√ºr den Quelltyp "{0}" gefunden werden. "{1}" wurde nicht gefunden.≤Es konnte keine Implementierung des Abfragemusters f√ºr den Quelltyp "{0}" gefunden werden. "{1}" wurde nicht gefunden. Geben Sie den Typ der Bereichsvariablen "{2}" explizit an.€Es konnte keine Implementierung des Abfragemusters f√ºr den Quelltyp "{0}" gefunden werden. "{1}" wurde nicht gefunden. Fehlen m√∂glicherweise erforderliche Assemblyverweise oder eine using-Anweisung f√ºr "System.Linq"?TDie Bereichsvariable "{0}" kann nicht als out- oder ref-Parameter √ºbergeben werden.ÖDer Name "{0}" ist auf der linken Seite von "equals" nicht im Bereich. Vertauschen Sie die Ausdr√ºcke auf beiden Seiten von "equals".6"{0}" kann keiner Bereichsvariablen zugewiesen werden._Die Bereichsvariable "{0}" verursacht einen Konflikt mit einer fr√ºheren Deklaration von "{0}".UDer Bereichsvariablen "{0}" kann nichts zugewiesen werden, sie ist schreibgesch√ºtzt.cDie Bereichsvariable "{0}" darf nicht denselben Namen wie der Typparameter einer Methode aufweisen.eDer Typ des Ausdrucks in der {0}-Klausel ist falsch. Fehler beim Typr√ºckschluss im Aufruf von "{1}".gDer Typ eines Ausdrucks in der {0}-Klausel ist falsch. Fehler beim Typr√ºckschluss im Aufruf von "{1}".∞Ein Ausdruck vom Typ "{0}" ist in einer nachfolgenden from-Klausel in einem Abfrageausdruck mit dem Quelltyp "{1}" unzul√§ssig. Fehler beim Typr√ºckschluss im Aufruf von "{2}".RDas Rohzeichenfolgenliteraltrennzeichen muss sich in einer eigenen Zeile befindet.iMehrzeilige rohe Zeichenfolgenliterale sind nur in ausf√ºhrlichen interpolierten Zeichenfolgen zul√§ssig.TMehrzeilige Rohzeichenfolgenliterale m√ºssen mindestens eine Inhaltszeile enthalten.IRohzeichenfolgenliterale sind in Pr√§prozessordirektiven nicht zul√§ssig.} erwartet.√Der Typ "{0}" kann nicht eingebettet werden, weil er eine Neuabstraktion eines Members aus der Basisschnittstelle aufweist. Legen Sie die Eigenschaft "Interoptypen einbetten" ggf. auf FALSE fest.ò{0}: "readonly" kann f√ºr Accessoren nur verwendet werden, wenn die Eigenschaft oder der Indexer sowohl einen get- als auch einen set-Accessor aufweist.O"readonly" wird als Parametermodifizierer nicht unterst√ºtzt. Meinten Sie "in"?ùMember des schreibgesch√ºtzten Felds "{0}" vom Typ "{1}" k√∂nnen nicht mit einem Objektinitialisierer zugewiesen werden, da es sich um einen Werttyp handelt.]Der prim√§re Konstruktor verursacht einen Konflikt mit dem synthetisierten Kopierkonstruktor.…Ein in ‚Äûstruct‚Äú mit Parameterliste deklarierter Konstruktor muss √ºber einen ‚Äûthis‚Äú-Initialisierer verf√ºgen, der den prim√§ren Konstruktor oder einen explizit deklarierten Konstruktor aufruft.6Der Konstruktor "{0}" kann sich nicht selbst aufrufen.wDer Typ von "{0}" kann nicht abgeleitet werden, da der Initialisierer direkt oder indirekt auf die Definition verweist.oref-assign von "{1}" zu "{0}" ist nicht m√∂glich, weil "{1}" einen geringeren Escapebereich als "{0}" aufweist.áEine ref-Zuweisung von "{1}" zu "{0}" ist nicht m√∂glich, weil "{1}" die aktuelle Methode nur √ºber eine return-Anweisung escapen kann.ﬁ‚Äû{1}‚Äú kann nicht auf ‚Äû{0}‚Äú verweisen, da ‚Äû{1}‚Äú einen breiteren Werte-Escapebereich als ‚Äû{0}‚Äú hat, wodurch die Zuweisung √ºber ‚Äû{0}‚Äú von Werten mit engeren Escapebereichen als ‚Äû{1}‚Äú erm√∂glicht wird.JDer Ausdruck muss vom Typ "{0}" sein, weil er als Verweis zugewiesen wird.X'"await" kann nicht in einem Ausdruck mit einem bedingten ref-Operator verwendet werden.RDer Ausdruck muss vom Typ "{0}" sein, um dem alternativen ref-Wert zu entsprechen.UEntweder beide bedingten Operatorwerte m√ºssen ref-Werte sein oder keiner von beiden.ìDer Typ "{2}" muss ein Referenztyp sein, damit er als {1}-Parameter im generischen Typ oder in der generischen Methode "{0}" verwendet werden kann.êDer erste Parameter einer ref-Erweiterungsmethode "{0}" muss ein Werttyp oder ein generischer Typ sein, der auf die Struktur eingeschr√§nkt ist.8Ein Ref-Feld kann nicht auf eine Ref-Struktur verweisen.DEin Verweisfeld kann nur in einer Verweisstruktur deklariert werden.@Die linke Seite einer Ref-Zuweisung muss eine Ref-Variable sein.:Ein ref- oder out-Wert muss eine zuweisbare Variable sein.?Ein ref- oder out-Parameter kann keinen Standardwert aufweisen.kEine Eigenschaft oder ein Indexer ohne Verweisr√ºckgabe darf nicht als Out- oder Ref-Wert verwendet werden.ZEigenschaften, deren R√ºckgabe als Verweis erfolgt, d√ºrfen keine set-Accessoren besitzen.WEigenschaften, deren R√ºckgabe als Verweis erfolgt, m√ºssen einen get-Accessor besitzennEin schreibgesch√ºtztes Feld kann (au√üer in einem Konstruktor) nicht als ref- oder out-Wert verwendet werden.Member des schreibgesch√ºtzten Felds "{0}" k√∂nnen (au√üer in einem Konstruktor) nicht als ref- oder out-Wert verwendet werden.Y"{0}" darf nicht als ref- oder out-Wert verwendet werden, weil ein Schreibschutz besteht.oFelder von "{0}" d√ºrfen nicht als ref- oder out-Wert verwendet werden, weil es sich um ein {1}-Objekt handelt.a"{0}" kann nicht als ref- oder out-Wert verwendet werden, weil es sich um ein {1}-Objekt handelt.w{0} "{1}" kann nicht als ref- oder out-Wert verwendet werden, weil es sich um eine schreibgesch√ºtzte Variable handelt.ÖMember von {0} "{1}" k√∂nnen nicht als ref- oder out-Wert verwendet werden, weil es sich um eine schreibgesch√ºtzte Variable handelt.…Ein prim√§rer Konstruktorparameter eines schreibgesch√ºtzten Typs kann nicht als ref- oder out-Wert verwendet werden (mit Ausnahme eines init-only-Setters des Typs oder eines Variableninitialisierers).—Member des prim√§ren Konstruktorparameters ‚Äû{0}‚Äú eines schreibgesch√ºtzten Typs k√∂nnen nicht als ref- oder out-Wert verwendet werden (au√üer init-only-Setter des Typs oder eines Variableninitialisierers).ÑEin statisches schreibgesch√ºtztes Feld kann (au√üer in einem statischen Konstruktor) nicht als ref- oder out-Wert verwendet werden.ïFelder des statischen schreibgesch√ºtzten Felds "{0}" k√∂nnen (au√üer in einem statischen Konstruktor) nicht als ref- oder out-Wert verwendet werden.nDas lokale Element "{0}" kann nicht als Verweis zur√ºckgegeben werden, weil es kein lokales ref-Elelement ist.{Ein Member des lokalen Elements "{0}" kann nicht als Verweis zur√ºckgegeben werden, weil es kein lokales ref-Elelement ist.äEin Ausdruck kann in diesem Kontext nicht verwendet werden, weil er m√∂glicherweise nicht als Verweis √ºbergeben oder zur√ºckgegeben wird.eDer R√ºckgabeausdruck muss vom Typ "{0}" sein, weil die R√ºckgabe dieser Methode als Verweis erfolgt.ö"{0}" kann nicht als Verweis zur√ºckgegeben werden, weil das Element mit einem Wert initialisiert wurde, der nicht als Verweis zur√ºckgegeben werden kann.†Ein Member von "{0}" kann nicht als Verweis zur√ºckgegeben werden, weil er mit einem Wert initialisiert wurde, der nicht als Verweis zur√ºckgegeben werden kann.ÇEin Parameter kann nicht als Verweis "{0}" √ºber einen ref-Parameter, sondern nur in einer return-Anweisung zur√ºckgegeben werden.éEin Member des Parameters "{0}" kann nicht als Verweis √ºber einen ref-Parameter, sondern nur in einer return-Anweisung zur√ºckgegeben werden.qEin Parameter kann nicht als Verweis '{0}' zur√ºckgegeben werden, da es sich nicht um einen ref-Parameter handeltäEin Member des Parameters "{0}" kann nicht als Verweis zur√ºckgegeben werden, weil es sich nicht um einen ref- oder out-Parameter handelt.[Der prim√§re Konstruktorparameter ‚Äû{0}‚Äú kann nicht durch Verweis zur√ºckgegeben werden.HDie Bereichsvariable "{0}" kann nicht als Verweis zur√ºckgegeben werden.WEin schreibgesch√ºtztes Feld kann nicht als schreibbarer Verweis zur√ºckgegeben werden.hMember des schreibgesch√ºtzten Felds "{0}" k√∂nnen nicht als schreibbarer Verweis zur√ºckgegeben werden.S"{0}" kann nicht als Verweis zur√ºckgegeben werden, weil ein Schreibschutz besteht.jFelder von "{0}" k√∂nnen nicht als Verweis zur√ºckgegeben werden, weil es sich um ein {1}-Element handelt.\"{0}" kann nicht als Verweis zur√ºckgegeben werden, weil es sich um ein {1}-Element handelt.ÇDie R√ºckgabe von {0} "{1}" als schreibbarer Verweis ist nicht m√∂glich, weil es sich um eine schreibgesch√ºtzte Variable handelt.åMember von {0} "{1}" k√∂nnen nicht als schreibbarer Verweis zur√ºckgegeben werden, weil es sich um eine schreibgesch√ºtzte Variable handelt.~Ein prim√§rer Konstruktorparameter eines schreibgesch√ºtzten Typs kann nicht als beschreibbarer Verweis zur√ºckgegeben werden.õMember des prim√§ren Konstruktorparameters ‚Äû{0}‚Äú eines schreibgesch√ºtzten Typs k√∂nnen nicht durch einen beschreibbaren Verweis zur√ºckgegeben werden.bEin statisches schreibgesch√ºtztes Feld kann nicht als schreibbarer Verweis zur√ºckgegeben werden.uFelder eines statischen schreibgesch√ºtzten Felds "{0}" k√∂nnen nicht als schreibbarer Verweis zur√ºckgegeben werden.sEin Parameter kann nicht als Verweis "{0}" zur√ºckgegeben werden, weil er auf die aktuelle Methode beschr√§nkt ist.}Ein Member des Parameters "{0}" kann nicht als Verweis zur√ºckgegeben werden, da er auf die aktuelle Methode beschr√§nkt ist.WStrukturmember k√∂nnen nicht "this" oder andere Instanzmember als Verweis zur√ºckgeben.4"this" kann nicht als Verweis zur√ºckgegeben werden.Ñ'"await" kann nicht in einem Ausdruck verwendet werden, der einen Aufruf von "{0}" enth√§lt, weil die R√ºckgabe als Verweis erfolgt.´Der Lambdaausdruck eines Ausdrucksbaums darf keinen Aufruf einer Methode, einer Eigenschaft oder eines Indexers enthalten, deren bzw. dessen R√ºckgabe als Verweis erfolgt.HDer Verweis, der Eigenschaften zur√ºckgibt, kann nicht erfordert werden.E'{0}: Referenzstrukturen k√∂nnen keine Schnittstellen implementieren.w"{0}": Eine Einschr√§nkungsklasse kann nicht gleichzeitig mit einer class- oder struct-Einschr√§nkung angegeben werden. #r ist nur in Skripts zul√§ssig.GRelationale Muster d√ºrfen nicht f√ºr Gleitkomma-NaNs verwendet werden.JDas erforderliche Mitglied '{0}' kann von '{1}' nicht ausgeblendet werden.îDer erforderliche Member '{0}' darf nicht weniger sichtbar sein oder einen Setter aufweisen, der weniger sichtbar ist als der enthaltende Typ '{1}'.iDas erforderliche Mitglied "{0}" muss im Objektinitialisierer oder Attributkonstruktor festgelegt werden.@Das erforderliche Mitglied "{0}" muss festgelegt werden k√∂nnen.ÃDie Liste der erforderlichen Member f√ºr den Basistyp '{0}' ist falsch formatiert und kann nicht interpretiert werden. Um diesen Konstruktor zu verwenden, wenden Sie das Attribut "SetsRequiredMembers" an.gDie erforderliche Mitgliederliste f√ºr '{0}' ist falsch formatiert und kann nicht interpretiert werden.ñDem erforderlichen Member "{0}" muss ein Wert zugewiesen werden. Ein geschachtelter Member oder Auflistungsinitialisierer kann nicht verwendet werden.DTypen und Aliase k√∂nnen nicht als "erforderlich" bezeichnet werden.pDer Assemblyname "{0}" ist reserviert und kann nicht als Verweis in einer interaktiven Sitzung verwendet werden.HDer Enumeratorname "{0}" ist reserviert und kann nicht verwendet werden.îAlle verkn√ºpften Ressourcen und Module m√ºssen einen eindeutigen Dateinamen haben. Der Dateiname "{0}" wurde in dieser Assembly mehrfach angegeben.JDer Ressourcenbezeichner "{0}" wurde in dieser Assembly bereits verwendet.]Da "{0}" "void" zur√ºckgibt, darf auf ein R√ºckgabeschl√ºsselwort kein Objektausdruck folgen.vEine anonyme Funktion, die in einen "void" zur√ºckgebenden Delegaten konvertiert wurde, kann keinen Wert zur√ºckgeben.KEin Objekt oder Typ ist erforderlich, der in "{0}" konvertiert werden kann.5"{0}": Nicht alle Codepfade geben einen Wert zur√ºck.ΩVon Iteratoren kann kein Wert zur√ºckgegeben werden. Verwenden Sie die "yield return"-Anweisung, um einen Wert zur√ºckzugeben, oder die "yield break"-Anweisung, um die Iteration zu beenden.UDer R√ºckgabewert von "{0}" ist keine Variable und kann daher nicht ge√§ndert werden.H'{0}: Statische Typen k√∂nnen nicht als R√ºckgabetypen verwendet werden.ù{0}: Die Zielruntime unterst√ºtzt keine covarianten Typen in √úberschreibungen. Der Typ muss "{2}" sein, um dem √ºberschriebenen Member "{1}" zu entsprechen.Ø{0}: Die Zielruntime unterst√ºtzt keine covarianten R√ºckgabetypen in √úberschreibungen. Der R√ºckgabetyp muss "{2}" sein, um dem √ºberschriebenen Member "{1}" zu entsprechen.VDie Standardschnittstellenimplementierung wird von der Zielruntime nicht unterst√ºtzt.ü"{0}" kann den Schnittstellenmember "{1}" im Typ "{2}" nicht implementieren, weil die Zielruntime die Standardschnittstellenimplementierung nicht unterst√ºtzt.§Die Zugriffsoptionen "protected", "protected internal" oder "private protected" werden von der Zielruntime f√ºr einen Member einer Schnittstelle nicht unterst√ºtzt.1Die Zielruntime unterst√ºtzt keine Verweisfelder.TDie Zielruntime unterst√ºtzt keine statischen abstrakten Elemente in Schnittstellen.≥‚Äû{0}‚Äú kann das Schnittstellenelement ‚Äû{1}‚Äú im Typ ‚Äû{2}‚Äú nicht implementieren, weil die Zielruntime keine statischen abstrakten Elemente in Schnittstellen unterst√ºtzt.yDie Zielruntime unterst√ºtzt keine erweiterbaren Aufrufkonventionen oder Standardaufrufkonventionen der Runtime-Umgebung./Der Typ "{1}" ist in "{0}" und "{2}" vorhanden.JDer Namespace "{1}" in "{0}" steht in Konflikt mit dem Typ "{3}" in "{2}".JDer Typ "{1}" in "{0}" steht in Konflikt mit dem Namespace "{3}" in "{2}".LDer Modifizierer ‚Äûscoped‚Äú kann nicht mit ‚Äûdiscard‚Äú verwendet werden.ÅDer Modifikator ‚ÄöScoped‚Äò des Parameters ‚Äö{0}‚Äò stimmt nicht mit dem √ºberschriebenen oder implementierten Member √ºberein.sDer Modifikator ‚ÄöScoped‚Äò des Parameters ‚Äö{0}‚Äò stimmt nicht mit der partiellen Methodendeklaration √ºberein.WDer 'Scoped'-Modifikator des Parameters '{0}' stimmt nicht mit dem Ziel '{1}' √ºberein.WDer Modifikator ‚ÄöScoped‚Äò kann nur f√ºr Refs und Ref-Strukturwerte verwendet werden.>Typen und Aliase k√∂nnen nicht als "scoped" bezeichnet werden.lErforderliche Mitglieder sind auf der obersten Ebene eines Skripts oder einer √úbermittlung nicht zul√§ssig.X"{0}" kann nicht versiegelt werden, weil der enthaltende Datensatz nicht versiegelt ist.G"{0}" ist keine √úberschreibung und kann daher nicht versiegelt werden.B{0}: Ein Typ kann nicht gleichzeitig statisch und versiegelt sein.TDas Sicherheitsattribut "{0}" weist einen ung√ºltigen SecurityAction-Wert "{1}" auf.oDer SecurityAction-Wert "{0}" ist ung√ºltig f√ºr Sicherheitsattribute, die auf eine Assembly angewendet werden.}Der SecurityAction-Wert "{0}" ist ung√ºltig f√ºr Sicherheitsattribute, die auf einen Typ oder eine Methode angewendet werden.¢Das Sicherheitsattribut "{0}" ist f√ºr diesen Deklarationstyp nicht g√ºltig. Sicherheitsattribute sind nur f√ºr Assembly-, Typ- und Methodendeklarationen g√ºltig.UDas erste Argument eines Sicherheitsattributs muss eine g√ºltige SecurityAction sein.RDas Sicherheitsattribut "{0}" kann nicht auf eine Async-Methode angewendet werden.òAsync-Methoden sind in Schnittstellen, Klassen, Strukturen, die die Attribute "SecurityCritical" oder "SecuritySafeCritical" aufweisen, nicht zul√§ssig.{ oder ; erwartet.{ oder ; oder => erwartet; erwartet.\In der Schl√ºsseldatei "{0}" fehlt der f√ºr die Signierung erforderliche private Schl√ºssel.2Der Datensatzmember "{0}" muss "{1}" zur√ºckgeben.u"/main" kann nicht angegeben werden, wenn eine Kompilierungseinheit mit Anweisungen der obersten Ebene vorhanden ist.BMindestens eine Anweisung der obersten Ebene darf nicht leer sein.ûDie lokale Variable oder die lokale Funktion "{0}", die in einer Anweisung der obersten Ebene in diesem Kontext deklariert wurde, kann nicht verwendet werden.LNur eine Kompilierungseinheit kann Anweisungen der obersten Ebene aufweisen.RDas Programm mit Anweisungen der obersten Ebene muss eine ausf√ºhrbare Datei sein.‡Ein aus einem Element bestehendes deconstruct-Muster erfordert zur Vermeidung einer Mehrdeutigkeit eine etwas andere Syntax. Es wird empfohlen, nach der schlie√üenden Klammer ")" einen discard-Kennzeichner "_" hinzuzuf√ºgen.[Ein einzeiliger Kommentar darf in einer interpolierten Zeichenfolge nicht verwendet werden.}Der Typ- oder Namespacename "{0}" wurde nicht gefunden (m√∂glicherweise fehlt eine using-Direktive oder ein Assemblyverweis).íDer Typname "{0}" wurde nicht gefunden. Dieser Typ wurde an Assembly "{1}" weitergeleitet. Sie sollten einen Verweis auf die Assembly hinzuf√ºgen.s"{0}" enth√§lt keine vordefinierte Gr√∂√üe, sizeof kann daher nur in einem ungesch√ºtzten Kontext verwendet werden.-Quelldateiverweise werden nicht unterst√ºtzt.GDer Schalter "/sourcelink" wird nur beim Ausgeben von PDB unterst√ºtzt.ûEine Instanz des Typs "{0}" kann nicht in einer geschachtelten Funktion, einem Abfrageausdruck, einem Iteratorblock oder einer Async-Methode verwendet werden.<Die Einschr√§nkung kann nicht die spezielle {0}-Klasse sein.\Die Umwandlung eines stackalloc-Ausdrucks vom Typ "{0}" in den Typ "{1}" ist nicht m√∂glich.L"stackalloc" darf nicht in einem catch- oder finally-Block verwendet werden.aEin Lambdaausdruck mit einem Anweisungstext kann nicht in einen Ausdrucksbaum konvertiert werden.3Der Datensatzmember "{0}" darf nicht statisch sein.UEine statische anonyme Funktion kann keinen Verweis auf "this" oder "base" enthalten.HEine statische anonyme Funktion kann keinen Verweis auf "{0}" enthalten.B"{1}": Von der statischen {0}-Klasse kann nicht abgeleitet werden.E"{0}": Statische Klassen k√∂nnen keine Schnittstellen implementieren.9"{0}": Ein statischer Konstruktor muss parameterlos sein.:Die Konstante "{0}" kann nicht als statisch markiert sein.N"{0}": Zugriffsmodifizierer sind bei statischen Konstruktoren nicht zul√§ssig.e"{0}": Ein statischer Konstruktor kann keinen expliziten this- oder base-Konstruktoraufruf enthalten.ÇDie statische {0}-Klasse kann nicht vom Typ "{1}" abgeleitet werden. Statische Klassen m√ºssen von einem Objekt abgeleitet werden.TEine statische lokale Funktion kann keinen Verweis auf "this" oder "base" enthalten.GEine statische lokale Funktion kann keinen Verweis auf "{0}" enthalten.EDer statische Member "{0}" kann nicht als "readonly" markiert werden.sDas statische Feld oder die statische Eigenschaft "{0}" kann nicht in einem Objektinitialisierer zugewiesen werden.;Ein statischer Member kann nicht als "{0}" markiert werden.hDas stdin-Argument "-" ist angegeben, aber die Eingabe wurde nicht vom Standardeingabestream umgeleitet.4Zeichenfolge muss mit Anf√ºhrungszeichen beginnen: "cEine ‚ÄûStruktur‚Äú mit Feldinitialisierern muss einen explizit deklarierten Konstruktor enthalten.RDer Strukturmember "{0}" vom Typ "{1}" verursacht eine Schleife im Strukturlayout.pDer prim√§re Strukturkonstruktorparameter ‚Äû{0}‚Äú vom Typ ‚Äû{1}‚Äú verursacht eine Schleife im struct-Layout.RDas FieldOffset-Attribut ist f√ºr statische oder konstante Felder nicht zul√§ssig.|Das FieldOffset-Attribut kann nur f√ºr Member des mit "StructLayout(LayoutKind.Explicit)" markierten Typs festgelegt werden.C"{0}": Strukturen k√∂nnen keine Basisklassenkonstruktoren aufrufen.JUnterausdruck kann nicht in einem Argument f√ºr "nameof" verwendet werden.©Das Muster kann nicht erreicht werden. Es wurde bereits von einem vorherigen Verzweigungsarm des Switch-Ausdrucks behandelt, oder es ist keine √úbereinstimmung m√∂glich.éDer Switch-Case kann nicht erreicht werden. Er wurde bereits von einem vorherigen Fall behandelt, oder es ist keine √úbereinstimmung m√∂glich.>Es wurde kein optimaler Typ f√ºr den switch-Ausdruck gefunden.=Der switch-Ausdruck muss ein Wert sein. Gefunden wurde "{0}".tDie Steuerung kann nicht von der abschlie√üenden case-Bezeichnung ("{0}") aus dem switch-Ausdruck √ºbergeben werden.YDas Steuerelement kann nicht von einer case-Bezeichnung ("{0}") zur n√§chsten fortfahren.PDer Ausdruck zur Steuerung von Schaltern muss in Klammern eingeschlossen werden.CBefehlszeilen-Syntaxfehler: In der Option "{0}" fehlt ":< Nummer>".<Befehlszeilen-Syntaxfehler: In der Option "{1}" fehlt "{0}".['"MethodImplOptions.Synchronized" kann nicht auf eine asynchrone Methode angewendet werden.Syntaxfehler. "{0}" erwartet.hSystem.Void kann nicht in C# verwendet werden. Sie k√∂nnen das void-Typobjekt mit typeof(void) abfragen.ÖDa ‚Äû{0}‚Äú eine asynchrone Methode ist, die ‚Äû{1}‚Äú zur√ºckgibt, darf auf ein R√ºckgabeschl√ºsselwort kein Objektausdruck folgen.ÇEine asynchroner Lambdafunktion, die in einen zur√ºckkehrenden ‚Äû{0}‚Äú-Delegat konvertiert wurde, kann keinen Wert zur√ºckgeben.BDas this-Schl√ºsselwort ist im aktuellen Kontext nicht verf√ºgbar.{Das this-Schl√ºsselwort ist in einer statischen Eigenschaft/Methode oder einem statischen Feldinitialisierer nicht g√ºltig.+Schl√ºsselwort "this" oder "base" erwartet.”Anonyme Methoden, Lambdaausdr√ºcke, Abfrageausdr√ºcke und lokale Funktionen innerhalb von Strukturen k√∂nnen nicht auf Instanzmember von "this" zugreifen. Kopieren Sie "this" in eine lokale Variable au√üerhalb der anonymen Methode, des Lambdaausdrucks, des Abfrageausdrucks oder der lokalen Funktion, und verwenden Sie die lokale Variable.5Ein throw-Ausdruck ist in diesem Kontext unzul√§ssig.YCatch-Klauseln k√∂nnen nicht auf die allgemeine catch-Klausel einer try-Anweisung folgen.#Zu viele Zeichen im Zeichenliteral.ØDas interpolierte Rohzeichenfolgenliteral beginnt nicht mit gen√ºgend ‚Äû$‚Äú-Zeichen, um so viele aufeinanderfolgende schlie√üende geschweifte Klammern als Inhalt zuzulassen.YNur 65534 lokale Variablen, einschlie√ülich der vom Compiler generierten, sind zul√§ssig.¨Das interpolierte Rohzeichenfolgenliteral beginnt nicht mit gen√ºgend ‚Äû$‚Äú-Zeichen, um so viele aufeinanderfolgende √∂ffnende geschweifte Klammern als Inhalt zuzulassen.ïDas Rohzeichenfolgenliteral beginnt nicht mit gen√ºgend Anf√ºhrungszeichen, um so viele aufeinanderfolgende Anf√ºhrungszeichen als Inhalt zuzulassen.ªDie kombinierte L√§nge der vom Programm verwendeten Benutzerzeichenfolgen √ºberschreitet den zul√§ssigen Grenzwert. Versuchen Sie, die Verwendung von Zeichenfolgenliteralen zu verringern.RAnweisungen der obersten Ebene m√ºssen vor Namespace- und Typdeklarationen stehen.DFormatbezeichner d√ºrfen keine nachgestellten Leerzeichen enthalten.Unerwartete Zeichenfolge "...".)Tupelelementnamen m√ºssen eindeutig sein.:Der Name "{0}" identifiziert nicht das Tupelelement "{1}".∂Es kann keine Klasse bzw. kein Member definiert werden, die oder der Tupel verwendet, weil der f√ºr den Compiler erforderliche Typ "{0}" nicht gefunden wurde. Fehlt ggf. ein Verweis?QTupelelementnamen sind auf der linken Seite einer Dekonstruktion nicht zul√§ssig.ìDer Tupelelementname "{0}" ist abgeleitet. Verwenden Sie Sprachversion {1} oder h√∂her, um nach dem abgeleiteten Namen auf ein Element zuzugreifen.=Der Tupelelementname "{0}" ist nur an Position {1} zul√§ssig.<Der Tupelelementname "{0}" ist an keiner Position zul√§ssig.ÛTupeltypen, die als Operanden eines ==- oder !=-Operators verwendet werden, m√ºssen √ºbereinstimmende Kardinalit√§ten aufweisen. Dieser Operator enth√§lt jedoch Tupeltypen der Kardinalit√§t "{0}" auf der linken und "{1}" auf der rechten Seite.2Das Tupel muss mindestens zwei Elemente enthalten.,"{1}" definiert nicht den Typparameter "{0}"8{1} "{0}" kann nicht mit Typargumenten verwendet werden.ΩDie Einschr√§nkungen "class", "struct", "unmanaged", "notnull" und "default" k√∂nnen nicht kombiniert oder dupliziert werden und m√ºssen in der Einschr√§nkungsliste zuerst angegeben werden.Typ erwartet.hDas Modul "{0}" in der Assembly "{1}" leitet den Typ "{2}" an mehrere Assemblys weiter: "{3}" und "{4}".]Der Typ der implizit typisierten Dekonstruktionsvariablen "{0}" kann nicht abgeleitet werden.RDer Typ der implizit typisierten out-Variablen "{0}" kann nicht abgeleitet werden.6"{0}" ist kein interpolierter Zeichenfolgenhandlertyp.YDer Typ "{0}" muss √∂ffentlich sein, damit er als Aufrufkonvention verwendet werden kann."Der Typ "{0}" ist nicht definiert.@Eine Typparameterdeklaration muss ein Bezeichner sein, kein Typ.HDer Typname "{0}" ist f√ºr die Verwendung durch den Compiler reserviert.¨NULL kann nicht in den {0}-Typparameter konvertiert werden, weil es sich m√∂glicherweise um einen Non-Nullable-Werttyp handelt. Verwenden Sie stattdessen ggf. default({0}).~Das kontextabh√§ngige Schl√ºsselwort "var" darf nur in einer lokalen Variablendeklaration oder im Skriptcode verwendet werden.rDas kontextabh√§ngige Schl√ºsselwort "var" darf nicht in der Deklaration einer Bereichsvariablen verwendet werden.aDer {0}-Typparameter hat den gleichen Namen wie der enthaltende Typ bzw. die enthaltende Methode.jDer erste Operand eines "as"-Operators ist unter Umst√§nden kein Tupelliteral ohne einen nat√ºrlichen Typ.äDie automatisch implementierte Eigenschaft '{0}' muss vollst√§ndig zugewiesen werden, bevor das Steuerelement an den Aufrufer zur√ºckgegeben wird. Erw√§gen Sie eine Aktualisierung auf die Sprachversion '{1}', um die Eigenschaft automatisch als Standard zu verwenden.◊Das Feld "{0}" muss vollst√§ndig zugewiesen werden, bevor das Steuerelement an den Aufrufer zur√ºckgegeben wird. Aktualisieren Sie ggf. auf die Sprachversion "{1}", um das Feld automatisch als Standard zu verwenden.EDas Ergebnis einer Unboxingkonvertierung kann nicht ge√§ndert werden.^Das schlie√üende Trennzeichen "}" fehlt f√ºr den interpolierten Ausdruck, der mit "{" beginnt.W{0}-Zeichen m√ºssen in interpolierten Zeichenfolgen (durch Verdoppeln) maskiert werden.)Unerwartetes Verwenden eines Aliasnamens.Unerwartete Argumentliste.1Typargumente sind im nameof-Operator unzul√§ssig.Unerwartetes Zeichen "{0}".#Unerwartete Pr√§prozessordirektive.0Unerwartete Verwendung eines generischen Namens.ÉEin Konstruktor, der in einem Typ mit Parameterliste deklariert ist, muss √ºber den Konstruktorinitialisierer ‚Äûthis‚Äú verf√ºgen.Unerwartete Parameterliste.@Unzul√§ssiges Semikolon nach der Methode oder dem Accessorblock.Unerwartetes Token "{0}"=Unerwartete Verwendung eines ungebundenen generischen Namens._Ung√ºltige Varianz: Der Typparameter "{1}" muss {3} und g√ºltig f√ºr "{0}" sein. "{1}" ist {2}.£Ung√ºltige Varianz: Der Typparameter "{1}" muss "{3}" lauten und g√ºltig f√ºr "{0}" sein, sofern nicht Sprachversion {4} oder h√∂her verwendet wird. "{1}" ist {2}.ã"{0}" kann nicht gleichzeitig "{1}" und "{2}" implementieren, da diese f√ºr einige Typparameterersetzungen zusammengef√ºhrt werden k√∂nnen.?"{0}" implementiert den geerbten abstrakten Member "{1}" nicht.V"{0}" implementiert den Schnittstellenmember "{1}" nicht. "{2}" ist nicht √∂ffentlich.9"{0}" implementiert den Schnittstellenmember "{1}" nicht.n"{0}": Eine Einschr√§nkungsklasse kann nicht gleichzeitig mit einer unmanaged-Einschr√§nkung angegeben werden.üMethoden mit dem Attribut "UnmanagedCallersOnly" k√∂nnen keine generischen Typparameter aufweisen und d√ºrfen nicht in einem generischen Typ deklariert werden.ô"{0}" ist mit dem Attribut "UnmanagedCallersOnly" versehen und kann nicht direkt aufgerufen werden. Rufen Sie einen Funktionszeiger auf diese Methode ab.ß"{0}" ist mit dem Attribut "UnmanagedCallersOnly" versehen und kann nicht in einen Delegattyp konvertiert werden. Rufen Sie einen Funktionszeiger auf diese Methode ab.ô"UnmanagedCallersOnly" kann nur auf gew√∂hnliche statische, nicht abstrakte, nicht virtuelle Methoden oder statische lokale Funktionen angewendet werden.”Der Typ "{2}" muss, ebenso wie s√§mtliche Felder auf jeder Schachtelungsebene, ein Non-Nullable-Typ sein, wenn er als {1}-Parameter im generischen Typ oder in der generischen Methode "{0}" verwendet werden soll.rEine vorherige Catch-Klausel hat bereits alle Ausnahmen dieses oder eines √ºbergeordneten Typs abgefangen ("{0}").u‚Äû{0}‚Äú ist in einem Modul mit einer unbekannten RefSafetyRulesAttribute-Version definiert, erwartet wird ‚Äû11‚Äú.VAsync-Methoden d√ºrfen √ºber keine unsicheren Parameter oder R√ºckgabetypen verf√ºgen.IIteratoren d√ºrfen keine unsicheren Parameter oder yield-Typen aufweisen.ZZeiger und Puffer fester Gr√∂√üe k√∂nnen nur in einem unsicheren Kontext verwendet werden.MDer unsichere Typ "{0}" darf bei der Objekterstellung nicht verwendet werden.["UnscopedRefAttribute" kann nicht auf eine Schnittstellenimplementierung angewendet werden.ì"UnscopedRefAttribute" kann nur auf Strukturinstanzmethoden und -eigenschaften und nicht auf Konstruktoren oder init-only-Member angewendet werden.|"UnscopedRefAttribute" kann nicht auf diesen Parameter angewendet werden, da er standardm√§√üig nicht bereichsgesteuert ist.s"UnscopedRefAttribute" kann nicht auf Parameter angewendet werden, die √ºber einen "scoped"-Modifizierer verf√ºgen.GDie Aufrufkonvention von "{0}" wird von der Sprache nicht unterst√ºtzt.l'{0}' erfordert die Compilerfunktion '{1}', die von dieser Version des C#-Compilers nicht unterst√ºtzt wird.zDer ref-, out- oder in-prim√§re Konstruktorparameter ‚Äû{0}‚Äú kann nicht innerhalb eines Instanzmembers verwendet werden.èDer prim√§re Konstruktorparameter ‚Äû{0}‚Äú, der einen ref-√§hnlichen Typ innerhalb eines Instanzmembers aufweist, kann nicht verwendet werden.ÑFehler beim transparenten Bezeichnermemberzugriff f√ºr Feld "{0}" von "{1}". Implementieren die abgefragten Daten das Abfragemuster?NListenmuster d√ºrfen nicht f√ºr einen Wert vom Typ ‚Äû{0}‚Äú verwendet werden.PRelationale Muster d√ºrfen nicht f√ºr einen Wert vom Typ "{0}" verwendet werden.OSegmentmuster d√ºrfen nicht f√ºr einen Wert vom Typ ‚Äû{0}‚Äú verwendet werden.+Nicht abgeschlossenes Zeichenfolgenliteral.%Nicht beendetes Zeichenfolgenliteral.:Verwendung der nicht zugewiesenen lokalen Variablen "{0}".>Verwendung des m√∂glicherweise nicht zugewiesenen Felds "{0}".±Verwendung eines m√∂glicherweise nicht zugewiesenen Felds '{0}'. Erw√§gen Sie eine Aktualisierung auf die Sprachversion '{1}', um das Feld automatisch als Standard zu verwenden.7Verwendung des nicht zugewiesenen out-Parameters "{0}".aVerwenden einer m√∂glicherweise nicht zugewiesenen, automatisch implementierten Eigenschaft "{0}"⁄Verwendung einer m√∂glicherweise nicht zugewiesenen automatisch implementierten Eigenschaft '{0}'. Erw√§gen Sie eine Aktualisierung auf die Sprachversion '{1}', um die Eigenschaft automatisch als Standard zu verwenden.‰Das ‚Äûthis‚Äú-Objekt kann nicht verwendet werden, bevor alle zugeh√∂rigen Felder zugewiesen wurden. Aktualisieren Sie ggf. auf die Sprachversion ‚Äû{0}‚Äú, um die nicht zugewiesenen Felder automatisch als Standard zu verwenden.}Eine using-Klausel muss allen anderen im Namespace definierten Elementen mit Ausnahme externer Aliasdeklarationen vorangehen.âEine using-Variable kann nicht direkt in einem switch-Abschnitt verwendet werden (erw√§gen Sie die Verwendung von geschweiften Klammern).ØEin switch-Ausdruck oder eine case-Bezeichnung muss den Typ "bool", "char", "string", "integral", "enum" oder einen entsprechenden Nullable-Typ in C# 6 oder fr√ºher aufweisen.õDer Typ "{2}" muss ein Non-Nullable-Werttyp sein, wenn er als {1}-Parameter im generischen Typ oder in der generischen Methode "{0}" verwendet werden soll.^NULL kann nicht in {0} konvertiert werden, weil es sich um einen Non-Nullable-Werttyp handelt.Syntaxfehler. Wert erwartet.rDie im Werttyp "{1}" definierte Erweiterungsmethode "{0}" kann nicht zum Erstellen von Delegaten verwendet werden.çMember der {0}-Eigenschaft vom Typ "{1}" k√∂nnen nicht mit einem Objektinitialisierer zugewiesen werden, da es sich um einen Werttyp handelt.VEin Ausdrucksbaumstruktur-Lambda darf keine Methode mit Variablenargumenten enthalten.DDie Variable des statischen Typs "{0}" kann nicht deklariert werden.1Die Syntax "var (...)" als lvalue ist reserviert.ÄDie Syntax "var" f√ºr ein Muster darf nicht zum Verweis auf einen Typen verwendet werden, "{0}" ist jedoch im Bereich enthalten.G__arglist ist in der Parameterliste von Async-Methoden nicht zul√§ssig.E"__arglist" ist in der Parameterliste von Iteratoren nicht zul√§ssig.OEin __arglist-Parameter muss der letzte Parameter in einer Parameterliste sein.SDie lokale Variable "{0}" kann erst verwendet werden, nachdem sie deklariert wurde.úDie lokale Variable "{0}" kann erst verwendet werden, nachdem sie deklariert wurde. Bei der Deklaration der lokalen Variablen wird das Feld "{1}" verborgen.Enumerationen, Klassen und Strukturen k√∂nnen nicht in Schnittstellen mit Parametern vom Typ "in" oder "out" deklariert werden.A"{0}": Virtuelle oder abstrakte Member k√∂nnen nicht privat sein.5Ein Wert vom Typ "void" darf nicht zugewiesen werden.1Der Vorgang ist f√ºr void-Zeiger nicht definiert.4Ein Tupel darf keinen Wert vom Typ "void" enthalten.M"{0}": Ein Feld kann nicht gleichzeitig fl√ºchtig und schreibgesch√ºtzt sein.9"{0}": Ein fl√ºchtiges Feld kann nicht vom Typ "{1}" seinVEin Windows-Runtime-Ereignis darf nicht als out- oder ref-Parameter √ºbergeben werden.∫Ein generischer aufgaben√§hnlicher R√ºckgabetyp wurde erwartet, aber der Typ ‚Äû{0}‚Äú, der im Attribut ‚ÄûAsyncMethodBuilder‚Äú gefunden wurde, war nicht geeignet. Es muss sich um einen ungebundenen generischen Typ von Stelligkeit Eins handelt, und der enthaltende Typ (falls vorhanden) muss nicht generisch sein.>Die Aufrufkonvention von "{0}" ist nicht mit "{1}" kompatibel.mF√ºr den Abgleich von Tupeltyp "{0}" sind {1} Teilmuster erforderlich, aber es sind {2} Teilmuster vorhanden.dDie yield-Anweisung kann nicht in einer anonymen Methode oder einem Lambdaausdruck verwendet werden.EIn Skriptcode der obersten Ebene darf "yield" nicht verwendet werden.!Elemente k√∂nnen nicht NULL sein.)Algorithmus "{0}" wird nicht unterst√ºtzt8Die Codepage "{0}" ist ung√ºltig oder nicht installiert.AUnerwarteter Fehler beim Schreiben der Debuginformationen: "{0}".~Der Dateiname "{0}" ist leer, enth√§lt ung√ºltige Zeichen, weist eine Laufwerkangabe ohne absoluten Pfad auf oder ist zu lang.`Ung√ºltiger Zieltyp f√ºr /target: Sie m√ºssen "exe", "winexe", "library", oder "module" angeben.7Metadatendatei "{0}" konnte nicht ge√∂ffnet werden: {1}âDer kurze Dateiname "{0}" kann nicht erstellt werden, wenn bereits ein langer Dateiname mit dem gleichen kurzen Dateinamen vorhanden ist.MDer generische Parameter ist eine Definition, erwartet wurde ein Verweis {0}.WDie Verwenden-Anweisung f√ºr ‚Äû{0}‚Äú wurde zuvor als ‚ÄûGlobal verwenden‚Äú angezeigtHDie Verwenden-Anweisung wurde zuvor als ‚ÄûGlobal verwenden‚Äú angezeigt!Nicht verwendeter externer Alias. Nicht verwendeter externer Alias$Nicht erforderliche using-Direktive.#Nicht erforderliche using-Direktive5"{0}" ist kein g√ºltiger C#-Verbundzuweisungsvorgang.3"{0}" ist kein g√ºltiger C#-Konvertierungsausdruck.&Methodengruppeanonyme MethodeArrayzugriff6Au√üerkraftsetzung des asynchronen Methoden-Generators."await" in Catch-Bl√∂cken und Finally-Bl√∂ckenÇU
                             Visual C#-Compileroptionen

                       ‚Äì AUSGABEDATEIEN ‚Äì
-out:<Datei>                   Gibt den Namen der Ausgabedatei an (Standardeinstellung: Basisname der
                              Datei mit der Hauptklasse oder der ersten Datei).
-target:exe                   Erstellt eine ausf√ºhrbare Konsolendatei (Standardeinstellung)
                              (Kurzform: -t:exe).
-target:winexe                Erstellt eine ausf√ºhrbare Windows-Datei
                              (Kurzform: -t:winexe).
-target:library               Erstellt eine Bibliothek (Kurzform: -t:library).
-target:module                Erstellt ein Modul, das einer anderen Assembly
                              hinzugef√ºgt werden kann (Kurzform: -t:module).
-target:appcontainerexe       Erstellt eine ausf√ºhrbare App-Containerdatei
                              (Kurzform: -t:appcontainerexe).
-target:winmdobj              Erstellt eine Windows-Runtime-Zwischendatei, die
                              von WinMDExp verwendet wird (Kurzform: -t:winmdobj).
-doc:<Datei>                   Die zu generierende XML-Dokumentationsdatei.
-refout:<Datei>                Die zu generierende Referenzassemblyausgabe.
-platform:<Zeichenfolge>            Schr√§nkt ein, auf welchen Plattformen dieser Code ausgef√ºhrt werden kann: x86,
                              Itanium, x64, arm, arm64, anycpu32bitpreferred oder
                              anycpu. Die Standardeinstellung ist "anycpu".

                       ‚Äì EINGABEDATEIEN ‚Äì
-recurse:<Platzhalter>           Schlie√üt alle Dateien im aktuellen Verzeichnis und
                              in Unterverzeichnissen gem√§√ü Platzhalter-
                              spezifikationen ein.
-reference:<Alias>=<Datei>     Verweist auf Metadaten aus der angegebenen Assembly-
                              datei mithilfe eines angegebenen Alias (Kurzform: -r).
-reference:<Dateiliste>        Verweist auf Metadaten aus den angegebenen Assembly-
          