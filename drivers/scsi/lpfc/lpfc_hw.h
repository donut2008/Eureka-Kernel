e '{0}' no se puede convertir en '{1}'dEl valor constante '{0}' no se puede convertir en '{1}' (use la sintaxis 'unchecked' para invalidar)3El campo const requiere que se proporcione un valorSe espera un valor constanteØUn patr√≥n de tipo "{0}" no se puede controlar por un patr√≥n de tipo "{1}". Use la versi√≥n de lenguaje "{2}" o superior para buscar un tipo abierto con un patr√≥n constante.ùLa longitud de la constante de cadena resultante de la concatenaci√≥n supera el valor System.Int32.MaxValue. Pruebe a dividir la cadena en varias constantes.A'{0}': las clases est√°ticas no se pueden usar como restricciones;No se permiten restricciones en declaraciones no gen√©ricas4La restricci√≥n no puede ser un tipo din√°mico '{0}'@Las clases est√°ticas no pueden tener constructores de instanciaYLa conversi√≥n definida por el usuario debe realizarse en el tipo envolvente o desde este?La tupla con {0} elementos no se puede convertir al tipo '{1}'.Z"{0}": no se permiten conversiones definidas por el usuario ni a un tipo base ni desde √©l^"{0}": no se permiten conversiones definidas por el usuario ni a un tipo derivado ni desde √©l['{0}': no se permiten conversiones definidas por el usuario ni a una interfaz ni desde ella0No se puede convertir en el tipo est√°tico '{0}'®Un constructor de copia de un registro debe llamar a un constructor de copia de la base, o un constructor de objeto sin par√°metros si el registro se hereda del objeto.fUn constructor de copia "{0}" debe ser p√∫blico o estar protegido porque el registro no est√° sellado.%Error criptogr√°fico al crear hashes.NLa interfaz heredada '{1}' crea un ciclo en la jerarqu√≠a de interfaz de '{0}'AEl reenviador del tipo '{0}' en el ensamblado '{1}' crea un ciclonEl punto de entrada de depuraci√≥n debe ser una definici√≥n de un m√©todo declarado en la compilaci√≥n actual.aNo se pudo realizar la evaluaci√≥n de la expresi√≥n de la constante decimal y se produjo un error0No se permite una declaraci√≥n en este contexto.VEl nombre "{0}" no coincide con el par√°metro de "Deconstruct" correspondiente, "{1}".YLa asignaci√≥n de deconstrucci√≥n requiere una expresi√≥n con un tipo en el lado derecho.9La desconstrucci√≥n debe contener al menos dos variables.HNo se puede deconstruir una tupla de '{0}' elementos en '{1}' variables.aEl formato de desconstrucci√≥n 'var (...)' no permite especificar un tipo determinado para 'var'.wLa restricci√≥n "default" solo es v√°lida en los m√©todos de invalidaci√≥n y de implementaci√≥n de interfaz expl√≠cita.òEl tipo "{0}" no se puede incrustar porque tiene un miembro no abstracto. Puede establecer la propiedad "Incrustar tipos de interoperabilidad" en false.>No hay ning√∫n tipo de destino para el literal predeterminado.AEl uso del literal predeterminado no es v√°lido en este contexto.VNo se puede especificar el atributo DefaultMember en un tipo que contenga un indizadorªUn literal predeterminado "default" no es v√°lido como patr√≥n. Use otro literal (por ejemplo, "0" o "null") seg√∫n corresponda. Para hacer coincidir todo, use un patr√≥n de descarte "_".PEl argumento de tipo '{0}' no se puede aplicar al atributo DefaultParameterValueVLos par√°metros opcionales deben aparecer despu√©s de todos los par√°metros necesariosINo se puede especificar un valor predeterminado para el par√°metro 'this'NNo se puede especificar un valor predeterminado para una matriz de par√°metrosaEl valor de par√°metro predeterminado para '{0}' debe ser una constante en tiempo de compilaci√≥n=Los valores predeterminados no son v√°lidos en este contexto.dEl tipo de argumento para el atributo DefaultParameterValue debe coincidir con el tipo de par√°metrouNo se puede especificar un valor de par√°metro predeterminado junto con DefaultParameterAttribute u OptionalAttributetNo se puede crear un delegado con '{0}' porque √©l mismo o un m√©todo que √©l invalida tiene un atributo ConditionalVNo se puede enlazar el delegado con '{0}' porque es un miembro de 'System.Nullable<T>'9Referencia no coincidente entre "{0}" y el delegado "{1}"kEl mejor m√©todo Add sobrecargado '{0}' para el elemento inicializador de la colecci√≥n est√° obsoleto. {1}'{0}' est√° obsoleto: '{1}'8'{0}': no puede implementar una interfaz din√°mica '{1}'-'{0}': no se puede derivar del tipo din√°mico4'{0}' no se puede derivar de la clase especial '{1}'9No puede derivar de '{0}' porque es un par√°metro de tipoCUna variable no puede declararse dentro de un patr√≥n "not" u "or".5Las clases est√°ticas no pueden contener destructoresaUna expresi√≥n lambda de √°rbol de expresi√≥n no puede contener un inicializador de diccionarios.AEl par√°metro de descarte no se puede comprobar con valores NULL.∑El patr√≥n de descarte no se permite como etiqueta de caso en una instrucci√≥n switch. Use "case var _:" para un patr√≥n de descarte o "case @_:" para una constante con el nombre '_'.<No se puede deducir el tipo de descarte con tipo impl√≠cito.~El atributo DllImport no se puede aplicar a un m√©todo que sea gen√©rico o que est√© contenido en un tipo o m√©todo gen√©rico.XEl atributo DllImport se debe especificar en un m√©todo marcado como 'static' y 'extern'wNo utilice el atributo 'System.Runtime.CompilerServices.FixedBuffer'. En su lugar, use el modificador de campo 'fixed'.VNo utilice el atributo "System.Runtime.CompilerServices.FixedBuffer" en una propiedad.:Error al escribir en el archivo de documentaci√≥n XML: {0}1"{0}" no invalida la propiedad esperada de "{1}"./"{0}" no invalida el m√©todo esperado de "{1}".2"{0}" no invalida el m√©todo esperado de "object".'{0}' no implementa '{1}'2El nombre de tipo '{0}' no existe en el tipo '{1}'ÑEl tipo o el nombre del espacio de nombres '{0}' no existe en el espacio de nombres '{1}' (¬øfalta alguna referencia de ensamblado?)•No se encuentra el nombre de tipo '{0}' en el espacio de nombres '{1}'. Este tipo se ha reenviado al ensamblado '{2}'. Puede agregar una referencia a ese ensamblado.3Un par√°metro solo puede tener un modificador '{0}'@Un tipo de valor devuelto solo puede tener un modificador "{0}".9Ya se ha definido el descriptor de acceso de la propiedadCEl alias using '{0}' aparece previamente en este espacio de nombresAtributo '{0}' duplicado!Atributo '{0}' duplicado en '{1}'=Restricci√≥n '{0}' duplicada para el tipo de par√°metro '{1}'KLa instrucci√≥n switch contiene varios casos con el valor de etiqueta '{0}'…Ya se ha especificado una cl√°usula de restricciones para el par√°metro de tipo '{0}'. Todas las restricciones correspondientes a un par√°metro de tipo se deben especificar en una sola cl√°usula where.>Conversi√≥n definida por el usuario duplicada en el tipo '{0}'="{0}" est√° implementado de forma expl√≠cita m√°s de una vez.fEl nombre de par√°metro '{0}' entra en conflicto con un nombre de par√°metro generado autom√°ticamentevSe han importado varios ensamblados con identidad equivalente: '{0}' y '{1}'. Quite una de las referencias duplicadas.ØYa se ha importado un ensamblado con el mismo nombre sencillo '{0}'. Intente quitar una de las referencias (por ej., '{1}') o f√≠rmelas para habilitar la funci√≥n en paralelo.*'{0}' ya aparece en la lista de interfacesJ"{0}" ya se muestra en la lista de interfaces en el tipo "{2}" como "{1}".x'{0}' ya se muestra en la lista de interfaces en el tipo '{2}' con nombres de elementos de tupla diferentes, como '{1}'.!La etiqueta '{0}' est√° duplicadaModificador '{0}' duplicado4El tipo '{0}' ya contiene una definici√≥n para '{1}'BEl espacio de nombres '{1}' ya contiene una definici√≥n para '{0}'BEl argumento con nombre '{0}' no se puede especificar varias veces6'{0}' es un argumento de atributo con nombre duplicado5Duplicar el operador de supresi√≥n de tipo null ("!")-El nombre de par√°metro '{0}' est√° duplicadoNo se pueden especificar modificadores de accesibilidad para ambos descriptores de acceso de la propiedad o del indizador '{0}'∏No se pueden especificar modificadores "readonly" en ambos descriptores de acceso de la propiedad o del indizador "{0}". En su lugar, coloque un modificador "readonly" en la propiedad.5'Elemento TypeForwardedToAttribute duplicado en '{0}'"Par√°metro de tipo duplicado '{0}'öNo se puede definir una clase o un miembro que use 'dynamic', porque no se encuentra el tipo '{0}' requerido por el compilador. ¬øFalta alguna referencia?gNo se puede pasar un argumento de tipo din√°mico al par√°metro params '{0}' de la funci√≥n local '{1}'.sNo se puede pasar un argumento con tipo din√°mico a funci√≥n local gen√©rica "{0}" con argumentos de tipo inferido.qNo se encuentran uno o varios tipos necesarios para compilar una expresi√≥n din√°mica. ¬øFalta alguna referencia?.La restricci√≥n no puede ser el tipo din√°micoNSe esperaba una definici√≥n de tipo o espacio de nombres, o el fin del archivo-‚Äúelse‚Äù no puede iniciar una instrucci√≥n.Literal de car√°cter vac√≠o2El inicializador de elemento no puede estar vac√≠o Especificador de formato vac√≠o.<Se esperaba una expresi√≥n tras la instrucci√≥n yield return\No se puede continuar porque la edici√≥n incluye una referencia a un tipo incrustado: '{0}'.ÖAl miembro '{0}' agregado durante la sesi√≥n de depuraci√≥n actual solo se puede acceder desde el ensamblado donde se declara, '{1}'.DNo se puede actualizar porque ha cambiado un tipo delegado inferido.6No se puede actualizar '{0}'; falta el atributo '{1}'.XNo se puede emitir informaci√≥n de depuraci√≥n para un texto de origen sin descodificar.:Se esperaba un comentario de una l√≠nea o un fin de l√≠nea#Se esperaba la directiva #endregionSe esperaba la directiva #endifYLos puntos de entrada de la aplicaci√≥n no se pueden atribuir con "UnmanagedCallersOnly".K'{0}': el valor del enumerador es demasiado grande para ajustarse a su tipoNLas enumeraciones no pueden contener constructores expl√≠citos sin par√°metros`La propiedad del contrato de igualdad de registros "{0}" debe tener un descriptor de acceso get.(Error al compilar recursos de Win32: {0}#error: '{0}'?Hay un error en un ensamblado al que se hace referencia: '{0}'.©No se puede usar un resultado de "{0}" en este contexto porque puede exponer variables a las que el par√°metro "{1}" hace referencia fuera de su √°mbito de declaraci√≥n.µNo se puede usar un miembro del resultado de "{0}" en este contexto porque puede exponer variables a las que el par√°metro "{1}" hace referencia fuera de su √°mbito de declaraci√≥n.öNo se puede usar un elemento "{0}" local en este contexto porque puede exponer variables a las que se hace referencia fuera de su √°mbito de declaraci√≥n.ÉNo se puede usar una expresi√≥n en este contexto porque puede exponer variables indirectamente fuera de su √°mbito de declaraci√≥n.éEl resultado de una expresi√≥n stackalloc de tipo "{0}" no se puede usar en este contexto porque puede exponerse fuera del m√©todo contenedor.WEl car√°cter '{0}' solo se puede escapar duplicando '{0}{0}' en una cadena interpolada.Q'{0}': la propiedad del evento debe tener los descriptores de acceso add y remove*'{0}': el evento debe ser de tipo delegado,Se esperaba la palabra clave contextual 'by'0Se esperaba la palabra clave contextual 'equals',Se esperaba la palabra clave contextual 'on'Se esperaba catch o finally/Se esperaba un nombre de archivo entre comillasHEl cuerpo de una consulta debe terminar con una cl√°usula select o groupDSe esperaba un script (archivo .csx), pero no se especific√≥ ningunoaSe esperaba una palabra clave, un identificador o una cadena detr√°s del especificador textual: @fNo use 'System.Runtime.CompilerServices.DynamicAttribute'. Use la palabra clave 'dynamic' en su lugar.pUna implementaci√≥n de interfaz expl√≠cita de un evento debe usar la sintaxis de descriptor de acceso de eventoseNo use 'System.Runtime.CompilerServices.ExtensionAttribute'. Use la palabra clave 'this' en su lugar.™No se puede heredar la interfaz '{0}' con los par√°metros de tipo especificados porque da lugar a que el m√©todo '{1}' contenga sobrecargas que difieren solo en ref y outF'{0}' no debe tener un par√°metro params porque '{1}' tampoco lo tienejLa implementaci√≥n expl√≠cita de un operador definido por el usuario "{0}" se debe declarar como est√°ticou"{0}": la declaraci√≥n expl√≠cita de la interfaz solo se puede declarar en una clase, registro, estructura o interfazE'{0}' en la declaraci√≥n expl√≠cita de la interfaz no es una interfazm'La implementaci√≥n del m√©todo expl√≠cito '{0}' no puede implementar '{1}' porque es un descriptor de acceso_No se permite la aplicaci√≥n expl√≠cita de "System.Runtime.CompilerServices.NullableAttribute".ONo use 'System.ParamArrayAttribute'. Use la palabra clave 'params' en su lugar.X'{0}' agrega un descriptor de acceso que no se encuentra en el miembro de interfaz '{1}'eLos descriptores de acceso "{0}" y "{1}" deben ser los dos solo de inicializaci√≥n o ninguno de ellosXA la implementaci√≥n de interfaz expl√≠cita '{0}' le falta el descriptor de acceso '{1}'6No use "{0}". Est√° reservado para uso del compilador.§No se puede hacer referencia a 'System.Runtime.CompilerServices.TupleElementNamesAttribute' expl√≠citamente. Use la sintaxis de tupla para definir nombres de tupla.}El tipo '{0}' exportado del m√≥dulo '{1}' entra en conflicto con el tipo declarado en el m√≥dulo primario de este ensamblado.kEl tipo '{0}' exportado del m√≥dulo '{1}' entra en conflicto con el tipo '{2}' exportado del m√≥dulo '{3}'.LLa expresi√≥n proporcionada no se puede utilizar en una instrucci√≥n "fixed"Se esperaba una expresi√≥n!La expresi√≥n no tiene un nombre.=Se esperaba una instrucci√≥n de expresi√≥n o de declaraci√≥n.JUn √°rbol de expresi√≥n no puede contener una asignaci√≥n de fusi√≥n nula.fUn √°rbol de expresi√≥n no puede contener un valor de estructura ref ni el tipo restringido ‚Äú{0}‚Äù.cUn √°rbol de (la) expresi√≥n no puede contener un acceso de miembro de interfaz abstracta est√°ticaLUn √°rbol de expresi√≥n no puede contener una expresi√≥n de m√©todo an√≥nimoDUn √°rbol de expresi√≥n no puede contener un operador de asignaci√≥nïUn elemento lambda de √°rbol de expresi√≥n no puede contener un operador de incorporaci√≥n con un literal predeterminado o nulo en la parte izquierda8Un √°rbol de expresi√≥n no puede contener un acceso base6Un √°rbol de expresi√≥n no puede contener un descarte.BUn √°rbol de expresi√≥n no puede contener una operaci√≥n din√°mica[Un √°rbol de expresi√≥n no puede contener una expresi√≥n de √≠ndice del otro extremo ("^").@Un √°rbol de expresi√≥n no puede contener una propiedad indizadadUn √°rbol de (la) expresi√≥n no puede contener una conversi√≥n de controlador de cadena interpolada.WUn √°rbol de expresi√≥n no puede contener un operador de coincidencia de patrones 'is'.NUn √°rbol de expresi√≥n no puede contener una referencia a una funci√≥n local.UUn √°rbol de expresi√≥n no puede contener un inicializador de matriz multidimensionalUUn √°rbol de expresi√≥n no puede contener una especificaci√≥n de argumento con nombreaUn √°rbol de expresi√≥n no puede contener una llamada o invocaci√≥n que use argumentos opcionalesXUn √°rbol de expresi√≥n no puede contener una declaraci√≥n de variable de argumento out.gUn √°rbol de expresi√≥n no puede contener un patr√≥n System.Index o un acceso a indizador System.Range.MUn √°rbol de expresi√≥n no puede contener una operaci√≥n de puntero no seguraMUn √°rbol de expresi√≥n no puede contener una expresi√≥n de intervalo ("..").@Un √°rbol de expresi√≥n no puede contener una expresi√≥n switch.?Un √°rbol de expresi√≥n no puede contener una expresi√≥n throw.GUn √°rbol de expresi√≥n no puede contener un operador de tupla == o !=.CUn √°rbol de expresi√≥n no puede contener una conversi√≥n de tupla.>Un √°rbol de expresi√≥n no puede contener un literal de tupla.EAn expression tree may not contain UTF8 string conversion or literal.>Un √°rbol de expresi√≥n no puede contener una expresi√≥n with.{No se puede convertir una expresi√≥n lambda en un √°rbol de expresi√≥n cuyo argumento de tipo '{0}' no sea un tipo delegado°No se puede definir un nuevo m√©todo de extensi√≥n porque no se encontr√≥ el tipo '{0}' requerido por el compilador. ¬øFalta alguna referencia a System.Core.dll?iNo se admite un m√©todo Add de extensi√≥n para un inicializador de colecci√≥n en un lambda de expresi√≥n.mLos m√©todos de extensi√≥n deben definirse en una clase est√°tica de nivel superior; {0} es una clase anidadakLa declaraci√≥n de un alias externo debe preceder a los dem√°s elementos definidos en el espacio de nombres-'extern alias' no es v√°lido en este contexto8"{0}": un evento externo no puede tener un inicializador/'{0}' no puede ser externo y declarar un cuerpoB'{0}' no puede ser externo y tener un inicializador de constructor≠La caracter√≠stica "{0}" se encuentra actualmente en vista previa y *no se admite*. Para usar caracter√≠sticas en vista previa, utilice la versi√≥n de idioma "vista previa".^La caracter√≠stica "{0}" es experimental y no se admite. Use "/features:{1}" para habilitarla.fLa caracter√≠stica "{0}" no est√° disponible en C# 1. Use la versi√≥n de lenguaje {1} u otra superior.jLa caracter√≠stica "{0}" no est√° disponible en C# 10.0. Use la versi√≥n {1} del lenguaje o una posterior.fLa caracter√≠stica "{0}" no est√° disponible en C# 2. Use la versi√≥n de lenguaje {1} u otra superior.fLa caracter√≠stica "{0}" no est√° disponible en C# 3. Use la versi√≥n de lenguaje {1} u otra superior.fLa caracter√≠stica "{0}" no est√° disponible en C# 4. Use la versi√≥n de lenguaje {1} u otra superior.fLa caracter√≠stica "{0}" no est√° disponible en C# 5. Use la versi√≥n de lenguaje {1} u otra superior.fLa caracter√≠stica "{0}" no est√° disponible en C# 6. Use la versi√≥n de lenguaje {1} u otra superior.jLa caracter√≠stica "{0}" no est√° disponible en C# 7.0. Use la versi√≥n del lenguaje {1} u otra posterior.hLa caracter√≠stica "{0}" no est√° disponible en C# 7.1. Use la versi√≥n de lenguaje {1} u otra superior.iLa caracter√≠stica "{0}" no est√° disponible en C# 7.2. Use la versi√≥n {1} del lenguaje o una posterior.iLa caracter√≠stica "{0}" no est√° disponible en C# 7.3. Use la versi√≥n {1} del lenguaje o una posterior.iLa caracter√≠stica "{0}" no est√° disponible en C# 8.0. Use la versi√≥n {1} del lenguaje o una posterior.iLa caracter√≠stica "{0}" no est√° disponible en C# 8.0. Use la versi√≥n {1} del lenguaje o una posterior.iLa caracter√≠stica "{0}" no est√° disponible en C# 9.0. Use la versi√≥n {1} del lenguaje o una posterior./Un √°rbol de expresi√≥n no puede contener '{0}'íUn campo o una propiedad implementada autom√°ticamente no pueden ser de tipo "{0}", a menos que sea un miembro de instancia de una estructura ref.4El campo o la propiedad no pueden ser del tipo '{0}'$El campo no puede tener un tipo void3El campo tiene varios valores constantes distintos.eUn inicializador de campo no puede hacer referencia al campo, m√©todo o propiedad no est√°ticos '{0}'6El evento de tipo campo "{0}" no puede ser "readonly".<No se admiten eventos de tipo campo en estructuras readonly.GLos campos de instancia de las estructuras readonly deben ser readonly.+No se encontr√≥ el archivo de origen '{0}'.lEl archivo de origen no puede contener declaraciones de espacio de nombres normales y de √°mbito de archivo.eEl espacio de nombres con √°mbito de archivo debe preceder a todos los dem√°s miembros de un archivo.ÄNo puede utilizar los b√∫feres de tama√±o fijo contenidos en expresiones de tipo unfixed. Pruebe a usar la instrucci√≥n "fixed"./Un b√∫fer fijo solo puede tener una dimensi√≥n.oUn campo de b√∫fer de tama√±o fijo debe tener el especificador de tama√±o de matriz detr√°s del nombre de campo|No se puede usar el valor local fijo '{0}' dentro de un m√©todo an√≥nimo, una expresi√≥n lambda o una expresi√≥n de consultaTDebe proporcionar un inicializador en una declaraci√≥n de instrucci√≥n fixed o usingrSolo se puede adquirir la direcci√≥n de una expresi√≥n de tipo unfixed de un inicializador de instrucci√≥n "fixed"]Solo se puede tener acceso a los b√∫feres de tama√±o fijo mediante variables locales o camposLLos campos de b√∫fer de tama√±o fijo solo pueden ser miembros de estructurasdNo se puede usar la instrucci√≥n "fixed" para adquirir la direcci√≥n de una expresi√≥n de tipo fixedJEl b√∫fer de tama√±o fijo de longitud {0} y tipo '{1}' es demasiado grandeGLa constante de punto flotante est√° fuera del intervalo del tipo '{0}'°La instrucci√≥n foreach no puede funcionar en variables de tipo "{0}" porque "{0}" no contiene ninguna definici√≥n de extensi√≥n o instancia p√∫blica para "{1}".ﬁLa instrucci√≥n foreach no puede funcionar en variables de tipo "{0}" porque "{0}" no contiene ninguna definici√≥n de extensi√≥n o instancia p√∫blica para "{1}". ¬øQuiso decir ‚Äúawait foreach‚Äù en lugar de ‚Äúforeach‚Äù?kEl tipo reenviado '{0}' entra en conflicto con el tipo declarado en el m√≥dulo primario de este ensamblado.mEl tipo '{0}' reenviado al ensamblado '{1}' entra en conflicto con el tipo '{2}' exportado del m√≥dulo '{3}'.hEl tipo '{0}' est√° definido en este ensamblado, pero se ha especificado un reenviador de tipos para √©lEEl tipo '{0}' no se puede reenviar porque es un tipo anidado de '{1}'oEl tipo '{0}' reenviado al ensamblado '{1}' entra en conflicto con el tipo '{2}' reenviado al ensamblado '{3}'.‰La referencia de ensamblado de confianza '{0}' no es v√°lida. Las declaraciones InternalsVisibleTo no pueden tener especificada una versi√≥n, una referencia cultural, un token de clave p√∫blica ni una arquitectura de procesador.∂La referencia de ensamblado de confianza '{0}' no es v√°lida. Los ensamblados firmados con nombre seguro deben especificar una clave p√∫blica en sus declaraciones InternalsVisibleTo.ƒ‚Äú{0}‚Äù ha concedido acceso de confianza, pero la clave p√∫blica del ensamblado de salida ({1}) no coincide con la especificada por el atributo InternalsVisibleTo en el ensamblado de concesi√≥n.õ'{0}' ha concedido acceso de confianza, pero el nombre seguro que firma el estado del ensamblado de salida no coincide con el del ensamblado de concesi√≥n.VNo se puede crear un puntero de funci√≥n para "{0}" porque no es un m√©todo est√°tico.DReferencia no coincidente entre "{0}" y el puntero de funci√≥n "{1}"YNo se admite el uso de un tipo de puntero de funci√≥n como valor "typeof" de un atributo.ENo se puede llamar a un puntero a funci√≥n con argumentos con nombre.E'{0}': los tipos est√°ticos no se pueden usar como argumentos de tipo¡La interfaz "{3}" no se puede usar como par√°metro de tipo "{2}" en el tipo o m√©todo gen√©rico "{0}". La interfaz de restricci√≥n "{1}" o su interfaz base tiene miembros abstractos est√°ticos.¨El tipo '{3}' no se puede usar como par√°metro de tipo '{2}' en el tipo o m√©todo gen√©rico '{0}'. El tipo que acepta valores NULL '{3}' no cumple la restricci√≥n de '{1}'.¸El tipo '{3}' no se puede usar como par√°metro de tipo '{2}' en el tipo o m√©todo gen√©rico '{0}'. El tipo que acepta valores NULL '{3}' no cumple la restricci√≥n de '{1}'. Los tipos que aceptan valores NULL no pueden cumplir restricciones de interfaz.®El tipo '{3}' no se puede usar como par√°metro de tipo '{2}' en el tipo o m√©todo gen√©rico '{0}'. No hay ninguna conversi√≥n de referencia impl√≠cita de '{3}' a '{1}'.≥El tipo '{3}' no se puede usar como par√°metro de tipo '{2}' en el tipo o m√©todo gen√©rico '{0}'. No hay conversi√≥n boxing ni conversi√≥n de par√°metro de tipo de '{3}' a '{1}'.éEl tipo '{3}' no se puede usar como par√°metro de tipo '{2}' en el tipo o m√©todo gen√©rico '{0}'. No hay conversi√≥n boxing de '{3}' a '{1}'.∑El tipo "{0}" del ensamblado "{1}" no se puede usar en los distintos l√≠mites de ensamblado porque tiene un argumento de tipo gen√©rico que es un tipo de interoperabilidad incrustado.óEl tipo '{0}' no se puede incrustar porque tiene un argumento gen√©rico. Puede establecer la propiedad 'Incrustar tipos de interoperabilidad' en false.-Se esperaba un descriptor de acceso get o setAEn este contexto no se permiten atributos de ensamblado y m√≥dulo™Los atributos de m√≥dulo y ensamblado deben ir delante de los dem√°s elementos definidos en un archivo, excepto las cl√°usulas using y las declaraciones de alias externosASe esperaba una definici√≥n, una instrucci√≥n o un fin de archivo4No se puede definir de nuevo el alias externo globalåEl nombre del tipo o del espacio de nombres '{0}' no se encontr√≥ en el espacio de nombres global (¬øfalta alguna referencia de ensamblado?)¶No se encuentra el nombre de tipo '{0}' en el espacio de nombres global. Este tipo se ha reenviado al ensamblado '{1}'. Puede agregar una referencia a ese ensamblado.PLas expresiones y las instrucciones solo pueden aparecer en un cuerpo de m√©todoVNo se puede usar una directiva global mediante una declaraci√≥n de espacio de nombres.cUna directiva de uso global debe ser anterior a todas las directivas no globales que no son de uso.pUna instrucci√≥n goto no puede saltar a una ubicaci√≥n antes que una declaraci√≥n using dentro del mismo bloque.ZUna instrucci√≥n goto no puede saltar a una ubicaci√≥n despu√©s de una declaraci√≥n using.AEl {1} '{0}' no gen√©rico no se puede usar con argumentos de tipoPEl miembro posicional '{0}' que se corresponde con este par√°metro est√° oculto.0'{0}' oculta el miembro abstracto heredado '{1}'Se esperaba un identificador8Se esperaba un identificador; '{1}' es una palabra claveKUn operador definido por el usuario no puede convertir un tipo en s√≠ mismoVLa expresi√≥n __arglist solo puede aparecer dentro de una llamada o una expresi√≥n new´No se permite la secuencia de caracteres \"@\". Una cadena textual o un identificador solo pueden tener un car√°cter \"@\" y una cadena sin formato no puede tener ninguno.!Secuencia de escape no reconocidaüEl tipo de b√∫fer de tama√±o fijo debe pertenecer a uno de los tipos siguientes: bool, byte, short, int, long, char, sbyte, ushort, uint, ulong, float o double1No puede aparecer c√≥digo no seguro en iteradores%params no es v√°lido en este contexto*ref y out no son v√°lidos en este contexto|Solo las expresiones de asignaci√≥n, llamada, incremento, decremento, espera y objeto nuevo se pueden usar como instrucci√≥n9No se permite el operador de supresi√≥n en este contexto.BEl c√≥digo no seguro solo puede aparecer si se compila con /unsafe(__arglist no es v√°lido en este contextoyModificador de varianza no v√°lido. Solo se pueden especificar como variantes par√°metros de tipo de interfaz y delegado.ÈLas restricciones para el par√°metro de tipo '{0} del m√©todo '{1} deben coincidir con las restricciones del par√°metro de tipo '{2} del m√©todo de interfaz '{3}. Si lo prefiere, puede usar una implementaci√≥n de interfaz expl√≠cita.§Los nombres de elementos de tupla en la firma del m√©todo '{0}' deben coincidir con los del m√©todo de interfaz '{1}' (que se incluye en el tipo de valor devuelto).IAn 'implicit' user-defined conversion operator cannot be declared checkedµ"{0}" no implementa el miembro de interfaz "{1}". "{2}" no puede implementar impl√≠citamente un miembro no p√∫blico en el {3} de C#. Use la versi√≥n de idioma "{4}" o una posterior.RLa invocaci√≥n del indizador de √≠ndices impl√≠cito no puede nombrar el argumento.=El tipo "{0}" no se puede usar como tipo de destino de new().*No hay ning√∫n tipo de destino para "{0}"./El uso de new() no es v√°lido en este contexto.PLa invocaci√≥n del indizador de rangos impl√≠cito no puede nombrar el argumento.@No se encontr√≥ el mejor tipo para la matriz con tipo impl√≠cito=Las variables locales con tipo impl√≠cito no pueden ser fijasiNo se permite la referencia a una variable out con tipo impl√≠cito '{0}' en la misma lista de argumentos.WUna variable con tipo impl√≠cito no se puede inicializar con un inicializador de matriz:No se puede asignar {0} a una variable con tipo impl√≠cito:Las variables con tipo impl√≠cito no pueden ser constantesELas variables con tipo impl√≠cito no pueden tener varios declaradores6Las variables con tipo impl√≠cito se deben inicializar>El archivo '{0}' al que se hace referencia no es un ensambladoVEl tipo "{0}" importado no es v√°lido. Contiene una dependencia de tipo base circular./Un par√°metro Out no puede tener un atributo In`No se pueden usar argumentos con el modificador "in" en expresiones distribuidas din√°micamente.'Se esperaba 'in'lEl primer par√°metro del m√©todo de extensi√≥n "in" "{0}" debe ser un tipo de valor concreto (no gen√©rico).vLa propiedad o el indizador '{0}' no se pueden usar en este contexto porque el descriptor de acceso get es inaccesiblevLa propiedad o el indizador '{0}' no se pueden usar en este contexto porque el descriptor de acceso set es inaccesibleäDos indizadores tienen nombres distintos; el atributo IndexerName se debe utilizar con el mismo nombre en todos los indizadores de un tiponUso incoherente del par√°metro lambda; los tipos de par√°metro deben ser todos expl√≠citos o todos impl√≠citosiEl operando de un operador de incremento o decremento debe ser una variable, una propiedad o un indizadorFLa propiedad indizada '{0}' debe tener todos los argumentos opcionalesTLa propiedad indizada '{0}' tiene argumentos no opcionales que se deben proporcionar,Los indizadores no pueden tener un tipo void?'{0}': no se pueden declarar indizadores en una clase est√°tica2Los indizadores deben tener al menos un par√°metroPEl constructor '{0}' no puede llamarse a s√≠ mismo a trav√©s de otro constructorNo se admite heredar desde un registro con 'Object.ToString' sellado en C# {0}. Utilice la versi√≥n de idioma '{1}' o superior.nLos descriptores de acceso "init" no se pueden marcar como "readonly". Marque en su lugar "{0}" como readOnly.ANo se puede inicializar una variable por referencia con un valor.BNo se puede inicializar una variable por valor con una referencia.ŒLa mejor coincidencia de m√©todo sobrecargado '{0}' para el elemento inicializador de la colecci√≥n no se puede usar. Los m√©todos 'Add' inicializadores de colecci√≥n no pueden tener par√°metros out ni ref.ªLa mejor coincidencia de m√©todo sobrecargado para '{0}' tiene una firma err√≥nea para el elemento inicializador. El elemento Add inicializable debe ser un m√©todo de instancia accesible.^Las estructuras sin constructores expl√≠citos no pueden contener miembros con inicializadores.QSolo las propiedades implementadas autom√°ticamente pueden tener inicializadores.H'{0}': no se puede declarar miembros de instancia en una clase est√°ticaRLas propiedades de la instancia en las interfaces no pueden tener inicializadores.?No se puede crear ninguna instancia de la clase est√°tica '{0}'<Una expresi√≥n es demasiado larga o compleja para compilarlaDivisi√≥n entre constante cero*La constante integral es demasiado extensaGSe esperaba el tipo byte, sbyte, short, ushort, int, uint, long o ulong!Se espera un valor de tipo enteroL"{0}": el evento de instancia en la interfaz no puede tener un inicializador_El miembro condicional '{0}' no puede implementar el miembro de interfaz '{1}' en el tipo '{2}'jEl m√©todo "UnmanagedCallersOnly" "{0}" no puede implementar el miembro de interfaz "{1}" en el tipo "{2}"y‚Äú{0}‚Äù no puede implementar el miembro de interfaz ‚Äú{1}‚Äù en el tipo ‚Äú{2}‚Äù porque tiene un par√°metro __arglist{No se encuentra "{0}" en la declaraci√≥n de interfaz expl√≠cita entre los miembros de la interfaz que se pueden implementar;Las interfaces no pueden incluir constructores de instanciacLos operadores de conversi√≥n, igualdad o desigualdad declarados en interfaces deben ser abstractos4Las interfaces no pueden incluir campos de instancia%Error interno en el compilador de C#.DEl m√©todo de interoperabilidad incrustado '{0}' contiene un cuerpo.fLa estructura de interoperabilidad incrustada '{0}' solo puede contener campos de instancia p√∫blicos.eEl tipo de interoperabilidad '{0}' no se puede incrustar porque le falta el atributo '{1}' requerido.¥No se puede incrustar el tipo de interoperabilidad '{0}' encontrado en los ensamblados '{1}' y '{2}'. Puede establecer la propiedad 'Incrustar tipos de interoperabilidad' en false.∏El atributo InterpolatedStringHandlerArgumentAttribute aplicado al par√°metro "{0}" tiene un formato incorrecto y no se puede interpretar. Construya manualmente una instancia de "{1}".çEl par√°metro "{0}" es un argumento de la conversi√≥n del controlador de cadena interpolada en el par√°metro "{1}", pero el argumento correspondiente se especifica despu√©s de la expresi√≥n de cadena interpolada. Reordene los argumentos para mover "{0}" antes de "{1}".÷El par√°metro "{0}" no se ha proporcionado expl√≠citamente, pero se usa como argumento de la conversi√≥n del controlador de cadenas interpoladas en el par√°metro "{1}". Especifique el valor de "{0}" antes de "{1}".}Una construcci√≥n de controlador de cadena interpolada no puede usar din√°mica. Construya manualmente una instancia de "{0}".~El m√©todo de control de cadenas interpoladas "{0}" tiene un tipo de valor devuelto incoherente. Se espera que devuelva "{1}".pEl m√©todo de controlador de cadena interpolada "{0}" tiene un formato incorrecto. No devuelve "void" ni "bool".∞Las conversiones de controlador de cadenas interpoladas que hacen referencia a la instancia que se est√° indizando no se puede usar en inicializadores de miembros de indizador.8No se puede adquirir la direcci√≥n de la expresi√≥n dada™Declarador de miembro de tipo an√≥nimo no v√°lido. Los miembros de tipo an√≥nimo deben declararse con una asignaci√≥n de miembro, un nombre simple o un acceso al miembro.8Especificador de rango no v√°lido: se esperaba ',' o ']'`Las cadenas de referencia cultural de ensamblado no pueden contener caracteres NULL incrustados.aLos archivos ejecutables no pueden ser ensamblados sat√©lite y no deben tener referencia culturalFLa referencia de ensamblado '{0}' no es v√°lida y no se puede resolver5Valor no v√°lido para el argumento del atributo '{0}'Ë'{0}' es de tipo '{1}'. El tipo especificado en una declaraci√≥n de constantes debe ser sbyte, byte, short, ushort, int, uint, long, ulong, char, float, double, decimal, bool, string, un tipo de enumeraci√≥n o un tipo de referencia.mNo se puede leer la informaci√≥n de depuraci√≥n del m√©todo "{0}" (token 0x{1:X8}) desde el ensamblado "{2}".9Formato de la informaci√≥n de depuraci√≥n no v√°lido: {0}òEl delegado '{0}' no tiene m√©todo 'invoke' o tiene un m√©todo 'invoke' con un tipo de valor devuelto o unos tipos de par√°metro que no son compatibles.rLa expresi√≥n se debe poder convertir impl√≠citamente en 'Boolean' o su tipo '{0}' debe definir el operador '{1}'.-El t√©rmino de expresi√≥n '{0}' no es v√°lido3Alineaci√≥n de secci√≥n de archivo no v√°lida "{0}"DLos b√∫feres de tama√±o fijo deben tener una longitud mayor que cero_Error de sintaxis de l√≠nea de comandos: formato de GUID '{0}' no v√°lido para la opci√≥n '{1}'ã"{0}" no es un modificador de tipo de valor devuelto de puntero de funci√≥n v√°lido. Los modificadores v√°lidos son "ref" y "ref readonly".["{0}" no es un especificador de convenci√≥n de llamada v√°lido para un puntero de funci√≥n.LTipo no v√°lido especificado como argumento para el atributo TypeForwardedToLUna instrucci√≥n goto case solo es v√°lida dentro de una instrucci√≥n switch*Nombre de algoritmo hash no v√°lido: "{0}"1Declarador de miembro de inicializador no v√°lido)Clase de instrumentaci√≥n no v√°lida: {0}7"{0}" no es un nombre de par√°metro v√°lido para "{1}".OFalta el n√∫mero de l√≠nea especificado para la directiva #line o no es v√°lidopEl token "{0}" no es v√°lido en una clase, un registro, una estructura o una declaraci√≥n de miembro de interfazsEl modificador "{0}" no es v√°lido para este elemento en C# {1}. Use la versi√≥n de lenguaje "{2}" o una posterior.;Se esperaba un identificador o un acceso de miembro simple.@Valor no v√°lido para el argumento '{0}' del atributo con nombreN√∫mero no v√°lidoCreaci√≥n de objeto no v√°lida(Nombre de archivo salida no v√°lido: {0}1La opci√≥n pathmap no ten√≠a el formato correcto.&Expresi√≥n de preprocesador no v√°lida\Nombre no v√°lido para un s√≠mbolo de preprocesamiento; "{0}" no es un identificador v√°lido~El modificador de accesibilidad del descriptor de acceso '{0}' debe ser m√°s restrictivo que la propiedad o el indizador '{1}'ÖNo se pueden especificar modificadores "readonly" en la propiedad o el indizador "{0}" y su descriptor de acceso. Quite uno de ellos.xNo se puede determinar el tipo de la expresi√≥n condicional porque no hay una conversi√≥n impl√≠cita entre '{0}' y '{1}'Literal real no v√°lido.WSe especific√≥ una clave p√∫blica de firma no v√°lida en AssemblySignatureKeyAttribute./'{0}' no es un especificador de formato v√°lido4"Especificador de rango no v√°lido: se esperaba "]""ñVersi√≥n {0} no v√°lida para /subsystemversion. La versi√≥n debe ser 6.02 o posterior para ARM o AppContainerExe, y 4.00 o posterior en caso contrarioR"{0}" no es un tipo de convenci√≥n de llamada v√°lido para "UnmanagedCallersOnly".wLa cadena de versi√≥n especificada no se ajusta al formato requerido: principal[.secundaria[.compilaci√≥n[.revisi√≥n]]]ÅLa cadena de versi√≥n especificada no se ajusta al formato requerido: principal.secundaria.compilaci√≥n.revisi√≥n (sin comodines)øLa versi√≥n especificada contiene comodines, que no son compatibles con la determinaci√≥n. Quite los comodines de la cadena de versi√≥n o deshabilite la determinaci√≥n para esta compilaci√≥n.@El receptor de una expresi√≥n "with" debe tener un tipo no nulo.|No se puede usar el tipo "{0}?" que acepta valores NULL en una expresi√≥n is-type; use en su lugar el tipo "{0}" subyacente.SUna expresi√≥n de tipo "{0}" no puede coincidir nunca con el patr√≥n proporcionado.WEl m√©todo "{0}" con un bloqueo de iterador debe ser "asincr√≥nico" para devolver "{1}"ANo existe la etiqueta '{0}' en el √°mbito de la instrucci√≥n gotoOLa etiqueta '{0}' oculta otra etiqueta del mismo nombre en un √°mbito contenido`La palabra clave contextual "var" no se puede utilizar como un tipo de retorno lambda expl√≠citoáEs posible que el primer operando de un operador 'is' o 'as' no sea una expresi√≥n lambda, un m√©todo an√≥nimo ni un grupo de m√©todos.TUna expresi√≥n lambda con atributos no se puede convertir en un √°rbol de expresi√≥nLLa versi√≥n de lenguaje especificada "{0}" no puede tener ceros al principio∏"{0}" no puede implementar el miembro de interfaz "{1}" en el tipo "{2}" porque la caracter√≠stica "{3}" no est√° disponible en C# {4}. Use la versi√≥n de idioma "{5}" o una posterior.Se esperaba {;'Ya no se admite la sintaxis 'id#'. En su lugar, use '$id'.ÑLa l√≠nea contiene un espacio en blanco diferente de la l√≠nea de cierre del literal de cadena sin formato: \"{0}\" frente a \"{1}\"oLa l√≠nea no comienza con el mismo espacio en blanco que la l√≠nea de cierre del literal de cadena sin formato.XLa posici√≥n final de la directiva #line debe ser mayor o igual que la posici√≥n inicial9Falta el valor de directiva #line o est√° fuera del rangoPEl metadato netmodule vinculado debe proporcionar una imagen PE completa: '{0}'.ÖNo se pueden usar patrones de lista para un valor de tipo \"{0}\". No se encontr√≥ ninguna propiedad \"Length\" o \"Count\" adecuada.àEl literal de tipo double no se puede convertir impl√≠citamente en el tipo '{1}'; use un sufijo '{0}' para crear un literal de este tipo #load solo se permite en scriptsLa variable local '{0}' o sus miembros no pueden ceder su direcci√≥n para usarse en un m√©todo an√≥nimo o una expresi√≥n lambdaPUna variable o funci√≥n local denominada '{0}' ya se ha definido en este √°mbito]La funci√≥n local "{0}" debe declarar un cuerpo porque no est√° marcada como "static extern".ÀUna variable local o un par√°metro denominados '{0}' no se pueden declarar en este √°mbito porque ese nombre se est√° usando en un √°mbito local envolvente para definir una variable local o un par√°metroy'{0}': un par√°metro o una variable o funci√≥n local no pueden tener el mismo nombre que un par√°metro de tipo de m√©todoŸSi se incrusta el tipo de interoperabilidad '{0}' desde el ensamblado '{1}', se producir√° un conflicto de nombre en el ensamblado actual. Puede establecer la propiedad 'Incrustar tipos de interoperabilidad' en false.C'{0}' no es el tipo de referencia que requiere la instrucci√≥n lockENo se pueden buscar miembros en '{0}' porque es un par√°metro de tipoBNo se puede usar '{0}' para el m√©todo Main porque se ha importadorEl objeto "{0}" especificado para el m√©todo Main debe ser una clase, registro, estructura o interfaz no gen√©rica7No se encontr√≥ '{0}' especificado para el m√©todo MainlNo se puede adquirir la direcci√≥n, obtener el tama√±o ni declarar un puntero a un tipo administrado ('{0}')<El tipo '{0}' sin administrar no es v√°lido para los campos.>El tipo '{0}' sin administrar solo es v√°lido para los campos.TUna expresi√≥n lambda de √°rbol de expresi√≥n no puede contener un grupo de m√©todosVEl tipo '{1}' ya define un miembro denominado '{0}' con los mismos tipos de par√°metro+Inicializaci√≥n del miembro '{0}' duplicadaJNo se puede inicializar el miembro '{0}'. No es un campo ni una propiedad.P'{0}': los nombres de los miembros no pueden coincidir con sus tipos envolventes/El m√©todo debe tener un tipo de valor devueltoWEl tipo '{1}' reserva ya un miembro denominado '{0}' con los mismos tipos de par√°metroFSe encontr√≥ un marcador de conflicto de fusi√≥n mediante combinaci√≥nFEl nombre '{0}' supera la longitud m√°xima permitida en los metadatos.0Las referencias de metadatos no son compatibles.INinguna sobrecarga correspondiente a '{0}' coincide con el delegado '{1}'UNinguna sobrecarga correspondiente a "{0}" coincide con el puntero de funci√≥n "{1}".mNo se puede convertir el grupo de m√©todos '{0}' en el tipo no delegado '{1}'. ¬øIntent√≥ invocar el m√©todo?BNo se puede establecer una referencia a una variable de tipo '{0}'ñEl m√©todo '{0}' no puede implementar el descriptor de acceso de la interfaz '{1}' para el tipo '{2}'. Use una implementaci√≥n de interfaz expl√≠cita.Se espera un nombre de m√©todo[El tipo de valor devuelto de un puntero de m√©todo, delegado o funci√≥n no puede ser "{0}".zLas ramas de un operador condicional ref no pueden hacer referencia a variables con √°mbitos de declaraci√≥n incompatiblesZPalabra clave \"record\" inesperada. ¬øQuer√≠a decir \"record struct\" o \"record class\"?dLos patrones de segmento solo se pueden utilizar una vez directamente dentro de un patr√≥n de lista.\No se puede convertir el grupo de m√©todos en puntero de funci√≥n (¬øfalta un operador "&"?)Falta un argumentoYLa creaci√≥n de matriz debe disponer de un tama√±o de matriz o un inicializador de matrizáNo se encuentra la clase contenedora '{0}' de la coclase administrada para la interfaz '{1}' (¬øfalta alguna referencia de ensamblado?)>La opci√≥n /pdb requiere que se use tambi√©n la opci√≥n /debugôNo se encontr√≥ un m√©todo de extensi√≥n o instancia "Deconstruct" adecuado para el tipo "{0}", con {1} par√°metros out y un tipo de valor devuelto void.LError de sintaxis de l√≠nea de comandos: falta el GUID para la opci√≥n '{1}'iA la interfaz de origen '{0}' le falta el m√©todo '{1}', que es necesario para incrustar el evento '{2}'.'Falta la referencia al netmodule '{0}'._Se esperaba un nombre de archivo entre comillas, un comentario de una l√≠nea o un fin de l√≠nealFalta el modificador parcial en la declaraci√≥n de tipo '{0}'; existe otra declaraci√≥n parcial de este tipoFalta un patr√≥n.5Falta el miembro '{0}.{1}' que requiere el compiladorcLa interfaz '{0}' tiene una interfaz de origen no v√°lida necesaria para incrustar el evento '{1}'.w"{0}": el campo de instancia en tipos marcados con StructLayout(LayoutKind.Explicit) debe tener un atributo FieldOffsetVLa referencia al tipo '{0}' confirma que est√° definida en '{1}', pero no se encontr√≥ëLa referencia al tipo '{0}' confirma que est√° definida en este ensamblado, pero no lo est√° ni en el c√≥digo fuente ni en los m√≥dulos agregadosr'{0}' no puede implementar '{1}' porque '{2}' es un evento de Windows Runtime y '{3}' es un evento normal de .NET.'No se pudo emitir el m√≥dulo "{0}": {1}LNo se puede atribuir el inicializador de m√≥dulo con "UnmanagedCallersOnly".oEl m√©todo inicializador de m√≥dulos "{0}" no debe ser gen√©rico y no debe estar incluido en un tipo gen√©rico.WEl m√©todo inicializador de m√≥dulos "{0}" debe estar accesible en el nivel de m√≥dulo.FUn inicializador de m√≥dulos debe ser un m√©todo de miembro ordinario.pEl m√©todo inicializador de m√≥dulos "{0}" debe ser est√°tico, no debe tener par√°metros y debe devolver "void".xEl miembro de interfaz "{0}" no tiene una implementaci√≥n m√°s espec√≠fica. Ni "{1}" ni "{2}" son los m√°s espec√≠ficos.XNo se puede usar m√°s de un tipo en una instrucci√≥n for, using, fixed o de declaraci√≥nhNo es posible que un mismo directorio ("{0}") contenga varios archivos de configuraci√≥n del analizador.ÑEl programa tiene m√°s de un punto de entrada definido. Compile con /main para especificar el tipo que contiene el punto de entrada.KEl atributo [EnumeratorCancellation] no se puede usar en varios par√°metrosgEl archivo de origen solo puede contener una declaraci√≥n de espacio de nombres con √°mbito de archivo.ÁUna instrucci√≥n foreach asincr√≥nica no puede funcionar en variables de tipo ‚Äú{0}‚Äù porque implementa varias creaciones de instancias de ‚Äú{1}‚Äù; pruebe a convertirla en una creaci√≥n de una instancia de interfaz espec√≠fica.œLa instrucci√≥n foreach no puede funcionar en variables de tipo '{0}' porque implementa varias creaciones de instancias de "{1}"; intente convertirla en una creaci√≥n de una instancia de interfaz espec√≠ficaQSolo una declaraci√≥n parcial de un registro puede tener una lista de par√°metros;Un bucle foreach debe declarar sus variables de iteraci√≥n.ÅPara que '{0}' sea aplicable como operador de cortocircuito, su tipo declarativo '{1}' debe definir un operador true y otro falseYLas devoluciones por valor solo se pueden usar en m√©todos que devuelven datos por valor.cLas devoluciones por referencia solo se pueden usar en m√©todos que devuelven datos por referencia.xEl par√°metro '{0}' solo puede tener una comprobaci√≥n nula de signo de exclamaci√≥n en los m√©todos de implementaci√≥n.MNo se pueden especificar a la vez las opciones de compilaci√≥n '{0}' y '{1}'./El nombre '{0}' no existe en el contexto actual`El nombre '{0}' no existe en el contexto actual (¬øfalta alguna referencia al ensamblado '{1}'?)/Se esperaba un argumento de atributo con nombreKUn acceso de matriz no puede tener un especificador de argumento con nombre‚Las especificaciones de argumento con nombre deben aparecer despu√©s de haber especificado todos los argumentos fijos. Use la versi√≥n {0} del lenguaje, o una posterior, para permitir argumentos con nombre que no sean finales.ìLas especificaciones de argumento con nombre deben aparecer despu√©s de haber especificado todos los argumentos fijos en una invocaci√≥n din√°mica.qEl argumento con nombre '{0}' especifica un par√°metro para el que ya se ha proporcionado un argumento posicionalULos grupos de m√©todos de extensi√≥n como argumento de 'nameof' no est√°n permitidos.YLos par√°metros de tipo no se permiten en un grupo de m√©todo como argumento de "nameof".CNo se puede declarar un espacio de nombres en el c√≥digo del scriptcUn espacio de nombres no puede contener directamente miembros como campos, m√©todos o instrucciones4No se puede crear una matriz con un tama√±o negativo7No se puede utilizar un tama√±o negativo con stackallocWEl nombre de archivo '{0}' almacenado en '{1}' debe coincidir con su nombre de archivo.kEl m√≥dulo '{0}' ya est√° definido en este ensamblado. Cada m√≥dulo debe tener un nombre de archivo √∫nico.CLa restricci√≥n new() debe ser la √∫ltima restricci√≥n especificadaLLa restricci√≥n "new()" no se puede utilizar con la restricci√≥n "unmanaged"ILa restricci√≥n 'new()' no se puede utilizar con la restricci√≥n 'struct'aEl tipo de interoperabilidad '{0}' no se puede incrustar. En su lugar, use la interfaz aplicable.ú'{2}' debe ser un tipo no abstracto con un constructor p√∫blico sin par√°metros para poder usarlo como par√°metro '{1}' en el tipo o m√©todo gen√©rico '{0}'V'{0}': no se pueden proporcionar argumentos al crear una instancia de un tipo variable:"{0}" es un nuevo miembro virtual en el tipo "{1}" sellado^'"new" no se puede usar con un tipo de tupla. Use una expresi√≥n literal de tupla en su lugar.Nueva l√≠nea en constanteÅNo se admiten l√≠neas nuevas dentro de una cadena interpolada no textual en C# {0}. Utilice la versi√≥n de idioma {1} o superior.RNo se puede usar una directiva de uso de versi√≥n est√°tica para declarar un alias/Clase base requerida para una referencia 'base'DNo hay ning√∫n bucle envolvente desde el que interrumpir o continuarïNo se encuentra el tipo de interoperabilidad que coincide con el tipo de interoperabilidad incrustado '{0}'. ¬øFalta alguna referencia de ensamblado?.El tipo '{0}' no tiene constructores definidosµ"{0}": el tipo usado en una instrucci√≥n using asincr√≥nica debe poder convertirse de forma impl√≠cita en "System.IAsyncDisposable" o implementar un m√©todo "DisposeAsync" adecuado.Ê"{0}": el tipo usado en una instrucci√≥n using asincr√≥nica debe poder convertirse de forma impl√≠cita en "System.IAsyncDisposable" o implementar un m√©todo "DisposeAsync" adecuado. ¬øQuiso decir "using" en lugar de "await using"?n"{0}": el tipo usado en una instrucci√≥n using debe poder convertirse impl√≠citamente en "System.IDisposable".ü"{0}": el tipo usado en una instrucci√≥n using debe poder convertirse impl√≠citamente en "System.IDisposable". ¬øQuiso decir "await using" en lugar de "using"?ÉEl atributo CallerArgumentExpressionAttribute no se puede aplicar porque no hay conversiones est√°ndar del tipo "{0}" al tipo "{1}"mCallerFilePathAttribute no se puede aplicar porque no hay conversiones est√°ndar del tipo '{0}' al tipo '{1}'oCallerLineNumberAttribute no se puede aplicar porque no hay conversiones est√°ndar del tipo '{0}' al tipo '{1}'oCallerMemberNameAttribute no se puede aplicar porque no hay conversiones est√°ndar del tipo '{0}' al tipo '{1}'yUn valor de tipo '{0}' no se puede usar como par√°metro predeterminado porque no hay conversiones est√°ndar al tipo '{1}'ôUn valor de tipo '{0}' no se puede usar como par√°metro predeterminado para el par√°metro '{1}' que acepta valores NULL porque '{0}' no es un tipo simplePNo se encontr√≥ ning√∫n constructor de copia accesible en el tipo de base "{0}".]No se ha dado ning√∫n argumento que corresponda al par√°metro formal requerido '{0}' de '{1}'fLa palabra clave \"delegate\" no se puede usar como restricci√≥n. ¬øQuer√≠a decir \"System.Delegate\"?»La llamada al m√©todo '{0}' debe enviarse de forma din√°mica, pero no se puede porque forma parte de una expresi√≥n de acceso base. Puede convertir los argumentos din√°micos o eliminar el acceso base.ÆLa llamada de constructor debe enviarse de forma din√°mica, pero no se puede porque forma parte de un inicializador de constructor. Puede convertir los argumentos din√°micos.√El acceso de indizador debe enviarse de forma din√°mica, pero no se puede porque forma parte de una expresi√≥n de acceso base. Puede convertir los argumentos din√°micos o eliminar el acceso base.ZEl programa no contiene ning√∫n m√©todo 'Main' est√°tico adecuado para un punto de entradafLa palabra clave \"enum\" no se puede usar como restricci√≥n. ¬øQuer√≠a decir \"struct, System.Enum\"?âNo se puede convertir el tipo '{0}' en '{1}' mediante una conversi√≥n de referencia, boxing, unboxing, de ajuste del texto o de tipo NULL,No se puede convertir el tipo '{0}' en '{1}'7Falta la especificaci√≥n de archivo de la opci√≥n '{0}'Z'{0}': no se puede invalidar porque '{1}' no tiene un descriptor de acceso get invalidable<No se puede convertir impl√≠citamente el tipo '{0}' en '{1}'äNo se puede convertir impl√≠citamente el tipo '{0}' en '{1}'. Ya existe una conversi√≥n expl√≠cita (compruebe si le falta una conversi√≥n)◊La expresi√≥n condicional no es v√°lida en la versi√≥n de lenguaje {0}porque no se encontr√≥ un tipo com√∫n entre "{1}" y "{2}". Para usar una conversi√≥n con tipo de destino, actualice a la versi√≥n {3} o superior.4"{0}" no tiene un m√©todo "Main" est√°tico adecuado.GNo se puede especificar /main si se compila un m√≥dulo o una biblioteca-No se encontr√≥ el archivo de metadatos '{0}'XNo se pueden colocar modificadores en declaraciones de descriptores de acceso de eventos?La clase '{0}' no puede tener varias clases base: '{1}' y '{2}'óLos elementos definidos en un espacio de nombres no se pueden declarar expl√≠citamente como private, protected, protected internal o private protected.:No se pueden compilar m√≥dulos al usar /refout o /refonly.HNo se puede crear una instancia de la interfaz o el tipo abstracto "{0}"`No se puede crear una instancia del tipo de variable '{0}' porque no tiene la restricci√≥n new().No se pudo determinar el directorio de salida.nNo se pueden incrustar tipos de interoperabilidad desde el ensamblado '{0}' porque no tiene el atributo '{1}'.vNo se pueden incrustar tipos de interoperabilidad desde el ensamblado '{0}' porque le falta el atributo '{1}' o '{2}'.çEl tipo '{0}' no se puede incrustar porque es un tipo anidado. Puede establecer la propiedad 'Incrustar tipos de interoperabilidad' en false.!No use refout si utiliza refonly.Z'{0}': no se puede invalidar porque '{1}' no tiene un descriptor de acceso set invalidable0No se pudo abrir el archivo de origen '{0}': {1},'{0}' no contiene una definici√≥n para '{1}'«"{0}" no contiene una definici√≥n para "{1}" ni un m√©todo de extensi√≥n accesible "{1}" que acepte un primer argumento del tipo "{0}" (¬øfalta alguna directiva using o una referencia de ensamblado?)º'{0}' no contiene una definici√≥n para '{1}' y no se encontr√≥ ning√∫n m√©todo de extensi√≥n '{1}' que acepte un primer argumento de tipo '{0}' (¬øfalta alguna directiva using para '{2}'?)|El tipo '{0}' est√° definido en un ensamblado al que no se hace referencia. Debe agregar una referencia al ensamblado '{1}'.iEl tipo '{0}' est√° definido en un m√≥dulo que todav√≠a no se ha agregado. Debe agregar el m√≥dulo '{1}'.9La palabra clave 'void' no se puede usar en este contexto*El tipo de par√°metro 'void' no es v√°lido:El tipo '{0}' de la lista de interfaces no es una interfaz<No se puede usar como m√©todo el miembro '{0}' no invocable.lEl par√°metro '{0}' es un tipo de valor que no acepta valores NULL y no se puede comprobar con valores NULL..El miembro de registro "{0}" debe ser privado.2El miembro de registro "{0}" debe estar protegido./El miembro de registro "{0}" debe ser p√∫blico.;El constructor de struct sin par√°metros debe ser "public".GUn punto de entrada de devoluci√≥n void o int no puede ser asincr√≥nico"'{0}' no es una clase de atributos6La expresi√≥n que se asigne a '{0}' debe ser constante•La interpolaci√≥n debe terminar con el mismo n√∫mero de corchetes de cierre que el n√∫mero de caracteres \"$\" con los que comenz√≥ el literal de cadena sin formato.BNo hay comillas suficientes para el literal de cadena sin formato.p"{0}" no es un m√©todo de instancia, el receptor no puede ser un argumento de controlador de cadena interpolada.x'{0}' es de tipo '{1}'. Un campo const de un tipo de referencia que no sea de cadena solo se puede inicializar con NULL.é'{0}' es de tipo '{1}'. Un valor de par√°metro predeterminado de un tipo de referencia que no sea de cadena solo se puede inicializar con NULLT"{0}" debe permitir la invalidaci√≥n porque el registro contenedor no est√° sellado.DEsta funcionalidad de idioma ('{0}') todav√≠a no est√° implementada.EEl par√°metro \"out\" \"{0}\" no se puede comprobar con valores NULL.ònull no es un nombre de par√°metro v√°lido. Para obtener acceso al receptor de un m√©todo de instancia, use la cadena vac√≠a como nombre del par√°metro.,No se permite utilizar NULL en este contextoaUna expresi√≥n lambda de √°rbol de expresi√≥n no puede contener un operador de propagaci√≥n NULL.,Se esperaba "enable", "disable" o "restore".ESe esperaban "advertencias", "anotaciones" o el final de la directiva^Valor "{0}" no v√°lido: "{1}" para C# {2}. Use la versi√≥n del lenguaje "{3}" o una posterior.æDebe saberse si un par√°metro de tipo que acepta valores NULL es un tipo de valor o un tipo de referencia que no acepta valores NULL, a menos que se use la versi√≥n de lenguaje "{0}" o una posterior. Considere la posibilidad de cambiar la versi√≥n de lenguaje o de agregar "class", "struct" o una restricci√≥n de tipo.A'{0}' no tiene clase base y no puede llamar a un constructor baseOLa clase System.Object no puede tener una clase base o implementar una interfazrNo se pueden aplicar expresiones de inicializador de objeto y colecci√≥n a una expresi√≥n de creaci√≥n de delegado{No se puede obtener acceso al miembro '{0}' con una referencia de instancia; calif√≠quelo con un nombre de tipo en su lugar[Se requiere una referencia de objeto para el campo, m√©todo o propiedad '{0}' no est√°ticos?No se permite omitir el argumento de tipo en el contexto actual≤Una opci√≥n /reference que declara un alias externo solo puede tener un nombre de archivo. Para especificar varios alias o nombres de archivo, utilice varias opciones /reference.4Solo los tipos de clase pueden contener destructoresAEl tipo de valor devuelto del operador True o False debe ser bool2Se encontr√≥ el fin del archivo y se esperaba '*/',Error al abrir el archivo de respuesta '{0}'6User-defined operator '{0}' cannot be declared checkedHLos operadores definidos por el usuario no pueden devolver un valor voidS'{0}': las clases est√°ticas no pueden contener operadores definidos por el usuarioOEl operador '{0}' requiere que tambi√©n se defina un operador coincidente '{1}'NEl operador '{0}' definido por el usuario debe declararse est√°tico y p√∫blico6La opci√≥n '{0}' debe ser una ruta de acceso absoluta.0Un par√°metro In no puede tener un atributo Out.eNo se puede especificar el atributo Out en un par√°metro ref sin especificar tambi√©n el atributo In.4Una variable out no se puede declarar como ref localBLos resultados sin origen deben tener la opci√≥n /out especificada9No se puede escribir en el archivo de salida '{0}': '{1}'v"{0}" no puede definir un elemento {1} sobrecargado que difiere solo en los modificadores de par√°metro "{2}" y "{3}".ÄEl m√©todo "{0}" especifica una restricci√≥n "default" para el par√°metro de tipo "{1}", pero el par√°metro de tipo "{2}" correspondiente del m√©todo "{3}" invalidado o implementado expl√≠citamente se restringe a un tipo de referencia o a un tipo de valor.DNo invalide object.Finalize. En su lugar, proporcione un destructor.>'{0}': no se encontr√≥ ning√∫n miembro adecuado para invalidarLUn miembro '{0}' marcado como override no se puede marcar como new o virtualÊEl m√©todo "{0}" especifica una restricci√≥n "class" para el par√°metro de tipo "{1}", pero el par√°metro de tipo correspondiente "{2}" de los m√©todos invalidados o implementados expl√≠citamente "{3}" no es un tipo de referencia.˙El m√©todo "{0}" especifica una restricci√≥n "struct" para el par√°metro de tipo "{1}", pero el par√°metro de tipo correspondiente "{2}" de los m√©todos invalidados o implementados expl√≠citamente "{3}" no es un tipo de valor que acepta valores NULL.ÂLas restricciones para m√©todos de invalidaci√≥n y de implementaci√≥n de interfaz expl√≠cita se heredan del m√©todo base; por tanto, no se pueden especificar directamente, excepto para una restricci√≥n de tipo "class" o "struct".-Se esperaba un operador binario sobrecargable%Se esperaba un operador sobrecargable,Se esperaba un operador unario sobrecargableoNo se puede definir o anular la definici√≥n de s√≠mbolos de preprocesador despu√©s del primer token del archivo*Se esperaba una directiva de preprocesador<No se puede usar #load despu√©s del primer token del archivo9No se puede usar #r despu√©s del primer token del archivo=El par√°metro tiene varios valores predeterminados distintos._Es necesario asignar el par√°metro '{0}' out antes de que el control abandone el m√©todo actual>'{0}': los tipos est√°ticos no se pueden usar como par√°metros@Par√°metro no v√°lido para el tipo no administrado especificado.3El par√°metro params no se puede declarar como {0}.XUn par√°metro params debe ser el √∫ltimo par√°metro de una lista de par√°metros formales7El par√°metro params debe ser una matriz unidimensional]Ambas declaraciones de m√©todo parcial deben tener modificadores de accesibilidad id√©nticos.âAmbas declaraciones de m√©todo parcial deben tener combinaciones id√©nticas de los modificadores "virtual", "override", "sealed" y "new".qAmbas declaraciones de m√©todo parcial deben ser m√©todos de extensi√≥n; si no, no puede serlo ninguna de las doséEn los √°rboles de expresi√≥n no se pueden usar m√©todos parciales con solo una declaraci√≥n de definici√≥n ni m√©todos condicionales quitadossLas declaraciones de m√©todos parciales de "{0}" tienen restricciones incoherentes para el par√°metro de tipo "{1}"kAmbas declaraciones de m√©todo parcial, '{0}' y '{1}', deben usar los mismos nombres de elementos de tupla.;Un m√©todo parcial no puede tener el modificador "abstract"uNo se encontr√≥ ninguna declaraci√≥n de definici√≥n para la declaraci√≥n de implementaci√≥n del m√©todo parcial '{0}'NUn m√©todo parcial no puede implementar expl√≠citamente un m√©todo de interfaz<Un m√©todo parcial debe declararse dentro de un tipo parcialIUn m√©todo parcial no puede tener varias declaraciones de implementaci√≥nEUn m√©todo parcial no puede tener varias declaraciones de definici√≥ngAmbas declaraciones de m√©todos parciales deben usar un par√°metro params; si no, ninguna podr√° usarlopAmbas declaraciones de m√©todos parciales deben ser de solo lectura o ninguna de ellas puede ser de solo lectura_Las declaraciones de m√©todo parcial deben tener valores devueltos de referencia que coincidan.SAmbas declaraciones de m√©todo parcial deben tener el mismo tipo de valor devuelto.bAmbas declaraciones de m√©todo parcial deben ser est√°ticas o ninguna de ellas puede ser est√°ticayNo se puede crear un delegado a partir del m√©todo '{0}' porque es un m√©todo parcial sin declaraci√≥n de implementaci√≥neAmbas declaraciones de m√©todos parciales deben ser no seguras o ninguna de ellas puede ser no seguraoEl m√©todo parcial "{0}" debe tener un elemento de implementaci√≥n porque tiene modificadores de accesibilidad.ëEl m√©todo parcial "{0}" debe tener modificadores de accesibilidad porque tiene un modificador "virtual", "override", "sealed", "new" o "extern".rEl m√©todo parcial "{0}" debe tener modificadores de accesibilidad porque tiene un tipo de valor devuelto no nulo.bEl m√©todo parcial "{0}" debe tener modificadores de accesibilidad porque tiene par√°metros "out".ôEl modificador "partial" solo puede aparecer inmediatamente antes de "class", "record", "struct", "interface" o de un tipo de valor devuelto del m√©todo.bLas declaraciones parciales de '{0}' tienen modificadores de accesibilidad que entran en conflictoPLas declaraciones parciales de '{0}' no deben especificar clases base diferentesûLas declaraciones parciales de '{0}' deben ser todas las clases, todas las clases de registro, todos los registros, todos los registros o todas las interfacesgLas declaraciones parciales de '{0}' tienen restricciones incoherentes para el par√°metro de tipo '{1}'lLas declaraciones parciales de '{0}' deben tener los mismos nombres de par√°metros de tipo en el mismo ordenáLas declaraciones parciales de '{0}' deben tener los mismos nombres de par√°metro de tipo y modificadores de varianza en el mismo orden5No se puede utilizar el tipo "dynamic" en un patr√≥n.hNo se puede usar el tipo "{0}?" que acepta valores NULL en un patr√≥n; utilice el tipo "{0}" subyacente.^A string 'null' constant is not supported as a pattern for '{0}'. Use an empty string instead.éUn patr√≥n de tipo "{1}" no puede controlar una expresi√≥n de tipo "{0}" en C# {2}. Use la versi√≥n {3} del lenguaje o una versi√≥n posterior.IUn patr√≥n de tipo "{1}" no puede controlar una expresi√≥n de tipo "{0}"./Error al escribir en el archivo de salida: {0}.pError al leer el archivo '{0}' especificado para el argumento con nombre '{1}' del atributo PermissionSet: '{2}'ÅNo se pudo resolver la ruta de acceso de archivo '{0}' especificada para el argumento con nombre '{1}' del atributo PermissionSet2Ni 'is' ni 'as' son v√°lidos como tipos de puntero@No se permite la coincidencia de patrones para tipos de puntero.NEl cuerpo de un m√©todo async-iterator debe contener una instrucci√≥n "yield".™El cuerpo de un m√©todo async-iterator debe contener una instrucci√≥n "yield". Considere quitar "async" de la declaraci√≥n del m√©todo o agregar una instrucci√≥n "yield".DPara convertir un valor negativo, el valor debe ir entre par√©ntesisGEl miembro '{0}' no se encontr√≥ en el tipo '{1}' del ensamblado '{2}'.8El tipo predefinido '{0}' no est√° definido ni importadofEl tipo "{0}" predefinido se declara en varios ensamblados a los que se hace referencia: "{1}" y "{2}"6El tipo '{0}' predefinido debe ser un elemento struct.8El tipo predefinido '{0}' no est√° definido ni importadoSEl valor '{0}' de SecurityAction no es v√°lido para el atributo PrincipalPermissionQ'{0}': las propiedades abstractas no pueden tener descriptores de acceso privados?'{0}': la propiedad o el indizador no pueden tener el tipo voidnLa propiedad o el indizador '{0}' no se puede usar en este contexto porque carece del descriptor de acceso getÉEl subpatr√≥n de una propiedad requiere una referencia a la propiedad o al campo que debe coincidir; por ejemplo, "{{ Name: {0} }}"Q'{0}': la propiedad o el indizador deben tener, al menos, un descriptor de accesoC'{0}': las clases est√°ticas no pueden contener miembros protegidos6'{0}': nuevo miembro protegido declarado en estructura/El operador * o -> se debe aplicar a un puntero1Un puntero solo puede estar indizado por un valorJError al firmar la salida con una clave p√∫blica del contenedor '{0}': {1}GError al firmar la salida con una clave p√∫blica del archivo '{0}': {1}fSe especific√≥ la firma p√∫blica y se requiere una clave p√∫blica, pero no se ha especificado ninguna./No se admite la firma p√∫blica para netmodules.-La variable de rango '{0}' ya se ha declaradoàEl nombre '{0}' no est√° dentro del √°mbito en el lado derecho de 'equals'. Puede cambiar las expresiones en cualquier lado de 'equals'.uSe encontraron varias implementaciones del patr√≥n de consulta para el tipo de origen '{0}'. Llamada ambigua a '{1}'.tNo se encontr√≥ ninguna implementaci√≥n del patr√≥n de consulta para el tipo de origen '{0}'. No se encontr√≥ '{1}'.¡No se encontr√≥ ninguna implementaci√≥n del patr√≥n de consulta para el tipo de origen '{0}'. No se encontr√≥ '{1}'. Puede especificar de forma expl√≠cita el tipo de la variable de rango '{2}'.”No se encontr√≥ ninguna implementaci√≥n del patr√≥n de consulta para el tipo de origen "{0}". No se encontr√≥ "{1}". ¬øFalta alguna referencia de ensamblado necesaria o alguna directiva using para "System.Linq"?FNo se puede pasar la variable de rango '{0}' como par√°metro out o refèEl nombre '{0}' no est√° dentro del √°mbito en el lado izquierdo de 'equals'. Puede intercambiar las expresiones en cualquier lado de 'equals'./No se puede asignar {0} a una variable de rangoTLa variable de rango '{0}' entra en conflicto con una declaraci√≥n anterior de '{0}'BLa variable de rango '{0}' no se puede asignar: es de solo lectura^La variable de rango '{0}' no puede tener el mismo nombre que un par√°metro de tipo de m√©todo}El tipo de la expresi√≥n de la cl√°usula {0} es incorrecto. No se pudo realizar la inferencia de tipos en la llamada a '{1}'.ÜEl tipo de una de las expresiones de la cl√°usula {0} es incorrecto. No se pudo realizar la inferencia de tipos en la llamada a '{1}'.ŒNo se permiten expresiones de tipo '{0}' en una cl√°usula from siguiente incluida en una expresi√≥n de consulta con el tipo de origen '{1}'. No se pudo realizar la inferencia de tipos en la llamada a '{2}'.LEl delimitador literal de cadena sin formato debe estar en su propia l√≠nea.mLos literales de cadena sin formato de varias l√≠neas solo se permiten en las cadenas interpoladas textuales.fLos literales de cadena sin formato de varias l√≠neas deben contener al menos una l√≠nea de contenido.RNo se permiten literales de cadena sin formato en las directivas de preprocesador.Se esperaba }¥El tipo "{0}" no se puede insertar porque tiene una reabstracci√≥n de un miembro de la interfaz base. Puede establecer la propiedad "Incrustar tipos de interoperabilidad" en false.ä"{0}": "readonly" solo se puede usar en los descriptores de acceso si la propiedad o el indexador tienen un descriptor de acceso get y setåLos miembros del campo de solo lectura '{0}' de tipo '{1}' no se pueden asignar con un inicializador de objeto porque es de un tipo de valorTEl constructor principal est√° en conflicto con el constructor de copia sintetizado.ªUn constructor declarado en un 'record struct' con lista de par√°metros debe tener un inicializador 'this' que llame al constructor principal o a un constructor declarado expl√≠citamente.3El constructor '{0}' no se puede llamar a s√≠ mismoyEl tipo de '{0}' no se puede inferir porque su inicializador hace referencia, directa o indirectamente, a la definici√≥n.mNo se puede asignar referencia "{1}" a "{0}" porque "{1}" tiene un √°mbito de escape m√°s limitado que "{0}".ELa expresi√≥n debe ser de tipo '{0}' porque se asigna por referencia.U'No se puede usar "await" en una expresi√≥n que contiene un operador condicional ref.TLa expresi√≥n debe ser de tipo "{0}" para que coincida con el valor ref alternativo.eAmbos valores de operador condicional deben ser valores ref o ninguno de ellos debe ser un valor ref.yEl tipo '{2}' debe ser un tipo de referencia para poder usarlo como par√°metro '{1}' en el tipo o m√©todo gen√©rico '{0}'ÄEl primer par√°metro de un m√©todo de extensi√≥n "ref" "{0}" debe ser un tipo de valor o un tipo gen√©rico restringido a struct.cLa parte izquierda de una asignaci√≥n de referencias debe ser una referencia local o un par√°metro.3Un valor out o ref debe ser una variable asignable.>Un par√°metro ref o out no puede tener un valor predeterminadoHUna propiedad o un indizador no se puede pasar como par√°metro out o refZLas propiedades que devuelven datos por referencia no pueden tener descriptores de acceso.[Las propiedades que devuelven datos por referencia deben tener un descriptor de acceso get.[No se puede usar un campo de solo lectura como valor out o ref (excepto en un constructor).nNo se pueden usar miembros del campo de solo lectura '{0}' como valores out o ref (excepto en un constructor).FNo se puede usar '{0}' como valor out o ref porque es de solo lectura.LNo se pueden usar campos de '{0}' como valores out o ref porque es un '{1}'.?No se puede usar '{0}' como valor out o ref porque es un '{1}'.PNo se puede usar {0} "{1}" como valor out o ref porque es una variable readonly.aLos miembros de {0} "{1}" no se pueden usar como valor out o ref porque es una variable readonly.oNo se puede usar un campo est√°tico de solo lectura como valor out o ref (excepto en un constructor est√°tico).ÄNo se pueden usar campos del campo est√°tico de solo lectura '{0}' como valores out o ref (excepto en un constructor est√°tico).UNo se puede devolver por referencia la variable local '{0}' porque no es de tipo ref.vNo se puede devolver por referencia un miembro de la variable local '{0}' porque no es una variable local de tipo ref.eNo se puede usar una expresi√≥n en este contexto porque no se puede pasar ni devolver por referencia.^La expresi√≥n return debe ser de tipo '{0}' porque este m√©todo devuelve datos por referencia.uNo se puede devolver '{0}' por referencia porque se inicializ√≥ con un valor que no se puede devolver por referencia.ÉNo se puede devolver por referencia un miembro de '{0}' porque se inicializ√≥ con un valor que no se puede devolver por referencia.VNo se pude devolver por referencia un par√°metro '{0}' porque no es de tipo ref o out.jNo se puede devolver un miembro del par√°metro "{0}" por referencia, porque no es un par√°metro out o ref.?No se puede devolver por referencia la variable de rango '{0}'.FNo se puede devolver un campo de solo lectura por referencia grabable.[Los miembros del campo de solo lectura "{0}" no se pueden devolver por referencia grabable.D'{0}' no se puede devolver por referencia porque es de solo lectura.LLos campos de '{0}' no se pueden devolver por referencia porque es un '{1}'.='{0}' no se puede devolver por referencia porque es un '{1}'.WNo se puede devolver {0} "{1}" por referencia grabable porque es una variable readonly.hLos miembros de {0} "{1}" no se pueden devolver por referencia grabable porque es una variable readonly.PNo se puede devolver un campo est√°tico de solo lectura por referencia grabable.cLos campos del campo est√°tico de solo lectura "{0}" no se pueden devolver por referencia grabable._Los miembros de struct no pueden devolver 'this' ni otros miembros de instancia por referencia.+No se puede devolver "this" por referencia.r'No se puede usar 'await' en una expresi√≥n que contiene una llamada a '{0}' porque devuelve datos por referencia.çUn lambda de √°rbol de expresi√≥n no puede contener una llamada a un m√©todo, una propiedad o un indexador que devuelva datos por referencia.<"{0}": las estructuras ref no pueden implementar interfaces.f'{0}': no se puede especificar a la vez una clase de restricci√≥n y la restricci√≥n 'class' o 'struct' #r solo se puede usar en scriptsLNo se pueden usar patrones relacionales para un valor NaN de punto flotante.kEl nombre de ensamblado '{0}' est√° reservado y no se puede usar como referencia en una sesi√≥n interactiva@El nombre de enumerador '{0}' est√° reservado y no se puede usarúLos recursos y m√≥dulos vinculados deben tener un nombre de archivo √∫nico. El nombre de archivo '{0}' se ha especificado m√°s de una vez en este ensambladoCEl identificador de recurso '{0}' ya se ha usado en este ensambladoaComo '{0}' devuelve void, una palabra clave return no debe ir seguida de una expresi√≥n de objeto\Una funci√≥n an√≥nima convertida en un delegado que devuelve void no puede devolver un valor;Se requiere un objeto cuyo tipo se pueda convertir en '{0}'A'{0}': no todas las rutas de acceso de c√≥digo devuelven un valorùNo se puede devolver un valor a partir de un iterador. Utilice la instrucci√≥n yield return para devolver un valor o yield break para terminar la iteraci√≥n.JNo se puede modificar el valor devuelto de '{0}' porque no es una variableM'{0}': los tipos est√°ticos no se pueden usar como tipos de valores devueltos≠"{0}": el entorno de ejecuci√≥n de destino no admite los tipos de covariante en las invalidaciones. El tipo debe ser "{2}" para que coincida con el miembro "{1}" invalidado.‘"{0}": el entorno de ejecuci√≥n de destino no admite los tipos de valores devueltos de covariante en las invalidaciones. El tipo de valor devuelto debe ser "{2}" para que coincida con el miembro "{1}" invalidado.[El tiempo de ejecuci√≥n de destino no admite la implementaci√≥n de interfaz predeterminada.¨"{0}" no puede implementar el miembro de interfaz "{1}" en el tipo "{2}" porque el entorno de ejecuci√≥n de destino no admite la implementaci√≥n de interfaz predeterminada.êEl entorno de ejecuci√≥n de destino no admite la accesibilidad protegida, protegida interna o protegida privada para un miembro de una interfaz.ZEl tiempo de ejecuci√≥n de destino no admite miembros abstractos est√°ticos en interfaces.™"{0}" no puede implementar el miembro de interfaz "{1}" en el tipo "{2}" porque el tiempo de ejecuci√≥n de destino no admite miembros abstractos est√°ticos en interfaces.ÜEl entorno de ejecuci√≥n de destino no admite convenciones de llamada predeterminadas de entorno en tiempo de ejecuci√≥n o extensible.(El tipo '{1}' existe en '{0}' y en '{2}'REl espacio de nombres '{1}' de '{0}' est√° en conflicto con el tipo '{3}' de '{2}'REl tipo '{1}' de '{0}' est√° en conflicto con el espacio de nombres '{3}' de '{2}'L"{0}" no puede estar sellado porque el registro contenedor no est√° sellado.;'{0}' no puede estar sellado porque no es una invalidaci√≥n/"{0}": un tipo no puede ser est√°tico y selladoPEl atributo de seguridad '{0}' tiene un valor '{1}' de SecurityAction no v√°lidohEl valor '{0}' de SecurityAction no es v√°lido para los atributos de seguridad aplicados a un ensambladolEl valor '{0}' de SecurityAction no es v√°lido para los atributos de seguridad aplicados a un tipo o m√©todo≥El valor '{0}' de SecurityAction no es v√°lido en este tipo de declaraci√≥n. Los atributos de seguridad solo son v√°lidos en las declaraciones de ensamblado, de tipo y de m√©todo.SEl primer argumento de un atributo de seguridad debe ser una SecurityAction v√°lidaFEl atributo de seguridad '{0}' no se puede aplicar a un m√©todo Async.äLos m√©todos Async no se permiten en interfaces, clases ni estructuras que tienen el atributo 'SecurityCritical' o 'SecuritySafeCritical'.Se esperaba { o ;Se esperaba { o ; o =>.Se esperaba ;IAl archivo de clave '{0}' le falta la clave privada necesaria para firmar2El miembro del registro "{0}" debe devolver "{1}".dNo se puede especificar /main si hay una unidad de compilaci√≥n con instrucciones de nivel superior.AAl menos una instrucci√≥n de nivel superior no debe estar vac√≠a.No se puede usar la variable local ni la funci√≥n local "{0}" declarada en una instrucci√≥n de nivel superior en este contexto.LSolo una unidad de compilaci√≥n puede tener instrucciones de nivel superior.KEl programa que usa instrucciones de nivel superior debe ser un ejecutable.ΩUn patr√≥n de deconstrucci√≥n de un solo elemento requiere m√°s sintaxis para la desambiguaci√≥n. Se recomienda agregar un designador de descarte "_" despu√©s del par√©ntesis de cierre ")".TEs posible que no se use un comentario de una sola l√≠nea en una cadena interpolada.El nombre del tipo o del espacio de nombres '{0}' no se encontr√≥ (¬øfalta una directiva using o una referencia de ensamblado?)áNo se encontr√≥ el nombre del tipo '{0}'. Este tipo se ha reenviado al ensamblado '{1}'. Puede agregar una referencia a ese ensamblado.d"{0}" no tiene un tama√±o predefinido; por tanto, sizeof solo se puede usar en un contexto no seguro8Las referencias de archivo de origen no son compatibles.8El modificador /sourcelink solo se admite al emitir PDB.ñLa instancia de tipo "{0}" no se puede usar dentro de una funci√≥n anidada, una expresi√≥n de consulta, un bloque iterador ni un m√©todo asincr√≥nico.4La restricci√≥n no puede ser la clase especial '{0}'WLa conversi√≥n de una expresi√≥n stackalloc del tipo "{0}" al tipo "{1}" no es posible.8stackalloc no se puede usar en un bloque catch o finallydUna expresi√≥n lambda con un cuerpo de instrucci√≥n no se puede convertir en un √°rbol de expresi√≥n5El miembro del registro "{0}" no puede ser est√°tico.SUna funci√≥n an√≥nima est√°tica no puede contener una referencia a "this" o "base".IUna funci√≥n an√≥nima est√°tica no puede contener una referencia a "{0}".6'{1}': no se puede derivar de la clase est√°tica '{0}'='{0}': las clases est√°ticas no pueden implementar interfaces9'{0}': un constructor est√°tico no debe tener par√°metros4La constante '{0}' no se puede marcar como est√°ticaI'{0}': no se permiten modificadores de acceso en constructores est√°ticosh'{0}': el constructor est√°tico no puede tener ninguna llamada de constructor 'this' o 'base' expl√≠citaoLa clase est√°tica '{0}' no se puede derivar del tipo '{1}'. Las clases est√°ticas se deben derivar del objeto.PUna funci√≥n local est√°tica no puede contener una referencia a "this" o "base".FUna funci√≥n local est√°tica no puede contener una referencia a "{0}".>El miembro est√°tico "{0}" no se puede marcar como "readonly".VNo se puede asignar la propiedad o campo est√°tico '{0}' en un inicializador de objeto2Un miembro est√°tico no se puede marcar como "{0}"sSe ha especificado el argumento stdin "-", pero la entrada no se ha redirigido desde el flujo de entrada est√°ndar.+La cadena debe comenzar con las comillas: "_Un 'struct' con inicializadores de campo debe incluir un constructor declarado expl√≠citamente.YEl miembro de estructura '{0}' de tipo '{1}' crea un ciclo en el dise√±o de la estructura?El atributo FieldOffset no se permite en campos static ni constqEl atributo FieldOffset solo se puede colocar en miembros de tipos marcados con StructLayout(LayoutKind.Explicit)E'{0}': las estructuras no pueden llamar a constructores de clase base<La subexpresi√≥n no se puede usar en un argumento de nameof.äNo se puede acceder al patr√≥n. Ya se ha administrado mediante un indicador anterior de la expresi√≥n switch o no se pudo hacer coincidir.lNo se puede acceder a switch case. Ya se ha administrado con un caso anterior o no se puede hacer coincidir.8No se encontr√≥ el mejor tipo para la expresi√≥n switch.9La expresi√≥n switch debe ser un valor. Se encontr√≥ {0}.UEl control no puede quedar fuera del modificador de la etiqueta de caso final ('{0}')MEl control no puede pasar expl√≠citamente de una etiqueta case ('{0}') a otra4La expresi√≥n switch aplicable requiere par√©ntesis.QError de sintaxis de l√≠nea de comandos: falta ':<n√∫mero>' para la opci√≥n '{0}'JError de sintaxis de l√≠nea de comandos: falta '{0}' para la opci√≥n '{1}'N'MethodImplOptions.Synchronized' no se puede aplicar a un m√©todo asincr√≥nico$Error de sintaxis, se esperaba '{0}'XSystem.Void no se puede usar en C#; use typeof(void) para obtener el objeto de tipo void¢Como '{0}' es un m√©todo asincr√≥nico que devuelve 'Task', una palabra clave return no debe ir seguida de una expresi√≥n de objeto. ¬øIntent√≥ devolver 'Task<T>'?ãUna expresi√≥n lambda asincr√≥nica convertida en un delegado que devuelve 'Task' no puede devolver un valor. ¬øIntent√≥ devolver 'Task<T>'?ALa palabra clave 'this' no est√° disponible en el contexto actualcLa palabra clave 'this' no es v√°lida en una propiedad, m√©todo o inicializador de campo est√°ticos,Se esperaba la palabra clave 'this' o 'base'ËLos m√©todos an√≥nimos, las expresiones lambda, las expresiones de consulta y las funciones locales incluidos en estructuras no pueden obtener acceso a miembros de instancia de "this". Puede copiar "this" en una variable local fuera del m√©todo an√≥nimo, la expresi√≥n lambda, la expresi√≥n de consulta o la funci√≥n local y usar la variable local en su lugar.4No se permite una expresi√≥n throw en este contexto.^No puede haber cl√°usulas catch despu√©s de la cl√°usula catch general de una instrucci√≥n try-Demasiados caracteres en literal de car√°cterüEl literal de cadena sin formato interpolado no comienza con suficientes caracteres \"$\" para permitir tantos corchetes de cierre consecutivos como contenido.SSolo se permiten 65534 variables locales incluyendo las generadas por el compilador°El literal de cadena sin formato interpolado no comienza con suficientes caracteres \"$\" para permitir tantos corchetes de apertura consecutivos como contenido.ÄEl literal de cadena sin formato no comienza con suficientes comillas para permitir tantas comillas consecutivas como contenido.ïLa longitud combinada de las cadenas de usuario que el programa utiliza supera el l√≠mite permitido. Intente disminuir el uso de literales de cadena.hLas instrucciones de nivel superior deben preceder a las declaraciones de espacio de nombres y de tipos.NLos especificadores de formato no pueden contener espacios en blanco al final.)Secuencia de caracteres "..." inesperada.3Los nombres de elemento de tupla deben ser √∫nicos.9El nombre "{0}" no identifica el elemento de tupla "{1}".ñNo se puede definir una clase o un miembro que utiliza tuplas porque no se encuentra el tipo requerido de compilador '{0}'. ¬øFalta alguna referencia?YNo se permiten nombres de elementos de tupla en el lado izquierdo de una deconstrucci√≥n.§El nombre "{0}" del elemento de tupla se ha deducido. Use la versi√≥n {1} del lenguaje, o una versi√≥n posterior, para acceder a un elemento por el nombre deducido.JEl nombre '{0}' del elemento de tupla solo se permite en la posici√≥n {1}.IEl nombre '{0}' del elemento de tupla no se permite en ninguna posici√≥n.ÀLos tipos de tupla utilizados como operandos de un operador == o != deben tener cardinalidades coincidentes. Pero este operador tiene tipos de tupla de cardinalidad {0} a la izquierda y {1} a la derecha./Una tupla debe contener al menos dos elementos.+'{1}' no define el par√°metro de tipo '{0}'1{1} '{0}' no se puede usar con argumentos de tipoÆLas restricciones "class", "struct", "unmanaged", "notnull" y "default" no se pueden combinar ni duplicar y se deben especificar en primer lugar en la lista de restricciones.Se esperaba un tipofEl m√≥dulo "{0}" del ensamblado "{1}" va a reenviar el tipo "{2}" a varios ensamblados: "{3}" y "{4}".VNo se puede inferir el tipo de variable de desconstrucci√≥n con tipo impl√≠cito '{0}'.FNo se puede inferir el tipo de variable out con tipo impl√≠cito '{0}'.9"{0}" no es un tipo de controlador de cadena interpolada.NEl tipo "{0}" debe ser p√∫blico para poder usarlo como convenci√≥n de llamada. No est√° definido el tipo '{0}'.LLa declaraci√≥n de par√°metros de tipo debe ser un identificador, no un tipo@El nombre de tipo "{0}" est√° reservado para uso del compilador.ôNo se puede convertir NULL en el par√°metro de tipo '{0}' porque podr√≠a ser un tipo de valor que no acepta valores NULL. Use 'default({0})' en su lugar.yLa palabra clave contextual 'var' solo puede aparecer dentro de una declaraci√≥n de variable local o en c√≥digo de script[La palabra clave contextual 'var' no se puede usar en una declaraci√≥n de variable de rangoUEl par√°metro de tipo '{0}' tiene el mismo nombre que el tipo contenedor o el m√©todo\El primer operando de un operador "as" no puede ser un literal de tupla sin un tipo natural.™Auto-implemented property '{0}' must be fully assigned before control is returned to the caller. Consider updating to language version '{1}' to auto-default the property.ìField '{0}' must be fully assigned before control is returned to the caller. Consider updating to language version '{1}' to auto-default the field.>No se puede modificar el resultado de una conversi√≥n unboxingTFalta el delimitador de cierre '}' de la expresi√≥n interpolada que empieza por '{'.OEl car√°cter '{0}' se debe escapar (duplic√°ndose) en las cadenas interpoladas.%Uso inesperado de un nombre con aliasLista de argumentos inesperada.FLos argumentos de tipo no est√°n permitidos en el nombre del operador.Car√°cter '{0}' inesperado%Directiva de preprocesador inesperada%Uso inesperado de un nombre gen√©ricowUn constructor declarado en un registro con una lista de par√°metros debe tener el inicializador de constructor "this".YEl punto y coma despu√©s del bloque de m√©todos o de descriptores de acceso no es v√°lidoToken inesperado '{0}'1Uso inesperado de un nombre gen√©rico sin enlazar`Varianza no v√°lida: el par√°metro de tipo '{1}' debe ser un {3} v√°lido en '{0}'. '{1}' es {2}.ßVarianza no v√°lida: el par√°metro de tipo "{1}" debe ser un elemento {3} v√°lido en "{0}", a menos que se use la versi√≥n de lenguaje "{4}" o posterior. "{1}" es {2}.}'{0}' no puede implementar '{1}' y '{2}' a la vez porque se pueden unificar para algunas sustituciones de par√°metros de tipo7'{0}' no implementa el miembro abstracto heredado '{1}'G'{0}' no implementa el miembro de interfaz '{1}'. '{2}' no es p√∫blico.0'{0}' no implementa el miembro de interfaz '{1}'_"{0}": no se puede especificar a la vez una clase de restricci√≥n y la restricci√≥n "unmanaged"åLos m√©todos con atributos "UnmanagedCallersOnly" no pueden tener par√°metros de tipo gen√©rico y no pueden declararse en un tipo gen√©rico.É"{0}" tiene un atributo "UnmanagedCallersOnly" y no se le puede llamar directamente. Obtenga un puntero de funci√≥n a este m√©todo.ë' {0} ' tiene un atributo ' UnmanagedCallersOnly ' y no se puede convertir en un tipo de delegado. Obtenga un puntero de funci√≥n a este m√©todo.{'UnmanagedCallersOnly' solo se puede aplicar a m√©todos est√°ticos ordinarios no abstractos o funciones locales est√°ticas.∆"{2}" debe ser un tipo de valor que no acepta valores NULL, junto con todos los campos de cualquier nivel de anidamiento, para poder usarlo como par√°metro "{1}" en el tipo o m√©todo gen√©rico "{0}"cUna cl√°usula catch previa ya detecta todas las excepciones de este tipo o de tipo superior ('{0}')[Los m√©todos asincr√≥nicos no pueden tener par√°metros no seguros o tipos de valor devueltoCLos iteradores no pueden tener par√°metros no seguros o tipos yield\Los punteros y los b√∫feres de tama√±o fijo solo se pueden utilizar en un contexto no seguro=El tipo '{0}' no seguro no se puede usar para crear un objeto9El lenguaje no admite la convenci√≥n de llamada de "{0}".ñError en el acceso del miembro de identificador transparente para el campo '{0}' de '{1}'. ¬øLos datos consultados implementan el patr√≥n de consulta?DNo se pueden utilizar patrones de lista para un valor de tipo "{0}".DNo se pueden usar patrones relacionales para un valor de tipo "{0}".GNo se pueden utilizar patrones de segmento para el valor de tipo "{0}".+Literal de cadena sin formato sin terminar.Literal de cadena no terminado*Uso de la variable local no asignada '{0}',Uso del campo '{0}' posiblemente sin asignarnUse of possibly unassigned field '{0}'. Consider updating to language version '{1}' to auto-default the field.(Uso del par√°metro out sin asignar '{0}'QUso de una propiedad implementada autom√°ticamente posiblemente sin asignar '{0}'ÖUse of possibly unassigned auto-implemented property '{0}'. Consider updating to language version '{1}' to auto-default the property.†The 'this' object cannot be used before all of its fields have been assigned. Consider updating to language version '{0}' to auto-default the unassigned fields.áUna cl√°usula using debe preceder al resto de elementos definidos en el espacio de nombres, excepto las declaraciones de alias externosfUna variable using no se puede usar directamente en una secci√≥n switch (considere el uso de llaves). ∞Una expresi√≥n switch o etiqueta de caso debe ser del tipo bool, char, string, integral, enum o del correspondiente tipo que acepte valores NULL en C# 6 y versiones anteriores.èEl tipo '{2}' debe ser un tipo de valor que no acepte valores NULL para poder usarlo como par√°metro '{1}' en el tipo o m√©todo gen√©rico '{0}'ZNo se puede convertir NULL en '{0}' porque es un tipo de valor que no acepta valores NULL.'Error de sintaxis; se esperaba un valorkLos m√©todos de extensi√≥n '{0}' definidos en el tipo de valor '{1}' no se pueden usar para crear delegadosÇLos miembros de la propiedad '{0}' de tipo '{1}' no se pueden asignar con un inicializador de objeto porque es de un tipo de valorcUna expresi√≥n lambda de √°rbol de expresi√≥n no puede contener un m√©todo con argumentos variables9No se puede declarar una variable de tipo est√°tico '{0}'5La sintaxis 'var (...)' como valor L est√° reservada.oLa sintaxis "var" de un patr√≥n no puede hacer referencia a un tipo, pero "{0}" est√° dentro del √°mbito aqu√≠.LNo se permite __arglist en la lista de par√°metros de m√©todos asincr√≥nicos@__arglist no se permite en la lista de par√°metros de iteradoresPEl par√°metro __arglist debe ser el √∫ltimo en una lista de par√°metros formales<No se puede usar la variable local '{0}' antes de declararlayNo se puede usar la variable local '{0}' antes de declararla. La declaraci√≥n de la variable local oculta el campo '{1}'.ÉLas enumeraciones, las clases y las estructuras no se pueden declarar en una interfaz que tenga un par√°metro de tipo "in" o "out".A'{0}': los miembros virtuales o abstractos no pueden ser privados,No se puede asignar un valor de tipo "void".=La operaci√≥n en cuesti√≥n no est√° definida en punteros void4Una tupla no puede contener un valor de tipo "void".@'{0}': un campo no puede ser tanto vol√°til como de solo lectura4'{0}': un campo vol√°til no puede ser del tipo '{1}'IUn evento de Windows Runtime no se puede pasar como par√°metro out o ref.ÜSe esperaba un tipo de valor devuelto gen√©rico similar a una tarea, pero el tipo "{0}" encontrado en el atributo "AsyncMethodBuilder" no era adecuado. Debe ser un tipo gen√©rico independiente de aridad uno y su tipo contenedor (si existe) debe ser no gen√©rico.>La convenci√≥n de llamada de "{0}" no es compatible con "{1}"._La coincidencia del tipo de tupla "{0}" requiere subpatrones "{1}", pero hay subpatrones "{2}".\La instrucci√≥n yield no se puede usar dentro de un m√©todo an√≥nimo o una expresi√≥n lambdaBNo se puede usar 'yield' en el c√≥digo de script de nivel superior!Los elementos no pueden ser NULL.No se admite el algoritmo '{0}'>La p√°gina de c√≥digo '{0}' no es v√°lida o no est√° instaladaBError inesperado al escribir la informaci√≥n de depuraci√≥n: '{0}'ûEl nombre de archivo '{0}' est√° vac√≠o, contiene caracteres no v√°lidos, tiene una especificaci√≥n de unidad sin ruta de acceso absoluta o es demasiado largobTipo de destino no v√°lido para /target: se debe especificar 'exe', 'winexe', 'library' o 'module'3No se pudo abrir el archivo de metadatos '{0}': {1}ÉNo se puede crear el nombre de archivo corto '{0}' cuando ya existe un nombre de archivo largo con el mismo nombre de archivo cortoQEl par√°metro gen√©rico es definici√≥n cuando se espera que sea la referencia {0}GLa directiva using para "{0}" aparec√≠a anteriormente como using global<La directiva using aparec√≠a anteriormente como using globalAlias externo sin usar.Alias externo sin usarDirectiva Using innecesaria.Directiva Using innecesaria?{0} no es una operaci√≥n de asignaci√≥n compuesta de C# v√°lida6{0} no es una expresi√≥n de conversi√≥n de C# v√°lida.grupo de &m√©todosm√©todo an√≥nimo5invalidaci√≥n del generador de m√©todos asincr√≥nicos await en bloques catch y finallyﬁW
                             Opciones del compilador de Visual¬†C#

                       - ARCHIVOS DE SALIDA -
-out:<archivo>                   Especifica el nombre del archivo de salida (el valor predeterminado: nombre base del 
                              archivo con la clase principal o el primer archivo)
-target:exe                   Compila un archivo ejecutable de consola (predeterminado) (forma
                              corta: -t:exe)
-target:winexe                Compila un archivo ejecutable de Windows (forma corta:
                              -t:winexe)
-target:library               Compila una biblioteca (forma corta: -t:library)
-target:module                Compila un m√≥dulo que se puede agregar a otro
                              ensamblado (forma corta: -t:module)
-target:appcontainerexe       Compila un archivo ejecutable Appcontainer (forma corta:
                              -t:appcontainerexe)
-target:winmdobj              Compila un archivo intermedio de Windows¬†Runtime
                              para que lo consuma WinMDExp (forma corta: -t:winmdobj)
-doc:<archivo>                   Archivo de documentaci√≥n XML que se va a generar
-refout:<archivo>                Salida de ensamblado de referencia para generar
-platform:<cadena>            Limita en qu√© plataformas se puede ejecutar este c√≥digo: x86,
                              Itanium, x64, arm, arm64, anycpu32bitpreferred o
                              anycpu. La predeterminada es anycpu.

                       - ARCHIVOS DE ENTRADA -
-recurse:<comod√≠n>           Incluye todos los archivos del directorio actual y los
                              subdirectorios de acuerdo con las especificaciones del
                              comod√≠n.
-reference:<alias>=<archivo>     Metadatos de referencia del archivo de
                              ensamblado especificado mediante el alias dado (forma corta: -r)
-reference:<lista de archivos >        Metadatos de referencia de los archivos de
                              ensamblado especificados (forma corta: -r)
-addmodule:<lista de archivos >        Vincula los m√≥dulos especificados en este ensamblado.
-link:<lista de archivos >             Inserta metadatos de los archivos de ensamblado de
                              interoperabilidad especificados (forma corta: -l)
-analyzer:<lista de archivos >         Ejecuta los analizadores de este ensamblado
                              (forma corta: -a)
-additionalfile:<lista de archivos>   Archivos adicionales que no afectan directamente a la generaci√≥n de c√≥digo,
                              pero que pueden usar los analizadores para producir
                              errores o advertencias.
-embed                        Inserta todos los archivos de origen en el PDB.
-embed:<lista de archivos >            Inserta archivos espec√≠ficos en el PDB.

                       - RECURSOS -
-win32res:<archivo>              Especifica un archivo de recursos Win32 (.res)
-win32icon:<archivo>             Usa este icono para la salida.
-win32manifest:<archivo>         Especifica un archivo de manifiesto Win32 (.xml)
-nowin32manifest              No incluye el manifiesto Win32 predeterminado
-resource:<info recurso>           Inserta el recurso especificado (forma corta: -res)
-linkresource:<info recurso>       Vincula el recurso especificado con este ensamblado
                              (forma corta: -linkres). El formato de informaci√≥n del recurso
                              es <archivo>[,<nombre de cadena >[,public|private]]

                       - GENERACI√ìN DE C√ìDIGO -
-debug[+|-]                   Emite informaci√≥n de depuraci√≥n
-debug:{full|pdbonly|portable|embedded}
                              Especifica el tipo de depuraci√≥n (‚Äúfull‚Äù es el valor predeterminado,
                              ‚Äúportable‚Äù es un formato multiplataforma,
                              ‚Äúembedded‚Äù es un formato multiplataforma insertado en
                              el archivo .dll o .exe de destino)
-optimize[+|-]                Habilita las optimizaciones (forma corta: -o)
-deterministic                Produce un ensamblado determinista
                              (que incluye el GUID y la marca de tiempo de la versi√≥n del m√≥dulo)
-refonly                      Produce un ensamblado de referencia en lugar de la salida principal.
-instrument:TestCoverage      Produce un ensamblado instrumentado para recopilar
                              informaci√≥n de cobertura.
-sourcelink:<archivo>            Informaci√≥n del v√≠nculo de origen para insertar en el PDB.
 
                       - ERRORES Y ADVERTENCIAS -
-warnaserror[+|-]             Notifica todas las advertencias como errores.
-warnaserror[+|-]:<lista de advertencias > Notifica advertencias espec√≠ficas como errores
                              (use "nullable" para todas las advertencias de nulabilidad).
-warn:<n>                     Establece el nivel de advertencia (0 o superior) (forma corta: -w)
-nowarn:<lista de advertencias >           Deshabilita mensajes de advertencia espec√≠ficos
                              (use "nullable" para todas las advertencias de nulabilidad)
-ruleset:<archivo>               Especifica un archivo de conjunto de reglas que deshabilita
                              diagn√≥sticos espec√≠ficos.
-errorlog:<archivo>[,version=<versi√≥n_de_sarif >]
                              Especifica un archivo para registrar todos los diagn√≥sticos del compilador y el
                              analizador.
                              versi√≥n_de_sarif:{1|2|2.1} El valor predeterminado es 1. 2 y 2.1,
                              ambos significan SARIF versi√≥n 2.1.0.
-reportanalyzer               Notifica informaci√≥n adicional del analizador, como el
                              tiempo de ejecuci√≥n.
-skipanalyzers[+|-]           Omite la ejecuci√≥n de los analizadores de diagn√≥stico.

                       - LENGUAJE -
-checked[+|-]                 Genera comprobaciones de desbordamiento.
-unsafe[+|-]                  Permite c√≥digo "no seguro".
-define:<lista de s√≠mbolos >         Define s√≠mbolos de compilaci√≥n condicional (forma
                              corta: -d)
-langversion:?                Muestra los valores permitidos para la versi√≥n de lenguaje.
-langversion:<cadena>         Especifica la versi√≥n de lenguaje, como
                              ‚Äúlatest‚Äù (√∫ltima versi√≥n, incluidas las secundarias),
                              ‚Äúdefault‚Äù (igual que ‚Äúlatest‚Äù),
                              ‚Äúlatestmajor‚Äù (√∫ltima versi√≥n, excluidas las secundarias),
                              ‚Äúpreview‚Äù (√∫ltima versi√≥n, incluidas las caracter√≠sticas en versi√≥n preliminar no admitida)
                              o versiones espec√≠ficas como ‚Äú6‚Äù o ‚Äú7.1‚Äù.
-nullable[+|-]                Especifique la opci√≥n de contexto que admite valores NULL enable|disable.
-nullable:{enable|disable|warnings|annotations}
                              Especifique la opci√≥n de contexto que admite valores NULL enable|disable|warnings|annotations.

                       - SEGURIDAD -
-delaysign[+|-]               Retrasa la firma del ensamblado usando solo la parte p√∫blica
                              de la clave de nombre seguro.
-publicsign[+|-]              Firma p√∫blica del ensamblado usando solo la parte p√∫blica
                              de la clave de nombre seguro.
-keyfile:<archivo>               Especifica un archivo de clave de nombre seguro.
-keycontainer:<cadena>        Especifica un contenedor de claves de nombres seguros.
-highentropyva[+|-]           Habilita ASLR de alta entrop√≠a.

                       - VARIOS -
@<archivo>                       Lee el archivo de respuesta para ver m√°s opciones.
-help                         Muestra este mensaje de uso (forma corta: -?)
-nologo                       Suprime el mensaje de copyright del compilador.
-noconfig                     No incluye autom√°ticamente el archivo CSC.RSP.
-parallel[+|-]                Compilaci√≥n simult√°nea.
-version                      Muestra el n√∫mero de versi√≥n del compilador y cierra.

                       - AVANZADO -
-baseaddress:<direcci√≥n>        Direcci√≥n base de la biblioteca que se compilar√°.
-checksumalgorithm:<alg>      Especifica el algoritmo para calcular la suma de comprobaci√≥n
                              del archivo de origen almacenado en PDB. Los valores admitidos son:
                              SHA1 o SHA256 (predeterminado).
-codepage:<n>                 Especifica la p√°gina de c√≥digo que se usar√° al abrir los archivos de
                              c√≥digo fuente.
-utf8output                   Mensajes del compilador de salida en codificaci√≥n UTF-8.
-main:<tipo>                  Especifica el tipo que contiene el punto de entrada
                              (ignora todos los dem√°s puntos de entrada posibles) (Forma
                              corta: -m)
-fullpaths                    El compilador genera rutas de acceso completas.
-filealign:<n>                Especifica la alineaci√≥n usada para las secciones del
                              archivo de salida.
-pathmap:<K1>=<V1>,<K2>=<V2>,...
                              Especifica una asignaci√≥n para los nombres de rutas de acceso de origen emitidos por
                              el compilador.
-pdb:<archivo>                   Especifica el nombre de archivo de informaci√≥n de depuraci√≥n (valor predeterminado:
                              nombre de archivo de salida con la extensi√≥n .pdb).
-errorendlocation             L√≠nea y columna de salida de la ubicaci√≥n final de
                              cada error. 
-preferreduilang              Especifica el nombre del lenguaje de salida preferido.
-nosdkpath                    Deshabilita la b√∫squeda de la ruta del SDK predeterminada para los ensamblados de biblioteca est√°ndar.
-nostdlib[+|-]                No hace referencia a la biblioteca est√°ndar (mscorlib.dll).
-subsystemversion:<cadena>    Especifica la versi√≥n del subsistema de este ensamblado.
-lib:<lista de archivos >              Especifica directorios adicionales en los que buscar
                              referencias.
-errorreport:<cadena>         Especifica c√≥mo tratar los errores internos del compilador:
                              avisar, enviar, poner en cola o ninguno. El valor predeterminado es
                              poner en cola.
-appconfig:<archivo>             Especifica un archivo de configuraci√≥n de aplicaci√≥n
                              que contenga opciones de enlace de ensamblado.
-moduleassemblyname:<cadena>  Nombre del ensamblado del que est√© m√≥dulo
                              formar√° parte.
-modulename:<cadena>          Especifica el nombre del m√≥dulo de origen.
-generatedfilesout:<dir>      Coloca archivos generados durante la compilaci√≥n en el
                              directorio especificado.

colecci√≥ncontravariantede forma contravariante
covariantede forma covariante*implementaci√≥n de interfaz predeterminadael directorio no existe4la ruta de acceso es demasiado larga o no es v√°lidadescartablevariable fixedvariable de iteraci√≥n foreach+cadenas textuales interpoladas alternativasy el patr√≥nm√©todos an√≥nimostipos an√≥nimosfunci√≥n asincr√≥nica
async mainflujos asincr√≥nicosusing asincr√≥nicaauto default struct fields*propiedades implementadas autom√°ticamente&inicializador de propiedad autom√°ticoliterales binarioschecked user-defined operatorsasignaci√≥n de incorporaci√≥ninicializador de colecci√≥ncadenas interpoladas constantesvalores devueltos de covarianteoperador predeterminadoliteral predeterminado3restricciones de par√°metros de tipo predeterminado(restricciones de tipo gen√©rico delegateinicializador de diccionariosseparadores de d√≠gitos	descarteseliminaci√≥n basada en patrones	din√°mico$restricciones de tipo gen√©rico enumfiltro de excepciones<descriptor de acceso de propiedades del cuerpo de expresi√≥n1constructor y destructor del cuerpo de expresi√≥n!indexador con forma de expresi√≥nm√©todo con forma de expresi√≥n!propiedad con forma de expresi√≥nRdeclaraci√≥n de variables de expresi√≥n en inicializadores y consultas de miembrosm√©todos parciales extendidos patrones de propiedad extendidosinstrucci√≥n "fixed" extensibleextensi√≥n GetAsyncEnumeratorextensi√≥n GetEnumeratorm√©todo de extensi√≥nalias externofunciones locales extern)espacio de nombres con √°mbito de archivob√∫feres de tama√±o fijopunteros de funci√≥natributos gen√©ricos
gen√©ricos*calificador de alias de espacio de nombresdirectiva global de usomatriz con tipo impl√≠cito"variable local con tipo impl√≠cito(creaci√≥n de objetos con tipo de destino#controladores de cadena interpoladaoperador de √≠ndice!indexando b√∫feres fijos moviblestipo de delegado inferido&establecedores solo de inicializaci√≥ncadenas interpoladas
iteradoresexpresi√≥n lambdaatributos de lambda!par√°metros de descarte de lambda tipo de valor devuelto de lambdaseparador de d√≠gito inicial directiva de intervalo de l√≠neapatr√≥n de listaatributos de funci√≥n localfunciones localesAtributo MemberNotNull9Declaraciones y expresiones mixtas en la desconstrucci√≥n1m√≥dulo como especificador de destino de atributoinicializadores de m√≥dulos*sombreado de nombres en funciones anidadasargumento con nombrenombre de operadorenteros de tama√±o nativo"stackalloc en expresiones anidadas!Nuevas l√≠neas en interpolaciones&restricci√≥n de tipo gen√©rico notnullsin patr√≥n$patr√≥n de constante de puntero nulooperador de propagaci√≥n nulotipos que aceptan valores NULL,tipos de referencia que aceptan valores NULLinicializador de objeto*descriptor de acceso obsoleto en propiedadpar√°metro opcionalo el patr√≥ndeclaraci√≥n de variable out,constructores de estructuras sin par√°metrospatr√≥n entre par√©ntesism√©todo parcialtipos parcialescoincidencia de patrones campos posicionales en registros#pragmaacci√≥n de advertencia "enable"private protected&modificadores de acceso en propiedadesexpresi√≥n de consultaoperador de intervaloliterales de cadena sin formatomiembros de solo lecturareferencias readonlyestructuras readonly:propiedades de solo lectura implementadas autom√°ticamente	registros	registrospatrones recursivos$expresi√≥n condicional de referenciam√©todos de extensi√≥n ref!variables for-loop de referencias.variables de iteraci√≥n foreach de referencias/variables locales y devoluciones por referenciareasignaci√≥n de referenciasestructuras refpatr√≥n relacionalToString sellado en el registro7pattern matching ReadOnly/Span<char> on constant stringinicializador stackalloc,miembros abstractos est√°ticos en interfacesfunci√≥n an√≥nima est√°ticaclases est√°ticasfunciones locales est√°ticas&inicializadores de campo de estructura<expresi√≥n switch>activar tipo booleano*expresi√≥n condicional con tipo de destinoexpresi√≥n throwigualdad de tuplatuplaspatr√≥n de tipovarianza de tipoUtf8 String LiteralsHpar√°metros de tipo sin restricciones en operador de incorporaci√≥n nulo"tipos construidos no administrados)restricciones de tipo gen√©rico unmanagedunsigned right shiftdeclaraciones usinguso de versi√≥n est√°tica6seguridad de varianza para miembros de interfaz staticcon los tipos an√≥nimoscon estrcutras<espacio de nombres global>de forma no variantevariable de entorno LIBopci√≥n /LIBexpresi√≥n lambda Versiones de lenguaje admitidas:{0} versi√≥n {1}CCopyright (C) Microsoft Corporation. Todos los derechos reservados.grupo de m√©todos<NULL><espacio de nombres>5La operaci√≥n ha provocado un desbordamiento de pila.Urestricciones para m√©todos de implementaci√≥n de interfaz expl√≠cita e invalidaci√≥n
par√°metro comprobaci√≥n null de par√°metro<lista de rutas de acceso>opci√≥n /REFERENCEPATH;(Ubicaci√≥n del s√≠mbolo relacionado con el error anterior)A(Ubicaci√≥n del s√≠mbolo relacionado con la advertencia anterior)valor devueltoalias usingconstructoreventoalias externocampoetiquetam√©todoespacio de nombres	propiedadtipopar√°metro de tipoelementovariable<texto><expresi√≥n throw>%Compilador de Microsoft (R) Visual C#instrucciones de nivel superiorvariable using'experimental') La etiqueta de inclusi√≥n no es v√°lida A Error al insertar algunos de los XML de inclusi√≥n o todos ellos:<!-- Badly formed XML comment ignored for member "{0}" -->A El archivo XML con formato incorrecto "{0}" no se puede incluir Falta el atributo de archivoFalta el atributo 'path'S No se encontraron elementos coincidentes para la siguiente etiqueta de inclusi√≥n fOmisi√≥n de algunos tipos en el ensamblado de analizador {0} por una ReflectionTypeLoadException: {1}.lOmitir la carga de los tipos con errores en el ensamblado de analizador debido a ReflectionTypeLoadExceptiontSe ha llamado a GetDeclarationName para un nodo de declaraci√≥n que puede contener varios declaradores de variables."elementos: no pueden estar vac√≠osSLa ubicaci√≥n se debe indicar para proporcionar una cualificaci√≥n de tipo m√≠nima.;LookupOptions tiene una combinaci√≥n de opciones no v√°lida$Conflicto de nombre en el nombre {0}Se espera SearchCriteria.No es un s√≠mbolo C#.ÖSe han proporcionado {0}¬†tipos de par√°metro y {1}¬†tipos de referencia de par√°metro. Estas matrices deben tener la misma longitud.Q"RefKind.Out" no es un tipo de referencia v√°lido para un tipo de valor devuelto.QLa posici√≥n no est√° dentro del √°rbol de sintaxis con el intervalo completo {0}DLa posici√≥n debe estar dentro del intervalo del √°rbol de sintaxis.pEl nodo de sintaxis que se va a especular no puede pertenecer a un √°rbol de sintaxis de la compilaci√≥n actual.;El env√≠o puede tener, como m√°ximo, un √°rbol de sintaxis./El env√≠o solo puede incluir c√≥digo de script.:El nodo de sintaxis no est√° dentro del √°rbol de sintaxisYa hay un √°rbol de sintaxis\SyntaxTree se obtuvo de una directiva #load y no se puede quitar ni reemplazar directamente.3El √°rbol de sintaxis debe crearse desde un env√≠o.,SyntaxTree no forma parte de la compilaci√≥nISyntaxTree no forma parte de la compilaci√≥n, as√≠ que no se puede quitar]Se debe indicar SyntaxTreeSemanticModel para proporcionar una cualificaci√≥n de tipo m√≠nima.NEste m√©todo solo se puede usar para crear tokens: {0} no es un tipo de token.Ael √°rbol debe tener un nodo ra√≠z con SyntaxKind.CompilationUnit+el √°rbol no forma parte de la compilaci√≥n&El argumento de tipo no puede ser NULL_Use Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Literal para crear tokens literales num√©ricos.aUse Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Literal para crear tokens literales de car√°cter.üUse Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Identifier o Microsoft.CodeAnalysis.CSharp.SyntaxFactory.VerbatimIdentifier para crear tokens de identificador.pEl valor de alineaci√≥n {0} tiene una magnitud superior a {1} y puede dar lugar a una cadena con formato grande.^El valor de alineaci√≥n tiene una magnitud que puede dar lugar a una cadena con formato grande=El resultado de la expresi√≥n siempre es 'NULL' de tipo '{0}'/El resultado de la expresi√≥n siempre es 'null'êReferencia ambigua en el atributo cref: '{0}'. Se supone '{1}', pero tambi√©n podr√≠a haber coincidido con otras sobrecargas que incluyen '{2}'.&Referencia ambigua en el atributo crefBNo se puede crear una instancia de analizador {0} desde {1} : {2}.-No se puede crear una instancia de analizadorfEl ensamblado "{0}" que contiene el tipo "{1}" hace referencia a .NET Framework, lo cual no se admite.WEl ensamblado que se ha cargado hace referencia a .NET Framework, lo cual no se admite.`El atributo '{0}' del m√≥dulo '{1}' se omitir√° a favor de la instancia que aparece en el origenNSe ignorar√° el atributo en beneficio de la instancia que aparece en la fuente◊Asignaci√≥n posiblemente incorrecta a la variable local '{0}', que es el argumento pasado a una instrucci√≥n using o lock. La llamada Dispose o el desbloqueo se producir√°n en el valor original de la variable local.dPosiblemente una asignaci√≥n incorrecta a local, que es el argumento a una instrucci√≥n using o lockAAsignaci√≥n a la misma variable. ¬øQuer√≠a asignar otro elemento?"Se ha asignado a la misma variableäEl m√©todo asincr√≥nico carece de operadores "await" y se ejecutar√° de forma sincr√≥nica. Puede usar el operador 'await' para esperar llamadas API que no sean de bloqueo o 'await Task.Run(...)' para hacer tareas enlazadas a la CPU en un subproceso en segundo plano.YEl m√©todo asincr√≥nico carece de operadores "await" y se ejecutar√° de forma sincr√≥nica\El tipo "{0}" no se puede usar en este contexto porque no se puede representar en metadatos.VEl tipo no se puede usar en este contexto porque no se puede representar en metadatos.CEl atributo "{0}" se ignora cuando se especifica la firma p√∫blica.<El atributo se omite cuando se especifica la firma p√∫blica.©'{0}' no es una ubicaci√≥n de atributos v√°lida para esta declaraci√≥n. Las ubicaciones de atributos v√°lidas son '{1}'. Todos los atributos de este bloque se omitir√°n.DNo hay ninguna ubicaci√≥n de atributo v√°lida para esta declaraci√≥n°Los atributos destinados al campo en las propiedades autom√°ticas no se admiten en la versi√≥n del lenguaje {0}. Use la versi√≥n del lenguaje {1} o una superior.nLos atributos destinados al campo en las propiedades autom√°ticas no se admiten en esta versi√≥n del lenguaje.ëPosible comparaci√≥n de referencias no intencionada; para obtener una comparaci√≥n de valores, convierta el lado de la izquierda en el tipo '{0}'cPosible comparaci√≥n de referencias involuntaria: El lado de la mano izquierda necesita conversi√≥nèPosible comparaci√≥n de referencias no intencionada; para obtener una comparaci√≥n de valores, convierta el lado de la derecha en el tipo '{0}'aPosible comparaci√≥n de referencias involuntaria. El lado de la mano derecha necesita conversi√≥nTNo se puede restaurar la advertencia 'CS{0}' porque estaba deshabilitada globalmenteKNo se puede restaurar la advertencia porque se ha deshabilitado globalmente(El nombre de idioma '{0}' no es v√°lido.!El nombre de idioma no es v√°lido-'{0}' no es un n√∫mero de advertencia v√°lidoæUn n√∫mero que se aprob√≥ en la directiva de preprocesador de advertencia #pragma no es un n√∫mero de advertencia v√°lido. Verifique que ese n√∫mero representa una advertencia y no un error.!N√∫mero de advertencia no v√°lidoFEl comentario XML tiene un atributo cref '{0}' que no se pudo resolverTTipo no v√°lido para el par√°metro {0} en el atributo cref del comentario XML: '{1}'ITipo no v√°lido para el par√°metro en el atributo cref del comentario XMLHTipo de valor devuelto no v√°lido en el atributo cref del comentario XMLHTipo de valor devuelto no v√°lido en el atributo cref del comentario XMLFEl comentario XML tiene un atributo cref '{0}' con sintaxis incorrectaDEl comentario XML tiene un atributo cref sint√°cticamente incorrectoZEl comentario XML tiene un atributo cref '{0}' que hace referencia a un par√°metro de tipoTEl comentario XML tiene un atributo cref que hace referencia a un par√°metro de tipo@El comentario XML tiene un atributo cref que no se pudo resolver}Operador OR bit a bit usado en un operando con extensi√≥n de signo; puede convertir primero a un tipo sin signo m√°s peque√±o±El compilador ampli√≥ y extendi√≥ el signo de una variable. Luego, utiliz√≥ el valor resultante en una operaci√≥n OR bit a bit. Esto puede provocar un comportamiento inesperado.EOperador OR bit a bit utilizado en un operando de extensi√≥n de signoøSi se utiliza '{0}' como valor out o ref, o se acepta su direcci√≥n, se puede producir una excepci√≥n en tiempo de ejecuci√≥n porque es un campo de una clase de serializaci√≥n por referencia.ØSi se utiliza un campo de una clase de serializaci√≥n por referencia como valor ref o out, o se acepta su direcci√≥n, se puede producir una excepci√≥n en tiempo de ejecuci√≥n.ÜLlame a System.IDisposable.Dispose() en la instancia asignada de {0} antes de que todas las referencias a √©l est√©n fuera de √°mbito.yLlame a System.IDisposable.Dispose() en una instancia asignada antes de que todas sus referencias est√©n fuera de √°mbitoæLa instancia asignada de {0} no se desecha en todas las rutas de acceso de excepciones. Llame a System.IDisposable.Dispose() antes de que todas las referencias a √©l est√©n fuera de √°mbito.SLa instancia asignada no est√° eliminada en todas las rutas de acceso de excepci√≥n2El objeto '{0}' se puede desechar m√°s de una vez.+Se puede eliminar el objeto m√°s de una vezCEl uso de matrices como argumentos de atributo no es conforme a CLSCEl uso de matrices como argumentos de atributo no es conforme a CLSh'{0}' no se puede marcar como conforme a CLS porque el ensamblado no tiene ning√∫n atributo CLSCompliantk'{0}' no necesita ning√∫n atributo CLSCompliant porque el ensamblado no tiene ning√∫n atributo CLSCompliantrEl tipo o el miembro no necesitan un atributo CLSCompliant porque el ensamblador no tiene un atributo CLSComplianttNo se puede marcar al tipo o al miembro como conformes a CLS porque el ensamblador no tiene un atributo CLSCompliant/El tipo de argumento '{0}' no es conforme a CLS)El tipo de argumento no es conforme a CLSK'{0}' no tiene constructores accesibles que usen solo tipos conformes a CLSLEL tipo no tiene constructores accesibles que solo usen tipos conforme a CLS.'{0}': el tipo base '{1}' no es conforme a CLS™Se ha marc