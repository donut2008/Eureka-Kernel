lâ€™opÃ©rateur dÃ©fini par lâ€™utilisateur '{0}'HLes opÃ©rateurs dÃ©finis par l'utilisateur ne peuvent pas retourner void\'{0}'Â : les classes static ne peuvent pas contenir d'opÃ©rateurs dÃ©finis par l'utilisateurPL'opÃ©rateur '{0}' exige qu'un opÃ©rateur correspondant '{1}' soit aussi dÃ©finiRL'opÃ©rateur dÃ©fini par l'utilisateur '{0}' doit Ãªtre dÃ©clarÃ© static et public+L'option '{0}' doit Ãªtre un chemin absolu.1Un paramÃ¨tre in ne peut pas avoir l'attribut OutgImpossible de spÃ©cifier l'attribut Out sur un paramÃ¨tre ref sans spÃ©cifier Ã©galement l'attribut In.HImpossible de dÃ©clarer une variable out en tant que variable locale refKL'option /out doit Ãªtre spÃ©cifiÃ©e pour les sorties dÃ©pourvues de source=Impossible d'Ã©crire dans le fichier de sortie '{0}' -- '{1}''{0}' ne peut pas dÃ©finir un {1} surchargÃ© qui se diffÃ©rencie uniquement par les modificateurs de paramÃ¨tres '{2}' et '{3}'şLa mÃ©thode '{0}' spÃ©cifie une contrainte 'default' pour le paramÃ¨tre de type '{1}', mais le paramÃ¨tre de type '{2}' correspondant de la mÃ©thode substituÃ©e ou explicitement implÃ©mentÃ©e '{3}' est limitÃ© Ã  un type rÃ©fÃ©rence ou Ã  un type valeur.FNe pas substituer object.Finalize. Fournir un destructeur Ã  la place.D'{0}' doit Ãªtre obligatoire, car il remplace le membre requis '{1}'L'{0}'Â : aucune mÃ©thode appropriÃ©e n'a Ã©tÃ© trouvÃ©e pour la substitutionUUn membre '{0}' marquÃ© comme override ne peut pas Ãªtre marquÃ© comme new ou virtualâLa mÃ©thode '{0}' spÃ©cifie une contrainte 'class' pour le paramÃ¨tre de type '{1}', mais le paramÃ¨tre de type '{2}' correspondant de la mÃ©thode substituÃ©e ou explicitement implÃ©mentÃ©e '{3}' n'est pas un type rÃ©fÃ©rence.ëLa mÃ©thode '{0}' spÃ©cifie une contrainte 'struct' pour le paramÃ¨tre de type '{1}', mais le paramÃ¨tre de type '{2}' correspondant de la mÃ©thode substituÃ©e ou explicitement implÃ©mentÃ©e '{3}' n'est pas un type valeur non-nullable.êLes contraintes des mÃ©thodes d'implÃ©mentation d'interface par remplacement et explicites sont hÃ©ritÃ©es de la mÃ©thode de base. Elles ne peuvent donc pas Ãªtre spÃ©cifiÃ©es directement, sauf pour une contrainte 'class' ou 'struct'.(OpÃ©rateur binaire surchargeable attendu OpÃ©rateur surchargeable attendu'OpÃ©rateur unaire surchargeable attendutImpossible de dÃ©finir/annuler la dÃ©finition des symboles de prÃ©processeur Ã  la suite du premier jeton du fichier$Directive de prÃ©processeur attendueCImpossible d'utiliser #load Ã  la suite du premier jeton du fichier@Impossible d'utiliser #r Ã  la suite du premier jeton du fichier@Le paramÃ¨tre contient plusieurs valeurs par dÃ©faut distinctes.^Le paramÃ¨tre out '{0}' doit Ãªtre assignÃ© avant que le contrÃ´le quitte la mÃ©thode actuelleJ'{0}'Â : les types static ne peuvent pas Ãªtre utilisÃ©s comme paramÃ¨tres:ParamÃ¨tre non valide pour le type non managÃ© spÃ©cifiÃ©.NLa fonctionnalitÃ© Â« paramÃ¨tre null-checking Â» nâ€™est pas prise en charge.<Impossible de dÃ©clarer le paramÃ¨tre params en tant que {0}SUn paramÃ¨tre params doit Ãªtre le dernier paramÃ¨tre dans une liste de paramÃ¨tresALe paramÃ¨tre params doit Ãªtre un tableau Ã  une seule dimensionkLes deux dÃ©clarations de mÃ©thodes partielles doivent avoir des modificateurs d'accessibilitÃ© identiques.”Les deux dÃ©clarations de mÃ©thodes partielles doivent avoir des combinaisons identiques des modificateurs 'virtual', 'override', 'sealed' et 'new'.gSoit les deux dÃ©clarations de mÃ©thode partielles sont des mÃ©thodes d'extension, soit aucune ne l'estºLes mÃ©thodes partielles avec uniquement une dÃ©claration de dÃ©finition ou des mÃ©thodes conditionnelles supprimÃ©es ne peuvent pas Ãªtre utilisÃ©es dans des arborescences d'expressionsuLes dÃ©clarations de mÃ©thodes partielles de '{0}' ont des contraintes incohÃ©rentes pour le paramÃ¨tre de type '{1}'uLes deux dÃ©clarations de mÃ©thodes partielles, '{0}' et '{1}', doivent utiliser les mÃªmes noms d'Ã©lÃ©ments tuples.CUne mÃ©thode partielle ne peut pas avoir le modificateur 'abstract'qAucune dÃ©claration de dÃ©finition trouvÃ©e pour la dÃ©claration d'implÃ©mentation de la mÃ©thode partielle '{0}'VUne mÃ©thode partielle ne peut pas implÃ©menter explicitement une mÃ©thode d'interfaceFUne mÃ©thode partielle doit Ãªtre dÃ©clarÃ©e au sein d'un type partielRUne mÃ©thode partielle ne peut pas avoir plusieurs dÃ©clarations d'implÃ©mentationOUne mÃ©thode partielle ne peut pas avoir plusieurs dÃ©clarations de dÃ©finitiongSoit les deux dÃ©clarations de mÃ©thode partielles utilisent un paramÃ¨tre params, soit aucune des deuxWSoit les deux dÃ©clarations de mÃ©thodes partielles sont readonly, soit aucune ne l'estbLes dÃ©clarations de mÃ©thodes partielles doivent avoir des valeurs de retour ref correspondantes.ULes deux dÃ©clarations de mÃ©thodes partielles doivent avoir le mÃªme type de retour.WSoit les deux dÃ©clarations de mÃ©thode partielles sont statiques, soit aucune ne l'estImpossible de crÃ©er un dÃ©lÃ©guÃ© Ã  partir de la mÃ©thode '{0}', car il s'agit d'une mÃ©thode partielle sans dÃ©claration d'implÃ©mentationTSoit les deux dÃ©clarations de mÃ©thode partielles sont unsafe, soit aucune ne l'estqLa mÃ©thode partielle '{0}' doit avoir une partie implÃ©mentation, car elle a des modificateurs d'accessibilitÃ©.™La mÃ©thode partielle '{0}' doit avoir des modificateurs d'accessibilitÃ©, car elle a un modificateur 'virtual', 'override', 'sealed', 'new' ou 'extern'.wLa mÃ©thode partielle '{0}' doit avoir des modificateurs d'accessibilitÃ©, car elle a un type de retour non nul (void).lLa mÃ©thode partielle '{0}' doit avoir des modificateurs d'accessibilitÃ©, car elle a des paramÃ¨tres 'out'.ŒLe modificateur 'partial' peut apparaÃ®tre uniquement juste avant 'class', 'record', 'struct', 'interface' ou un type de retour de mÃ©thode.WLes dÃ©clarations partielles de '{0}' ont des modificateurs d'accessibilitÃ© en conflit`Les dÃ©clarations partielles de '{0}' ne doivent pas spÃ©cifier des classes de base diffÃ©rentes½Les dÃ©clarations partielles de '{0}' doivent Ãªtre toutes les classes, toutes les classes dâ€™enregistrement, tous les structs, tous les structs dâ€™enregistrement ou toutes les interfaceshLes dÃ©clarations partielles de '{0}' ont des contraintes incohÃ©rentes pour le paramÃ¨tre de type '{1}'mLes dÃ©clarations partielles de '{0}' doivent avoir les mÃªmes noms de paramÃ¨tre de type dans le mÃªme ordreŠLes dÃ©clarations partielles de '{0}' doivent avoir les mÃªmes noms de paramÃ¨tre de type et modificateurs de variance dans le mÃªme ordre=Vous ne devez pas utiliser le type 'dynamic' dans un modÃ¨le.xIl n'est pas correct d'utiliser le type Nullable '{0}?' dans un modÃ¨le. Utilisez le type sous-jacent '{0}' Ã  la place.„Une constante Â« null Â» de chaÃ®ne nâ€™est pas prise en charge en tant que modÃ¨le pour Â«{0}Â». Utilisez plutÃ´t une chaÃ®ne vide.Une expression de type '{0}' ne peut pas Ãªtre gÃ©rÃ©e par un modÃ¨le de type '{1}' en C# {2}. Utilisez la version de langage {3} ou une version ultÃ©rieure.TUne expression de type '{0}' ne peut pas Ãªtre gÃ©rÃ©e par un modÃ¨le de type '{1}'.IUne erreur s'est produite durant l'Ã©criture du fichier de sortieÂ : {0}.yErreur lors de la lecture du fichier '{0}' spÃ©cifiÃ© pour l'argument nommÃ© '{1}' pour l'attribut PermissionSetÂ : '{2}'Impossible de rÃ©soudre le chemin d'accÃ¨s au fichier '{0}' spÃ©cifiÃ© pour l'argument nommÃ© '{1}' de l'attribut PermissionSet6is' et 'as' ne sont pas valides sur les types pointeurJLes critÃ¨res spÃ©ciaux ne sont pas autorisÃ©s pour les types de pointeur.MLe corps d'une mÃ©thode async-iterator doit contenir une instruction 'yield'.£Le corps d'une mÃ©thode async-iterator doit contenir une instruction 'yield'. Supprimez 'async' de la dÃ©claration de mÃ©thode, ou ajoutez une instruction 'yield'.WPour effectuer un cast d'une valeur nÃ©gative, vous devez la mettre entre parenthÃ¨ses.FLe membre '{0}' est introuvable sur le type '{1}' de l'assembly '{2}'.7Le type prÃ©dÃ©fini '{0}' n'est pas dÃ©fini ou importÃ©`Le type prÃ©dÃ©fini '{0}' est dÃ©clarÃ© dans plusieurs assemblys rÃ©fÃ©rencÃ©sÂ : '{1}' et '{2}'/Le type prÃ©dÃ©fini '{0}' doit Ãªtre un struct.7Le type prÃ©dÃ©fini '{0}' n'est pas dÃ©fini ou importÃ©SLa valeur SecurityAction '{0}' n'est pas valide pour l'attribut PrincipalPermissionN'{0}'Â : les propriÃ©tÃ©s abstraites ne peuvent pas avoir d'accesseurs privateF'{0}'Â : une propriÃ©tÃ© ou un indexeur ne peut pas Ãªtre de type voidlImpossible d'utiliser la propriÃ©tÃ© ou l'indexeur '{0}' dans ce contexte, car il lui manque l'accesseur get‰Un sous-modÃ¨le de propriÃ©tÃ© nÃ©cessite une correspondance de la rÃ©fÃ©rence Ã  la propriÃ©tÃ© ou au champ. ExempleÂ : '{{ Nom: {0} }}'H'{0}'Â : une propriÃ©tÃ© ou un indexeur doit avoir au moins un accesseurH'{0}'Â : les classes static ne peuvent pas contenir de membres protected7'{0}'Â : nouveau membre protected dÃ©clarÃ© dans struct8L'opÃ©rateur * ou -> doit Ãªtre appliquÃ© Ã  un pointeur:Un pointeur ne doit Ãªtre indexÃ© que par une seule valeurYErreur lors de la signature de la sortie avec une clÃ© publique du conteneur '{0}' -- {1}WErreur lors de la signature de la sortie avec une clÃ© publique du fichier '{0}' -- {1}La signature publique a Ã©tÃ© spÃ©cifiÃ©e et nÃ©cessite une clÃ© publique. Toutefois, aucune clÃ© publique n'a Ã©tÃ© spÃ©cifiÃ©e.DLa signature publique n'est pas prise en charge pour les netmodules.6La variable de portÃ©e '{0}' a dÃ©jÃ  Ã©tÃ© dÃ©clarÃ©euLe nom '{0}' n'est pas dans la portÃ©e Ã  droite de 'equals'. Ã‰changez les expressions de chaque cÃ´tÃ© de 'equals'.wPlusieurs implÃ©mentations du modÃ¨le de requÃªte ont Ã©tÃ© trouvÃ©es pour le type source '{0}'. Appel ambigu Ã  '{1}'.nImpossible de trouver une implÃ©mentation du modÃ¨le de requÃªte pour le type source '{0}'. '{1}' introuvable.°Impossible de trouver une implÃ©mentation du modÃ¨le de requÃªte pour le type source '{0}'. '{1}' introuvable. SpÃ©cifiez explicitement le type de la variable de portÃ©e '{2}'.ÑImpossible de trouver une implÃ©mentation du modÃ¨le de requÃªte pour le type source '{0}'. '{1}' introuvable. Vous manque-t-il des rÃ©fÃ©rences d'assembly requises ou une directive using pour 'System.Linq'Â ?SImpossible de passer la variable de portÃ©e '{0}' en tant que paramÃ¨tre out ou refuLe nom '{0}' n'est pas dans la portÃ©e Ã  gauche de 'equals'. Ã‰changez les expressions de chaque cÃ´tÃ© de 'equals'.4Impossible d'assigner {0} Ã  une variable de portÃ©eWLa variable de portÃ©e '{0}' est en conflit avec une dÃ©claration prÃ©cÃ©dente de '{0}'XLa variable de portÃ©e '{0}' ne peut pas Ãªtre assignÃ©e Ã  -- elle est en lecture seule`La variable de portÃ©e '{0}' ne peut pas avoir le mÃªme nom qu'un paramÃ¨tre de type de mÃ©thodepLe type de l'expression dans la clause {0} est incorrect. L'infÃ©rence de type a Ã©chouÃ© dans l'appel Ã  '{1}'.yLe type de l'une des expressions dans la clause {0} est incorrect. L'infÃ©rence de type a Ã©chouÃ© dans l'appel Ã  '{1}'.ÄUne expression de type '{0}' n'est pas autorisÃ©e dans une clause from ultÃ©rieure dans une expression de requÃªte avec un type source '{1}'. L'infÃ©rence de type a Ã©chouÃ© dans l'appel Ã  '{2}'.QLe dÃ©limiteur de littÃ©ral de chaÃ®ne brute doit se trouver sur sa propre ligne.sLes littÃ©raux de chaÃ®ne brute multiligne sont uniquement autorisÃ©s dans les chaÃ®nes interpolÃ©es textuellement.ZLes littÃ©raux de chaÃ®ne brute multiligne doivent contenir au moins une ligne de contenu.]Les littÃ©raux de chaÃ®ne brute ne sont pas autorisÃ©s dans les directives de prÃ©processeur.
} attendue·Impossible d'incorporer le type '{0}', car il a une nouvelle abstraction d'un membre de l'interface de base. Affectez la valeur false Ã  la propriÃ©tÃ© 'Incorporer les types interop'.Œ'{0}'Â : 'readonly' peut uniquement Ãªtre utilisÃ© sur des accesseurs si la propriÃ©tÃ© ou l'indexeur a un accesseur get et un accesseur setk'readonly' nâ€™est pas pris en charge en tant que modificateur de paramÃ¨tre. Vouliez-vous dire Â« in Â»Â ?Les membres du champ readonly '{0}' de type '{1}' ne peuvent pas Ãªtre assignÃ©s avec un initialiseur d'objet, car il s'agit d'un type valeurULe constructeur principal est en conflit avec le constructeur de copie synthÃ©tisÃ©e.¼Un constructeur dÃ©clarÃ© dans un 'struct' avec une liste de paramÃ¨tres doit avoir un initialiseur 'this' qui appelle le constructeur principal ou un constructeur explicitement dÃ©clarÃ©.5Le constructeur '{0}' ne peut pas s'appeler lui-mÃªme~Impossible de dÃ©duire le type de '{0}', car son initialiseur fait directement ou indirectement rÃ©fÃ©rence Ã  la dÃ©finition.†Impossible d'effectuer une assignation par rÃ©fÃ©rence de '{1}' vers '{0}', car '{1}' a une portÃ©e de sortie plus limitÃ©e que '{0}'.¸Cette rÃ©fÃ©rence ne peut pas effectuer une attribution par rÃ©fÃ©rence '{1}' Ã  '{0}', car '{1}' ne peut Ã©chapper Ã  la mÃ©thode actuelle quâ€™Ã  lâ€™aide dâ€™une instruction return.ëCette rÃ©fÃ©rence ne peut affecter '{1}' Ã  '{0}', car '{1}' a une Ã©tendue dâ€™Ã©chappement de valeur plus large que '{0}' permettant lâ€™affectation via '{0}' de valeurs avec des Ã©tendues dâ€™Ã©chappement plus restreintes que '{1}'.ML'expression doit Ãªtre de type '{0}', car elle est assignÃ©e par rÃ©fÃ©rence_'await' ne peut pas Ãªtre utilisÃ© dans une expression contenant un opÃ©rateur conditionnel refXL'expression doit Ãªtre de type '{0}' pour correspondre Ã  la valeur ref de remplacement|Les deux valeurs d'opÃ©rateur conditionnel doivent Ãªtre des valeurs ref. Sinon, aucune d'elles ne doit Ãªtre une valeur ref‡Le type '{2}' doit Ãªtre un type rÃ©fÃ©rence afin d'Ãªtre utilisÃ© comme paramÃ¨tre '{1}' dans le type ou la mÃ©thode gÃ©nÃ©rique '{0}'€Le premier paramÃ¨tre d'une mÃ©thode d'extension 'ref' '{0}' doit Ãªtre un type valeur ou un type gÃ©nÃ©rique limitÃ© Ã  struct.<Un champ ref ne peut pas faire rÃ©fÃ©rence Ã  un struct ref.UUn champ de rÃ©fÃ©rence ne peut Ãªtre dÃ©clarÃ© que dans une sructure de rÃ©fÃ©rence.ELe cÃ´tÃ© gauche dâ€™une affectation ref doit Ãªtre une variable ref.FUne valeur ref ou out doit Ãªtre une variable qui peut Ãªtre assignÃ©e@Un paramÃ¨tre ref ou out ne peut pas avoir de valeur par dÃ©faut‰Une propriÃ©tÃ© ou un indexeur qui ne retourne pas une rÃ©fÃ©rence ne peut pas Ãªtre utilisÃ© en tant que valeur ou rÃ©fÃ©rence de sortie_Les propriÃ©tÃ©s qui effectuent un retour par rÃ©fÃ©rence ne peuvent pas avoir d'accesseurs setXLes propriÃ©tÃ©s qui effectuent un retour par rÃ©fÃ©rence doivent avoir un accesseur getaImpossible d'utiliser un champ readonly en tant que valeur ref ou out (sauf dans un constructeur)sImpossible d'utiliser les membres du champ readonly '{0}' en tant que valeur ref ou out (sauf dans un constructeur)VImpossible d'utiliser '{0}' en tant que valeur ref ou out, car il est en lecture seuleaImpossible d'utiliser les champs de '{0}' en tant que valeur ref ou out, car il s'agit d'un '{1}'SImpossible d'utiliser '{0}' en tant que valeur ref ou out, car il s'agit d'un '{1}'lImpossible d'utiliser {0} '{1}' en tant que valeur ref ou out, car il s'agit d'une variable en lecture seule{Impossible d'utiliser les membres de {0} '{1}' en tant que valeur ref ou out, car il s'agit d'une variable en lecture seuleÅUn paramÃ¨tre de constructeur primaire dâ€™un type en lecture seule ne peut pas Ãªtre utilisÃ© comme valeur ref ou out (sauf dans le setter init-only du type ou dans un initialisateur de variable).×Membres dâ€™un paramÃ¨tre de constructeur primaire '{0}' dâ€™un type en lecture seule ne peut pas Ãªtre utilisÃ© comme valeur ref ou out (sauf dans le setter init-only du type ou dans un initialisateur de variable).sImpossible d'utiliser un champ readonly statique en tant que valeur ref ou out (sauf dans un constructeur statique)„Impossible d'utiliser les champs du champ readonly statique '{0}' en tant que valeur ref ou out (sauf dans un constructeur statique){Impossible de retourner la variable locale '{0}' par rÃ©fÃ©rence, car il ne s'agit pas d'une variable locale de rÃ©fÃ©renceˆImpossible de retourner un membre de la variable locale '{0}' par rÃ©fÃ©rence, car il ne s'agit pas d'une variable locale de rÃ©fÃ©rencewImpossible d'utiliser une expression dans ce contexte, car elle ne peut pas Ãªtre passÃ©e ou retournÃ©e par rÃ©fÃ©rencefL'expression de retour doit Ãªtre de type '{0}', car cette mÃ©thode effectue un retour par rÃ©fÃ©renceˆImpossible de retourner '{0}' par rÃ©fÃ©rence, car il a Ã©tÃ© initialisÃ© Ã  une valeur qui ne peut pas Ãªtre retournÃ©e par rÃ©fÃ©rence Impossible d'effectuer un retour par rÃ©fÃ©rence d'un membre de '{0}', car il a Ã©tÃ© initialisÃ© Ã  une valeur qui ne peut pas Ãªtre retournÃ©e par rÃ©fÃ©rencešNe peut pas retourner un paramÃ¨tre par rÃ©fÃ©rence '{0}' par le biais dâ€™un paramÃ¨tre refÂ ; il ne peut Ãªtre retournÃ© que dans une instruction return¦Impossible de retourner par rÃ©fÃ©rence un membre du paramÃ¨tre '{0}' par le biais dâ€™un paramÃ¨tre refÂ ; il ne peut Ãªtre retournÃ© que dans une instruction returniImpossible de retourner un paramÃ¨tre par rÃ©fÃ©rence '{0}', car il ne sâ€™agit pas dâ€™un paramÃ¨tre refvImpossible de retourner par rÃ©fÃ©rence un membre du paramÃ¨tre '{0}', car il ne s'agit pas d'un paramÃ¨tre ref ou outVImpossible de retourner le paramÃ¨tre de constructeur principal '{0}' par rÃ©fÃ©rence.DImpossible de retourner la variable de portÃ©e '{0}' par rÃ©fÃ©renceQImpossible de retourner un champ readonly par rÃ©fÃ©rence accessible en Ã©criturecImpossible de retourner les membres du champ readonly '{0}' par rÃ©fÃ©rence accessible en Ã©critureJImpossible de retourner '{0}' par rÃ©fÃ©rence, car il est en lecture seuleUImpossible de retourner les champs de '{0}' par rÃ©fÃ©rence, car il s'agit d'un '{1}'GImpossible de retourner '{0}' par rÃ©fÃ©rence, car il s'agit d'un '{1}'xImpossible de retourner {0} '{1}' par rÃ©fÃ©rence accessible en Ã©criture, car il s'agit d'une variable en lecture seule‡Impossible de retourner les membres de {0} '{1}' par rÃ©fÃ©rence accessible en Ã©criture, car il s'agit d'une variable en lecture seuleUn paramÃ¨tre de constructeur principal dâ€™un type en lecture seule ne peuvent pas Ãªtre retournÃ©s par une rÃ©fÃ©rence accessible en Ã©criture¢Les membres du paramÃ¨tre de constructeur principal '{0}' dâ€™un type en lecture seule ne peuvent pas Ãªtre retournÃ©s par une rÃ©fÃ©rence accessible en Ã©critureZImpossible de retourner un champ readonly statique par rÃ©fÃ©rence accessible en Ã©criturekImpossible de retourner les champs du champ readonly statique '{0}' par rÃ©fÃ©rence accessible en Ã©crituregImpossible de retourner un paramÃ¨tre par rÃ©fÃ©rence '{0}', car il est Ã©tendu Ã  la mÃ©thode actuelleqImpossible de retourner par rÃ©fÃ©rence un membre du paramÃ¨tre '{0}', car il est Ã©tendu Ã  la mÃ©thode actuelleaLes membres struct ne peuvent pas retourner 'this' ou d'autres membres d'instance par rÃ©fÃ©rence/Impossible de retourner 'this' par rÃ©fÃ©rence.y'Impossible d'utiliser 'await' dans une expression contenant un appel Ã  '{0}', car il effectue un retour par rÃ©fÃ©rence˜Une arborescence d'expression lambda ne peut pas contenir d'appel Ã  une mÃ©thode, une propriÃ©tÃ© ou un indexeur qui effectue un retour par rÃ©fÃ©renceBImpossible dâ€™exiger une rÃ©fÃ©rence retournant des propriÃ©tÃ©s.M'{0}'Â : les structs par rÃ©fÃ©rence ne peuvent pas implÃ©menter d'interfacesj'{0}'Â : impossible de spÃ©cifier Ã  la fois une classe de contrainte et la contrainte 'class' ou 'struct''#r n'est autorisÃ© que dans les scriptsbLes modÃ¨les relationnels ne peuvent pas Ãªtre utilisÃ©s pour une valeur NaN Ã  virgule flottante.>Le '{0}' de membre requis ne peut pas Ãªtre masquÃ© par '{1}'.yLe membre obligatoire '{0}' ne peut pas Ãªtre moins visible ou avoir un setter moins visible que le type conteneur '{1}'.oLe membre obligatoire '{0}' doit Ãªtre dÃ©fini dans lâ€™initialiseur dâ€™objet ou le constructeur dâ€™attribut.5Le membre obligatoire '{0}' doit Ãªtre dÃ©finissable.¶La liste des membres requis pour le type de base '{0}' est incorrecte et ne peut pas Ãªtre interprÃ©tÃ©e. Pour utiliser ce constructeur, appliquez lâ€™attribut 'SetsRequiredMembers'.[La liste des membres requis pour Â«{0}Â» est incorrecte et ne peut pas Ãªtre interprÃ©tÃ©e.‹Une valeur doit Ãªtre affectÃ©e au membre obligatoire '{0}', il ne peut pas utiliser de membre imbriquÃ© ou dâ€™initialiseur de collection.?Les types et alias ne peuvent pas Ãªtre nommÃ©s Â« required Â».gLe nom d'assembly '{0}' est rÃ©servÃ© et ne peut pas servir de rÃ©fÃ©rence dans une session interactiveHLe nom d'Ã©numÃ©rateur '{0}' est rÃ©servÃ© et ne peut pas Ãªtre utilisÃ©Chaque ressource et module liÃ©s doivent avoir un nom de fichier unique. Le nom de fichier '{0}' est indiquÃ© plusieurs fois dans cet assemblyML'identificateur de ressource '{0}' a dÃ©jÃ  Ã©tÃ© utilisÃ© dans cet assembly^Comme '{0}' retourne void, un mot clÃ© return ne doit pas Ãªtre suivi d'une expression d'objet]Une fonction anonyme convertie en dÃ©lÃ©guÃ© retournant void ne peut pas retourner une valeur2Un objet d'un type convertible en '{0}' est requis>'{0}'Â : les chemins du code ne retournent pas tous une valeur¬Impossible de retourner une valeur Ã  partir d'un itÃ©rateur. Utilisez l'instruction yield return pour retourner une valeur, ou yield break pour mettre fin Ã  l'itÃ©ration.WImpossible de modifier la valeur de retour de '{0}' car il ne s'agit pas d'une variableT'{0}'Â : les types static ne peuvent pas Ãªtre utilisÃ©s en tant que types de retour£'{0}'Â : le runtime cible ne prend pas en charge les types covariants dans les substitutions. Le type doit Ãªtre '{2}' pour correspondre au membre substituÃ© '{1}'·'{0}'Â : le runtime cible ne prend pas en charge les types de retour covariants dans les substitutions. Le type de retour doit Ãªtre '{2}' pour correspondre au membre substituÃ© '{1}'RLe runtime cible ne prend pas en charge l'implÃ©mentation d'interface par dÃ©faut.¥'{0}' ne peut pas implÃ©menter le membre d'interface '{1}' dans le type '{2}', car le runtime cible ne prend pas en charge l'implÃ©mentation d'interface par dÃ©faut.ŠLe runtime cible ne prend pas en charge l'accessibilitÃ© 'protected', 'protected internal' ou 'private protected' d'un membre d'interface.BLe runtime cible ne prend pas en charge les champs de rÃ©fÃ©rence.\Le runtime cible ne prend pas en charge les membres abstraits statiques dans les interfaces.¯'{0}' ne peut pas implÃ©menter le membre d'interface '{1}' dans le type '{2}', car le runtime cible ne prend pas en charge les membres abstraits statiques dans les interfaces.{Le runtime cible ne prend pas en charge les conventions d'appel par dÃ©faut des environnements extensibles ou d'exÃ©cution.(Le type '{1}' existe dans '{0}' et '{2}'NL'espace de noms '{1}' dans '{0}' est en conflit avec le type '{3}' dans '{2}'NLe type '{1}' dans '{0}' est en conflit avec l'espace de noms '{3}' dans '{2}'GLe modificateur Â«Â ScopedÂ Â» ne peut pas Ãªtre utilisÃ© avec discard.dLe modificateur 'scoped' du paramÃ¨tre '{0}' ne correspond pas au membre substituÃ© ou implÃ©mentÃ©.hLe modificateur 'scoped' du paramÃ¨tre '{0}' ne correspond pas Ã  la dÃ©claration de mÃ©thode partielle.NLe modificateur 'scoped' du paramÃ¨tre '{0}' ne correspond pas au '{1}' cible.XLe modificateur 'scoped' ne peut Ãªtre utilisÃ© que pour les valeurs refs et ref struct.9Les types et alias ne peuvent pas Ãªtre nommÃ©s 'scoped'.cLes membres requis ne sont pas autorisÃ©s au niveau supÃ©rieur dâ€™un script ou dâ€™une soumission.P'{0}' ne peut pas Ãªtre sealed, car l'enregistrement contenant n'est pas sealed.G'{0}' ne peut pas Ãªtre sealed, car il ne s'agit pas d'une substitution>'{0}'Â : un type ne peut pas Ãªtre Ã  la fois static et sealedKL'attribut de sÃ©curitÃ© '{0}' a une valeur SecurityAction '{1}' non validejLa valeur SecurityAction '{0}' n'est pas valide pour les attributs de sÃ©curitÃ© appliquÃ©s Ã  un assemblyyLa valeur SecurityAction '{0}' n'est pas valide pour les attributs de sÃ©curitÃ© appliquÃ©s Ã  un type ou Ã  une mÃ©thode¸L'attribut de sÃ©curitÃ© '{0}' n'est pas valide dans ce type de dÃ©claration. Les attributs de sÃ©curitÃ© ne sont valides que dans les dÃ©clarations d'assembly, de type et de mÃ©thode.SLe premier argument d'un attribut de sÃ©curitÃ© doit Ãªtre un SecurityAction valideLImpossible d'appliquer l'attribut de sÃ©curitÃ© '{0}' Ã  une mÃ©thode Async.›Les mÃ©thodes Async ne sont pas autorisÃ©es dans une interface, une classe ou une structure qui a un attribut 'SecurityCritical' ou 'SecuritySafeCritical'.{ ou ; attendu{ ou ; ou => attendu	; attenduTLe fichier de clÃ© '{0}' ne comprend pas la clÃ© privÃ©e nÃ©cessaire Ã  la signature6Le membre d'enregistrement '{0}' doit retourner '{1}'.pImpossible de spÃ©cifier /main s'il existe une unitÃ© de compilation avec des instructions de niveau supÃ©rieur.EAu moins une instruction de niveau supÃ©rieur ne doit pas Ãªtre vide.Impossible d'utiliser une variable locale ou une fonction locale '{0}' dÃ©clarÃ©e dans une instruction de niveau supÃ©rieur dans ce contexte.QUne seule unitÃ© de compilation peut avoir des instructions de niveau supÃ©rieur.YLe programme qui utilise des instructions de niveau supÃ©rieur doit Ãªtre un exÃ©cutable.ÍUn modÃ¨le de dÃ©construction d'un seul Ã©lÃ©ment nÃ©cessite une autre syntaxe pour la dÃ©sambiguÃ¯sation. Il est recommandÃ© d'ajouter un dÃ©signateur d'abandon '_' aprÃ¨s la parenthÃ¨se de fermeture ')'.[Un commentaire sur une seule ligne ne doit pas Ãªtre utilisÃ© dans une chaÃ®ne interpolÃ©e.€Le nom de type ou d'espace de noms '{0}' est introuvable (vous manque-t-il une directive using ou une rÃ©fÃ©rence d'assemblyÂ ?)|Le nom de type '{0}' est introuvable. Ce type a Ã©tÃ© transmis Ã  l'assembly '{1}'. Ajoutez une rÃ©fÃ©rence Ã  cet assembly.~Dans la mesure oÃ¹ '{0}' n'a aucune taille prÃ©dÃ©finie, sizeof peut uniquement Ãªtre utilisÃ© dans un contexte non sÃ©curisÃ©@Les rÃ©fÃ©rences du fichier source ne sont pas prises en charge.]Le commutateur /sourcelink est uniquement pris en charge durant l'Ã©mission d'un fichier PDB.“Impossible d'utiliser une instance de type '{0}' dans une fonction imbriquÃ©e, une expression de requÃªte, un bloc itÃ©rateur ou une mÃ©thode async9La contrainte ne peut pas Ãªtre la classe spÃ©ciale '{0}'YLa conversion d'une expression stackalloc de type '{0}' en type '{1}' n'est pas possible.?stackalloc ne peut Ãªtre utilisÃ© dans un bloc catch ou finallymUne expression lambda avec un corps d'instruction ne peut pas Ãªtre convertie en arborescence de l'expression:Le membre d'enregistrement '{0}' ne peut pas Ãªtre static.VUne fonction anonyme statique ne peut pas contenir de rÃ©fÃ©rence Ã  'this' ou 'base'.KUne fonction anonyme statique ne peut pas contenir de rÃ©fÃ©rence Ã  '{0}'.C'{1}'Â : dÃ©rivation impossible Ã  partir de la classe static '{0}'D'{0}'Â : les classes static ne peuvent pas implÃ©menter d'interfacesB'{0}'Â : un constructeur statique ne doit pas avoir de paramÃ¨tres:La constante '{0}' ne peut pas Ãªtre marquÃ©e comme staticZ'{0}'Â : les modificateurs d'accÃ¨s ne sont pas autorisÃ©s sur les constructeurs statiquesf'{0}'Â : un constructeur statique ne peut pas avoir d'appel de constructeur 'this' ou 'base' explicitejLa classe static '{0}' ne peut pas dÃ©river du type '{1}'. Les classes static doivent dÃ©river d'un objet.UUne fonction locale statique ne peut pas contenir de rÃ©fÃ©rence Ã  'this' ou 'base'.JUne fonction locale statique ne peut pas contenir de rÃ©fÃ©rence Ã  '{0}'.>Le membre statique '{0}' ne peut pas Ãªtre marquÃ© 'readonly'.\Impossible d'assigner le champ ou la propriÃ©tÃ© statique '{0}' dans un initialiseur d'objet>Un membre statique ne peut pas Ãªtre marquÃ© comme Â«Â {0}Â Â»rL'argument stdin '-' est spÃ©cifiÃ©, mais l'entrÃ©e n'a pas Ã©tÃ© redirigÃ©e Ã  partir du flux d'entrÃ©e standard..La chaÃ®ne doit commencer par le guillemet : "aUn 'struct' avec des initialiseurs de champ doit inclure un constructeur explicitement dÃ©clarÃ©.cLe membre '{0}' de la structure de type '{1}' engendre un cycle dans la disposition de la structurerLe paramÃ¨tre de constructeur principal struct '{0}' de type '{1}' provoque un cycle dans la disposition du structIL'attribut FieldOffset n'est pas autorisÃ© sur des champs static ou constxL'attribut FieldOffset ne peut Ãªtre placÃ© que sur des membres de types marquÃ©s avec StructLayout(LayoutKind.Explicit)O'{0}'Â : les structs ne peuvent pas appeler les constructeurs de classe de baseKUne sous-expression ne peut pas Ãªtre utilisÃ©e dans un argument de nameof.’Le modÃ¨le est inaccessible. Il a dÃ©jÃ  Ã©tÃ© traitÃ© par un bras prÃ©cÃ©dent de l'expression switch ou la mise en correspondance est impossible.ŒL'instruction switch case est inaccessible. Elle a dÃ©jÃ  Ã©tÃ© traitÃ©e par un cas prÃ©cÃ©dent ou la mise en correspondance est impossible.9Il n'existe aucun meilleur type pour l'expression switch.9L'expression switch doit Ãªtre une valeur. '{0}' trouvÃ©.\Le contrÃ´le ne peut pas sortir du commutateur Ã  partir de l'Ã©tiquette case finale ('{0}')JLe contrÃ´le ne peut pas passer d'une Ã©tiquette case ('{0}') Ã  une autreLDes parenthÃ¨ses sont obligatoires autour de l'expression rÃ©gissant switch.SErreur de syntaxe de ligne de commandeÂ : ':<numÃ©ro>' manquant pour l'option '{0}'LErreur de syntaxe de ligne de commandeÂ : '{0}' manquant pour l'option '{1}'R'MethodImplOptions.Synchronized' ne peut pas Ãªtre appliquÃ© Ã  une mÃ©thode async Erreur de syntaxe, '{0}' attendudImpossible d'utiliser System.Void dans C#Â : utilisez typeof(void) pour obtenir l'objet de type void‘Comme Â«Â {0}Â Â» est une mÃ©thode asynchrone qui renvoie Â«Â {1}Â Â», un mot clÃ© de retour ne doit pas Ãªtre suivi dâ€™une expression dâ€™objeteUne expression lambda convertie en dÃ©lÃ©guÃ© retournant Â«Â {0}Â Â» ne peut pas retourner une valeur?Le mot clÃ© 'this' n'est pas disponible dans le contexte actuel{Le mot clÃ© 'this' n'est pas valide dans un initialiseur de propriÃ©tÃ© statique, de mÃ©thode statique ou de champ statique!Mot clÃ© 'this' ou 'base' attenduşLes mÃ©thodes anonymes, les expressions lambda, les expressions de requÃªte et les fonctions locales contenues dans les structs ne peuvent pas accÃ©der aux membres d'instance de 'this'. Copiez 'this' dans une variable locale en dehors de la mÃ©thode anonyme, de l'expression lambda ou de l'expression de requÃªte ou de la fonction locale, et utilisez la variable locale Ã  la place.;Une expression throw n'est pas autorisÃ©e dans ce contexte.XDes clauses Catch ne peuvent pas suivre la clause catch gÃ©nÃ©rale d'une instruction try3Trop de caractÃ¨res dans le littÃ©ral de caractÃ¨re§Le littÃ©ral de chaÃ®ne brute interpolÃ©e ne commence pas par suffisamment de caractÃ¨res '$' pour autoriser autant dâ€™accolades fermante consÃ©cutives comme contenu.cSeules sont autorisÃ©es 65Â 534Â variables locales, y compris celles gÃ©nÃ©rÃ©es par le compilateurÄLe littÃ©ral brut interpolÃ© de la chaÃ®ne de caractÃ¨res ne commence pas par un nombre suffisant de caractÃ¨res '$' pour permettre un tel nombre d'accolades ouvrantes consÃ©cutives comme contenu.ÉLe littÃ©ral brut de la chaÃ®ne de caractÃ¨res ne commence pas par un nombre suffisant de caractÃ¨res de guillemets pour autoriser un tel nombre de caractÃ¨res de guillemets consÃ©cutifs comme contenu.La longueur combinÃ©e des chaÃ®nes utilisateur que le programme utilise dÃ©passe la limite autorisÃ©e. Essayez de rÃ©duire le nombre de littÃ©raux de chaÃ®ne.gLes instructions de niveau supÃ©rieur doivent prÃ©cÃ©der les dÃ©clarations d'espace de noms et de type.GUn spÃ©cificateur de format ne doit contenir aucun espace blanc de fin.)SÃ©quence de caractÃ¨res inattendue '...'7Les noms d'Ã©lÃ©ments d'un tuple doivent Ãªtre uniques.8Le nom '{0}' n'identifie pas l'Ã©lÃ©ment de tuple '{1}'.ªImpossible de dÃ©finir une classe ou un membre qui utilise des tuples, car le type '{0}' nÃ©cessaire au compilateur est introuvable. Une rÃ©fÃ©rence est-elle manquanteÂ ?RLes noms d'Ã©lÃ©ment tuple ne sont pas autorisÃ©s Ã  gauche d'une dÃ©construction.ŸLe nom d'Ã©lÃ©ment de tuple '{0}' est dÃ©duit. Utilisez la version de langage {1} ou une version supÃ©rieure pour accÃ©der Ã  un Ã©lÃ©ment par son nom dÃ©duit.NLe nom d'Ã©lÃ©ment de tuple '{0}' est uniquement autorisÃ© Ã  la position {1}.GLe nom d'Ã©lÃ©ment de tuple '{0}' est interdit Ã  toutes les positions.ÛLes types de tuple utilisÃ©s en tant qu'opÃ©randes d'un opÃ©rateur == ou != doivent avoir des cardinalitÃ©s correspondantes. Toutefois, cet opÃ©rateur a des types de tuple de cardinalitÃ© {0} Ã  gauche et {1} Ã  droite.0Le tuple doit contenir au moins deux Ã©lÃ©ments.1'{1}' ne dÃ©finit pas le paramÃ¨tre de type '{0}'=Impossible d'utiliser le {1} '{0}' avec des arguments de typeÊLes contraintes 'class', 'struct', 'unmanaged', 'notnull' et 'default' ne peuvent pas Ãªtre combinÃ©es ou dupliquÃ©es. De plus, elles doivent Ãªtre spÃ©cifiÃ©es en premier dans la liste des contraintes.Type attenduhLe module '{0}' dans l'assembly '{1}' transfÃ¨re le type '{2}' Ã  plusieurs assemblysÂ : '{3}' et '{4}'.\Impossible de dÃ©duire le type de la variable de dÃ©construction implicitement typÃ©e '{0}'.QImpossible de dÃ©duire le type de variable de sortie implicitement typÃ©e. '{0}'.FÂ«Â {0}Â Â» nâ€™est pas un type de gestionnaire de chaÃ®ne interpolÃ©.MLe type '{0}' doit Ãªtre public pour Ãªtre utilisÃ© comme convention d'appel. Le type '{0}' n'est pas dÃ©fini.QLa dÃ©claration du paramÃ¨tre de type doit Ãªtre un identificateur et non un typeAL'utilisation du nom de type '{0}' est rÃ©servÃ©e au compilateur.”Impossible de convertir null en paramÃ¨tre de type '{0}' parce qu'il peut s'agir d'un type valeur non-nullable. Utilisez 'default({0})' Ã  la place.wLe mot clÃ© contextuel 'var' ne peut apparaÃ®tre que dans une dÃ©claration de variable locale ou dans un script de codedLe mot clÃ© contextuel 'var' ne peut pas Ãªtre utilisÃ© dans une dÃ©claration de variable de portÃ©eOLe paramÃ¨tre de type '{0}' a le mÃªme nom que le type conteneur ou la mÃ©thodedLe premier opÃ©rande d'un opÃ©rateur "as" ne peut pas Ãªtre un littÃ©ral de tuple sans type naturel.şLa propriÃ©tÃ© implÃ©mentÃ©e automatiquement '{0}' doit Ãªtre entiÃ¨rement affectÃ©e avant que le contrÃ´le soit retournÃ© Ã  lâ€™appelant. Envisagez de mettre Ã  jour la version de langue Â«{1}Â» pour dÃ©finir automatiquement la propriÃ©tÃ© par dÃ©faut.ÔLe champ '{0}' doit Ãªtre entiÃ¨rement attribuÃ© avant que le contrÃ´le soit retournÃ© Ã  lâ€™appelant. Envisagez de mettre Ã  jour la version de langue Â«{1}Â» pour dÃ©finir automatiquement le champ par dÃ©faut.=Impossible de modifier le rÃ©sultat d'une conversion unboxingRDÃ©limiteur de fin '}' manquant pour l'expression interpolÃ©e qui dÃ©bute par '{'.tUn caractÃ¨re '{0}' doit faire l'objet d'une sÃ©quence d'Ã©chappement (par doublement) dans une chaÃ®ne interpolÃ©e.0Utilisation inattendue d'un nom dotÃ© d'un aliasListe d'arguments inattendue.FLes arguments de type ne sont pas autorisÃ©s dans l'opÃ©rateur nameof.CaractÃ¨re inattendu '{0}'&Directive de prÃ©processeur inattendue+Utilisation inattendue d'un nom gÃ©nÃ©riquevUn constructeur dÃ©clarÃ© dans un type avec une liste de paramÃ¨tres doit avoir 'this' initialisateur de constructeur. Liste de paramÃ¨tres inattendue.BPoint-virgule non valide aprÃ¨s un bloc de mÃ©thode ou d'accesseurJeton inattendu '{0}'8Utilisation inattendue d'un nom gÃ©nÃ©rique indÃ©pendanteVariance non valideÂ : le paramÃ¨tre de type '{1}' doit Ãªtre un {3} valide sur '{0}'. '{1}' est {2}.¯Variance non valideÂ : le paramÃ¨tre de type '{1}' doit Ãªtre {3} valide sur '{0}' sauf si la version de langage '{4}' ou une version supÃ©rieure est utilisÃ©e. '{1}' est {2}.y'{0}' ne peut pas implÃ©menter '{1}' et '{2}', car ils peuvent Ãªtre rÃ©unis pour des substitutions de paramÃ¨tre de type9'{0}' n'implÃ©mente pas le membre abstrait hÃ©ritÃ© '{1}'L'{0}' n'implÃ©mente pas le membre d'interface '{1}'. '{2}' n'est pas public.3'{0}' n'implÃ©mente pas le membre d'interface '{1}'b'{0}'Â : impossible de spÃ©cifier Ã  la fois une classe de contrainte et la contrainte 'unmanaged'®Les mÃ©thodes ayant pour attribut 'UnmanagedCallersOnly' ne peuvent pas avoir de paramÃ¨tres de type gÃ©nÃ©rique et ne peuvent pas Ãªtre dÃ©clarÃ©es dans un type gÃ©nÃ©rique.'{0}' est attribuÃ© avec 'UnmanagedCallersOnly' et ne peut pas Ãªtre appelÃ© directement. Obtenez un pointeur de fonction vers cette mÃ©thode.–'{0}' est attribuÃ© avec 'UnmanagedCallersOnly' et ne peut pas Ãªtre converti en type dÃ©lÃ©guÃ©. Obtenez un pointeur de fonction vers cette mÃ©thode.¡'UnmanagedCallersOnly' ne peut Ãªtre appliquÃ© quâ€™Ã  des mÃ©thodes statiques non abstraites ou non virtuelles ordinaires ou Ã  des fonctions locales statiques.ßLe type '{2}' doit Ãªtre un type valeur non-nullable, ainsi que l'ensemble des champs Ã  tous les niveaux d'imbrication, pour pouvoir Ãªtre utilisÃ© en tant que paramÃ¨tre '{1}' dans le type ou la mÃ©thode gÃ©nÃ©rique '{0}'hUne clause catch prÃ©cÃ©dente intercepte dÃ©jÃ  toutes les exceptions de this ou d'un super type ('{0}')e'{0}' est dÃ©fini dans un module avec une version RefSafetyRulesAttribute non reconnue, '11' attendu.NLes mÃ©thodes ne peuvent pas avoir de paramÃ¨tres unsafe ou de types de retourLLes itÃ©rateurs ne peuvent pas avoir de paramÃ¨tres unsafe ou de types yieldlLes pointeurs et les mÃ©moires tampons de taille fixe ne peuvent Ãªtre utilisÃ©s que dans un contexte unsafeDImpossible d'utiliser le type unsafe '{0}' dans la crÃ©ation d'objetVUnscopedRefAttribute ne peut pas Ãªtre appliquÃ© Ã  une implÃ©mentation dâ€™interface.»UnscopedRefAttribute peut uniquement Ãªtre appliquÃ© aux mÃ©thodes et propriÃ©tÃ©s dâ€™instance de struct, et ne peut pas Ãªtre appliquÃ© aux constructeurs ou aux membres init uniquement.jImpossible dâ€™appliquer UnscopedRefAttribute Ã  ce paramÃ¨tre, car il nâ€™a pas dâ€™Ã©tendue par dÃ©faut.bUnscopedRefAttribute ne peut pas Ãªtre appliquÃ© aux paramÃ¨tres qui ont un modificateur 'scoped'.HLa convention d'appel de '{0}' n'est pas prise en charge par le langage.~'{0}' nÃ©cessite la fonctionnalitÃ© de compilateur '{1}', qui nâ€™est pas prise en charge par cette version du compilateur C#.‡Impossible dâ€™utiliser le paramÃ¨tre de constructeur principal '{0}' avec ref, out ou in Ã  lâ€™intÃ©rieur dâ€™un membre dâ€™instance. Nous nâ€™avons pas pu utiliser le paramÃ¨tre de constructeur principal '{0}' qui a un type de rÃ©fÃ©rence similaire Ã  lâ€™intÃ©rieur dâ€™un membre dâ€™instance Ã‰chec de l'accÃ¨s de membre Ã  identificateur transparent pour le champ '{0}' de '{1}'. Les donnÃ©es interrogÃ©es implÃ©mentent-elles le modÃ¨le de requÃªteÂ ?SLes modÃ¨les de liste ne peuvent pas Ãªtre utilisÃ©s pour une valeur de type '{0}'.WLes modÃ¨les relationnels ne peuvent pas Ãªtre utilisÃ©s pour une valeur de type '{0}'.ULes modÃ¨les de tranche ne peuvent pas Ãªtre utilisÃ©s pour une valeur de type '{0}'.%LittÃ©ral de chaÃ®ne brute inachevÃ©.LittÃ©ral de chaÃ®ne inachevÃ©5Utilisation d'une variable locale non assignÃ©e '{0}'9Utilisation d'un champ potentiellement non assignÃ© '{0}'·Utilisation dâ€™un '{0}' de champ Ã©ventuellement non attribuÃ©. Envisagez de mettre Ã  jour vers la version de langage '{1}' pour utiliser la valeur par dÃ©faut automatique du champ.0Utilisation du paramÃ¨tre out non assignÃ© '{0}'bUtilisation d'une propriÃ©tÃ© implÃ©mentÃ©e automatiquement Ã©ventuellement non assignÃ©eÂ : '{0}'ÕUtilisation de la propriÃ©tÃ© implÃ©mentÃ©e automatiquement Â«{0}Â» Ã©ventuellement non assignÃ©e. Envisagez de mettre Ã  jour la version de langue Â«{1}Â» pour dÃ©finir automatiquement la propriÃ©tÃ© par dÃ©faut.ÔImpossible dâ€™utiliser lâ€™objet 'this' avant lâ€™affectation de tous ses champs. Envisagez de mettre Ã  jour vers la version de langage '{0}' pour dÃ©finir automatiquement les champs non attribuÃ©s par dÃ©faut.€Une clause using doit prÃ©cÃ©der tous les autres Ã©lÃ©ments dÃ©finis dans l'espace de noms sauf les dÃ©clarations d'alias externgImpossible d'utiliser une variable using directement dans une section switch (utilisez des accolades). ¨Une expression switch ou une Ã©tiquette case doit Ãªtre de type bool, char, string, integral, enum ou Nullable correspondant en C#Â 6 et dans les versions antÃ©rieures.Le type '{2}' doit Ãªtre un type valeur non-nullable afin d'Ãªtre utilisÃ© comme paramÃ¨tre '{1}' dans le type ou la mÃ©thode gÃ©nÃ©rique '{0}'VImpossible de convertir null en '{0}' parce qu'il s'agit d'un type valeur non-nullable#Erreur de syntaxe ; valeur attenduexLa mÃ©thode d'extension '{0}' dÃ©finie dans le type valeur '{1}' ne peut pas Ãªtre utilisÃ©e pour crÃ©er des dÃ©lÃ©guÃ©sLes membres de la propriÃ©tÃ© '{0}' de type '{1}' ne peuvent pas Ãªtre assignÃ©s avec un initialiseur d'objet, car il s'agit d'un type valeurfUne arborescence d'expression lambda ne peut pas contenir une mÃ©thode avec des arguments de variables9Impossible de dÃ©clarer une variable de type static '{0}'9La syntaxe 'var (...)' en tant que lvalue est rÃ©servÃ©e.wLa syntaxe 'var' d'un modÃ¨le n'est pas autorisÃ©e Ã  faire rÃ©fÃ©rence Ã  un type, mais '{0}' est dans l'Ã©tendue ici.M__arglist n'est pas autorisÃ© dans la liste de paramÃ¨tres de mÃ©thodes asyncJ__arglist n'est pas autorisÃ© dans la liste de paramÃ¨tres des itÃ©rateursaLe paramÃ¨tre __arglist doit Ãªtre le dernier paramÃ¨tre spÃ©cifiÃ© dans une liste de paramÃ¨tresPImpossible d'utiliser la variable locale '{0}' tant qu'elle n'est pas dÃ©clarÃ©eImpossible d'utiliser la variable locale '{0}' tant qu'elle n'est pas dÃ©clarÃ©e. La dÃ©claration de la variable locale masque le champ '{1}'.ŠLes enums, les classes et les structures ne peuvent pas Ãªtre dÃ©clarÃ©s dans une interface contenant un paramÃ¨tre de type 'in' ou 'out'.E'{0}'Â : les membres virtual ou abstract ne peuvent pas Ãªtre private0Impossible d'assigner une valeur de type 'void'.BL'opÃ©ration en question n'est pas dÃ©finie sur les pointeurs void7Un tuple ne doit pas contenir de valeur de type 'void'.C'{0}'Â : un champ ne peut pas Ãªtre Ã  la fois volatile et readonly:'{0}'Â : un champ volatile ne peut pas Ãªtre de type '{1}'TUn Ã©vÃ©nement Windows Runtime ne peut pas Ãªtre passÃ© comme paramÃ¨tre out ou ref.«Un type de retour de type tÃ¢che gÃ©nÃ©rique est attendu, mais le type Â«Â {0}Â Â» trouvÃ© dans lâ€™attribut â€™AsyncMethodBuilderâ€™ nâ€™Ã©tait pas appropriÃ©. Il doit sâ€™agir dâ€™un type gÃ©nÃ©rique indÃ©pendant dâ€™aritÃ© One, et son type conteneur (le cas Ã©chÃ©ant) doit Ãªtre non gÃ©nÃ©rique.?La convention d'appel de '{0}' n'est pas compatible avec '{1}'.~La correspondance avec le type de tuple '{0}' nÃ©cessite des sous-modÃ¨les '{1}', mais des sous-modÃ¨les '{2}' sont prÃ©sents.bL'instruction yield ne peut pas Ãªtre utilisÃ©e dans une mÃ©thode anonyme ou une expression lambdaIImpossible d'utiliser 'yield' dans du code de script de niveau supÃ©rieur3Les Ã©lÃ©ments ne peuvent pas avoir la valeur null.#Algorithme '{0}' non pris en charge;La page de '{0}' n'est pas correcte ou n'est pas installÃ©eLErreur inattendue lors de l'Ã©criture des informations de dÃ©bogage -- '{0}'‰Le nom de fichier '{0}' est vide, contient des caractÃ¨res non valides, spÃ©cifie un lecteur sans chemin d'accÃ¨s absolu ou est trop longeType de cible non valide pour /targetÂ : vous devez spÃ©cifier 'exe', 'winexe', 'library' ou 'module'<Impossible d'ouvrir le fichier de mÃ©tadonnÃ©es '{0}' -- {1}‚Impossible de crÃ©er le nom de fichier court '{0}', car il existe dÃ©jÃ  un nom de fichier long avec ce mÃªme nom de fichier courtULe paramÃ¨tre gÃ©nÃ©rique est definition alors que la rÃ©fÃ©rence attendue Ã©tait {0}QLa directive using pour Â«Â {0}Â Â» est apparue prÃ©cÃ©demment comme using global@La directive using est apparue prÃ©cÃ©demment comme using globalAlias extern non utilisÃ©.Alias extern non utilisÃ© Directive using non nÃ©cessaire.Directive using non nÃ©cessaire>{0} n'est pas une opÃ©ration d'assignation composÃ©e C# valide4{0} n'est pas une expression de conversion C# valide&groupe de mÃ©thodesmÃ©thode anonymeaccÃ¨s au tableau3Remplacement du gÃ©nÃ©rateur de mÃ©thode asynchrone2attendre dans des blocs catch et des blocs finally‰X
                             Options du compilateur VisualÂ C#

                       -Â FICHIERS DE SORTIEÂ -
-out:<fichier>                SpÃ©cifier un nom de fichier de sortie (par dÃ©fautÂ : nom de base du
                              fichier avec classe principale ou premier fichier)
-target:exe                   GÃ©nÃ©rer un fichier exÃ©cutable console (par dÃ©faut) (forme
                              abrÃ©gÃ©eÂ : -t:exe)
-target:winexe                GÃ©nÃ©rer un fichier exÃ©cutable Windows (forme abrÃ©gÃ©eÂ :
                              -t:winexe)
-target:library               GÃ©nÃ©rer une bibliothÃ¨que (forme abrÃ©gÃ©eÂ : -t:library)
-target:module                GÃ©nÃ©rer un module qui peut Ãªtre ajoutÃ© Ã  un autre
                              assembly (forme abrÃ©gÃ©eÂ : -t:module)
-target:appcontainerexe       GÃ©nÃ©rer un exÃ©cutable Appcontainer (forme abrÃ©gÃ©eÂ :
                              -t:appcontainerexe)
-target:winmdobj              GÃ©nÃ©rer un fichier intermÃ©diaire Windows Runtime
                              consommÃ© par WinMDExp (forme abrÃ©gÃ©eÂ : -t:winmdobj)
-doc:<fichier>                Fichier de documentation XML Ã  gÃ©nÃ©rer
-refout:<fichier>             Sortie de l'assembly de rÃ©fÃ©rence Ã  gÃ©nÃ©rer
-platform:<chaÃ®ne>            Limiter les plateformes sur lesquelles ce code peut s'exÃ©cuterÂ : x86,
                              Itanium, x64, arm, arm64, anycpu32bitpreferred ou
                              anycpu. La valeur par dÃ©faut estÂ anycpu.

                       -Â FICHIERS D'ENTRÃ‰EÂ -
-recurse:<gÃ©nÃ©rique>          Inclure tous les fichiers dans le rÃ©pertoire et
                              les sous-rÃ©pertoires actifs en fonction des
                              spÃ©cifications de caractÃ¨res gÃ©nÃ©riques
-reference:<alias>=<fichier>  RÃ©fÃ©rencer les mÃ©tadonnÃ©es Ã  partir du
                              fichier d'assembly spÃ©cifiÃ© via l'alias indiquÃ© (forme abrÃ©gÃ©eÂ : -r)
-reference:<liste_fichiers>   RÃ©fÃ©rencer les mÃ©tadonnÃ©es Ã  partir
                              des fichiers d'assembly spÃ©cifiÃ©s (forme abrÃ©gÃ©eÂ : -r)
-addmodule:<liste_fichiers>   Lier les modules spÃ©cifiÃ©s dans cet assembly
-link:<liste_fichiers>        Incorporer les mÃ©tadonnÃ©es Ã  partir des
                              fichiers d'assembly d'interopÃ©rabilitÃ© spÃ©cifiÃ©s (forme abrÃ©gÃ©eÂ : -l)
-analyzer:<liste_fichiers>    ExÃ©cuter les analyseurs Ã  partir de cet assembly
                              (Forme abrÃ©gÃ©eÂ : -a)
-additionalfile:<liste_fich.> Fichiers supplÃ©mentaires qui n'affectent pas directement
                              la gÃ©nÃ©ration de code mais qui peuvent Ãªtre utilisÃ©s par les analyseurs pour produire
                              des erreurs ou des avertissements.
-embed                        Incorporer tous les fichiers sources dans le fichier PDB.
-embed:<liste_fichiers>       Incorporer des fichiers spÃ©cifiques dans le fichier PDB.

                       -Â RESSOURCESÂ -
-win32res:<fichier>           SpÃ©cifier un fichier de ressources Win32 (.res)
-win32icon:<fichier>          Utiliser cette icÃ´ne pour la sortie
-win32manifest:<fichier>      SpÃ©cifier un fichier manifeste (.xml) Win32
-nowin32manifest              Ne pas inclure le manifeste Win32 par dÃ©faut
-resource:<resinfo>           Incorporer la ressource spÃ©cifiÃ©e (forme abrÃ©gÃ©eÂ : -res)
-linkresource:<resinfo>       Lier la ressource spÃ©cifiÃ©e Ã  cet assembly
                              (forme abrÃ©gÃ©eÂ : -linkres), oÃ¹ le format resinfo
                              est <fichier>[,<nom_chaÃ®ne>[,public|private]]

                       -Â GÃ‰NÃ‰RATION DE CODEÂ -
-debug[+|-]                   Ã‰mettre des informations de dÃ©bogage
-debug:{full|pdbonly|portable|embedded}
                              SpÃ©cifier le type de dÃ©bogage ('full' est la valeur par dÃ©faut,
                              'portable' est un format multiplateforme,
                              'embedded' est un format multiplateforme incorporÃ© dans
                              le fichier .dll ou .exe cible)
-optimize[+|-]                Activer les optimisations (forme abrÃ©gÃ©eÂ : -o)
-deterministic                Produire un assembly dÃ©terministe
                              (en incluant le GUID et l'horodatage de la version du module)
-refonly                      Produire un assembly de rÃ©fÃ©rence Ã  la place de la sortie principale
-instrument:TestCoverage      Produire un assembly instrumentÃ© pour collecter
                              les informations de couverture
-sourcelink:<fichier>         Informations du lien source Ã  incorporer dans le fichier PDB.
 
                       -Â ERREURS ET AVERTISSEMENTSÂ -
-warnaserror[+|-]             Signaler tous les avertissements comme des erreurs
-warnaserror[+|-]:<avertiss.> Signaler des avertissements spÃ©cifiques comme des erreurs
                              (utiliser "nullable" pour tous les avertissements de nullabilitÃ©)
-warn:<n>                     DÃ©finir le niveau d'avertissement (0 ou plus) (forme abrÃ©gÃ©eÂ : -w)
-nowarn:<liste avertiss.>     DÃ©sactiver des messages d'avertissement spÃ©cifiques
                              (utiliser "nullable" pour tous les avertissements de nullabilitÃ©)
-ruleset:<fichier>            SpÃ©cifier un fichier ruleset qui dÃ©sactive des
                              diagnostics spÃ©cifiques.
-errorlog:<fichier>[,version=<version_sarif>]
                              SpÃ©cifier un fichier pour journaliser tous les diagnostics du compilateur
                              et de l'analyseur.
                              version_sarifÂ :{1|2|2.1} La valeur par dÃ©faut estÂ 1. 2 et 2.1
                              Les deux signifient SARIF versionÂ 2.1.0.
-reportanalyzer               Signaler des informations supplÃ©mentaires sur l'analyseur, par exemple
                              la durÃ©e d'exÃ©cution.
-skipanalyzers[+|-]           Ignorer l'exÃ©cution des analyseurs de diagnostic.

                       -Â LANGAGEÂ -
-checked[+|-]                 GÃ©nÃ©rer des contrÃ´les de dÃ©passement de capacitÃ©
-unsafe[+|-]                  Autoriser du code 'unsafe'
-define:<liste_symboles>  DÃ©finir les symboles de compilation conditionnelle (forme
                              abrÃ©gÃ©eÂ : -d)
-langversion:?                Afficher les valeurs autorisÃ©es pour la version du langage
-langversion:<chaÃ®ne>         SpÃ©cifier la version du langage, par exemple
                              'latest' (derniÃ¨re version, en incluant les versions mineures),
                              'default' (identique Ã  'latest'),
                              'latestmajor' (derniÃ¨re version, en excluant les versions mineures),
                              'preview' (derniÃ¨re version, en incluant les fonctionnalitÃ©s de la prÃ©version non prise en charge),
                              ou des versions spÃ©cifiques commeÂ '6' ouÂ '7.1'
-nullable[+|-]                SpÃ©cifier l'option de contexte nullable enable|disable.
-nullable:{enable|disable|warnings|annotations}
                              SpÃ©cifier l'option de contexte nullable enable|disable|warnings|annotations.

                       -Â SÃ‰CURITÃ‰Â -
-delaysign[+|-]               DiffÃ©rer la signature de l'assembly en utilisant uniquement
                              la partie publique de la clÃ© de nom fort
-publicsign[+|-]              Signer publiquement l'assembly en utilisant uniquement
                              la partie publique de la clÃ© de nom fort
-keyfile:<fichier>            SpÃ©cifier un fichier de clÃ© de nom fort
-keycontainer:<chaÃ®ne>        SpÃ©cifier un conteneur de clÃ© de nom fort
-highentropyva[+|-]           Activer la randomisation du format d'espace d'adresse d'entropie Ã©levÃ©e

                       -Â DIVERSÂ -
@<fichier>                    Lire le fichier rÃ©ponse pour plus d'options
-help                         Afficher ce message d'utilisation (forme abrÃ©gÃ©eÂ : -?)
-nologo                       Supprimer le message de copyright du compilateur
-noconfig                     Ne pas inclure automatiquement un fichier CSC.RSP
-parallel[+|-]                Build simultanÃ©e.
-version                      Afficher le numÃ©ro de version du compilateur et quitter le processus.

                       -Â AVANCÃ‰Â -
-baseaddress:<adresse>        Adresse de base de la bibliothÃ¨que Ã  gÃ©nÃ©rer
-checksumalgorithm:<alg>      SpÃ©cifier l'algorithme de calcul de la somme de contrÃ´le
                              de fichier source stockÃ©e dans le fichier PDB. Valeurs prises en chargeÂ :
                              SHA1 ou SHA256 (par dÃ©faut).
-codepage:<n>                 SpÃ©cifier la page de codes Ã  utiliser Ã  l'ouverture
                              des fichiers sources
-utf8output                   Messages du compilateur de sortie encodÃ©s en UTF-8
-main:<type>                  SpÃ©cifier le type qui contient le point d'entrÃ©e
                              (ignorer tous les autres points d'entrÃ©e possibles) (forme
                              abrÃ©gÃ©eÂ : -m)
-fullpaths                    Le compilateur gÃ©nÃ¨re des chemins complets
-filealign:<n>                SpÃ©cifier l'alignement utilisÃ© pour les
                              sections du fichier de sortie
-pathmap:<K1>=<V1>,<K2>=<V2>,...
                              SpÃ©cifier un mappage pour les noms de chemins sources sortis par
                              le compilateur.
-pdb:<fichier>                SpÃ©cifier le nom du fichier des informations de dÃ©bogage (par dÃ©fautÂ :
                              nom du fichier de sortie avec l'extension .pdb)
-errorendlocation             Ligne et colonne de sortie de l'emplacement final de
                              chaque erreur
-preferreduilang              SpÃ©cifier le nom du langage de sortie prÃ©fÃ©rÃ©.
-nosdkpath                    DÃ©sactiver la recherche du chemin du kit SDK par dÃ©faut pour les assemblys de bibliothÃ¨que standard.
-nostdlib[+|-]                Ne pas rÃ©fÃ©rencer la bibliothÃ¨que standard (mscorlib.dll)
-subsystemversion:<chaÃ®ne>    SpÃ©cifier la version du sous-systÃ¨me de cet assembly
-lib:<liste_fichiers>         SpÃ©cifier des rÃ©pertoires supplÃ©mentaires dans lesquels rechercher les
                              rÃ©fÃ©rences
-errorreport:<chaÃ®ne>         SpÃ©cifier comment prendre en charge les erreurs internes du compilateurÂ :
                              prompt, send, queue ou none. La valeur par dÃ©faut est
                              queue.
-appconfig:<fichier>          SpÃ©cifier un fichier de configuration de l'application
                              contenant des paramÃ¨tres de liaison d'assembly
-moduleassemblyname:<chaÃ®ne>  Nom de l'assembly dont ce module
                              doit faire partie
-modulename:<chaÃ®ne>          SpÃ©cifier le nom du module source
-generatedfilesout:<rÃ©p>      Placer les fichiers gÃ©nÃ©rÃ©s durant la compilation
                              dans le rÃ©pertoire spÃ©cifiÃ©.

collectioncontravariantpar contravariance	covariantpar covariance'implÃ©mentation d'interface par dÃ©fautrÃ©pertoire inexistant'chemin d'accÃ¨s trop long ou non validesupprimable(s)variable fixedvariable d'itÃ©ration foreach.chaÃ®nes verbatim interpolÃ©es de remplacementModÃ¨le andmÃ©thodes anonymestypes anonymesfonction async
async main
flux asyncusing asynchrone(champs de struct par dÃ©faut automatique+propriÃ©tÃ©s automatiquement implÃ©mentÃ©esinitialiseur auto-propertylittÃ©raux binaires3opÃ©rateurs dÃ©finis par lâ€™utilisateur vÃ©rifiÃ©sassignation de fusioninitialiseur de collection chaÃ®nes interpolÃ©es constantesretours covariantsopÃ©rateur par dÃ©fautlittÃ©ral par dÃ©faut-contraintes de paramÃ¨tre de type par dÃ©faut-contraintes de type gÃ©nÃ©rique de dÃ©lÃ©guÃ©initialiseur de dictionnairesÃ©parateurs numÃ©riquesdiscards (Ã©lÃ©ments ignorÃ©s)"Ã©limination basÃ©e sur un modÃ¨le	dynamique&contraintes de type gÃ©nÃ©rique d'enumfiltre d'exception.accesseur de propriÃ©tÃ© du corps d'expression1constructeur et destructeur du corps d'expressionindexeur expression-bodiedmÃ©thode expression-bodiedpropriÃ©tÃ© expression-bodiedYdÃ©claration de variables d'expression dans les initialiseurs de membres et les requÃªtesmÃ©thodes partielles Ã©tendues"modÃ¨les de propriÃ©tÃ©s Ã©tenduesinstruction fixed extensible!GetAsyncEnumerator de l'extensionGetEnumerator de l'extensionmÃ©thode d'extensionalias externfonctions locales externes0espace de noms inclus dans l'Ã©tendue de fichiertypes de fichier mÃ©moires tampons de taille fixepointeurs de fonctionattributs gÃ©nÃ©riquesgÃ©nÃ©riques&qualificateur d'alias d'espace de nomsdirective using globaletableau implicitement typÃ©$variable locale implicitement typÃ©e crÃ©ation d'un objet typÃ© cible&gestionnaires de chaÃ®nes interpolÃ©esopÃ©rateur d'index-indexation de mÃ©moires tampons fixes mobilestype dÃ©lÃ©guÃ© dÃ©duit,mÃ©thodes setter d'initialisation uniquementchaÃ®nes interpolÃ©esitÃ©rateursexpression lambdaattributs lambdaparamÃ¨tres d'abandon lambda,paramÃ¨tres optionnels dâ€™expression lambda0tableau des paramÃ¨tres de lâ€™expression lambdatype de retour lambda sÃ©parateur numÃ©rique de dÃ©butmodÃ¨le de listeattributs de fonction localefonctions localesAttribut MemberNotNullBMÃ©lange de dÃ©clarations et d'expressions dans la dÃ©construction2module en tant que spÃ©cificateur cible d'attributinitialiseurs de module/ombrage des noms dans les fonctions imbriquÃ©esargument nommÃ©opÃ©rateur nameofentiers de taille native+stackalloc dans des expressions imbriquÃ©es&sauts de ligne dans les interpolations&contrainte de type gÃ©nÃ©rique notnullModÃ¨le not%modÃ¨le de constante de pointeur nullopÃ©rateur de propagation nulltypes Nullabletypes rÃ©fÃ©rence Nullableinitialiseur d'objet(obsolÃ¨te sur l'accesseur de propriÃ©tÃ©paramÃ¨tre facultatif
ModÃ¨le or"dÃ©claration de variable de sortie'constructeurs de struct sans paramÃ¨treModÃ¨le entre parenthÃ¨sesmÃ©thode partielletypes partielscritÃ¨res spÃ©ciaux,champs positionnels dans les enregistrements#pragmaaction d'avertissement enableconstructeurs principauxprivate protected+modificateurs d'accÃ¨s sur des propriÃ©tÃ©sexpression de requÃªteopÃ©rateur de plagelittÃ©raux de chaÃ®ne brutemembres readonlyrÃ©fÃ©rences en lecture seulestructs en lecture seule8readonly a implÃ©mentÃ© automatiquement les propriÃ©tÃ©sstructs dâ€™enregistrementenregistrementsmodÃ¨les rÃ©cursifsexpression conditionnelle ref%mÃ©thodes d'extension par rÃ©fÃ©rence
champs ref!variables for loop de rÃ©fÃ©rence-variables d'itÃ©ration foreach de rÃ©fÃ©rence"variables locales et retours byrefrÃ©assignation de rÃ©fÃ©rencestructs par rÃ©fÃ©renceModÃ¨le relationnelopÃ©rateur shift souplemembres obligatoires(ToString scellÃ© dans lâ€™enregistrementFmodÃ¨le correspondant Ã  ReadOnly/Span<char> sur une chaÃ®ne constanteinitialiseur stackalloc/membres abstraits statiques dans les interfacesfonction anonyme statiqueclasses staticfonctions locales statiques initialiseurs de champ de struct<expression switch>commutateur sur type boolÃ©en'expression conditionnelle de type cibleexpression throwÃ©galitÃ© de tupletuplesModÃ¨le typevariance de typeVparamÃ¨tres de type sans contrainte dans un opÃ©rateur de fusion ayant une valeur nulltypes construits non managÃ©s)contraintes de type gÃ©nÃ©rique unmanagedshift droit non signÃ©DÃ©clarations usingusing static utilisation de lâ€™alias de typeLittÃ©raux de chaÃ®ne UTF-8=sÃ©curitÃ© de variance pour les membres d'interface statiquesavec sur les types anonymesavec sur structs<espace de noms global>par invariancevariable d'environnement LIBoption /LIBexpression lambda'Versions de langage prises en chargeÂ :{0} version {1}<Copyright (C) Microsoft Corporation. Tous droits rÃ©servÃ©s.groupe de mÃ©thodes
<manquant><Null><espace de noms>AL'opÃ©ration a provoquÃ© un dÃ©passement de capacitÃ© de la pile.Vcontraintes des mÃ©thodes d'implÃ©mentation d'interface par remplacement et explicites
paramÃ¨tre<liste de chemins d'accÃ¨s>#accÃ¨s Ã  lâ€™Ã©lÃ©ment de pointeuroption /REFERENCEPATH=(Emplacement du symbole par rapport Ã  l'erreur prÃ©cÃ©dente)C(Emplacement du symbole par rapport Ã  l'avertissement prÃ©cÃ©dent)	de retouralias usingconstructeurÃ©vÃ©nementalias externchamp
Ã©tiquettemÃ©thodeespace de nomspropriÃ©tÃ©typeparamÃ¨tre de type	Ã©lÃ©mentvariable<texte><expression throw>#Compilateur Microsoft (R) Visual C#!instructions de niveau supÃ©rieurvariable using'expÃ©rimental' Balise include non valide 9 Impossible d'insÃ©rer tout ou partie du code XML inclus :<!-- Badly formed XML comment ignored for member "{0}" -->5 Impossible d'inclure le fichier XML "{0}" incorrect Attribut file manquantAttribut path manquantQ Aucun Ã©lÃ©ment correspondant n'a Ã©tÃ© trouvÃ© pour la balise include suivante zCertains types contenus dans l'assembly analyseur {0} ont Ã©tÃ© ignorÃ©s pour cause de ReflectionTypeLoadExceptionÂ : {1}.yIgnorer le chargement de types dans un assembly dâ€™analyseur qui Ã©chouent en raison dâ€™une ReflectionTypeLoadExceptionuGetDeclarationName appelÃ© pour un nÅ“ud de dÃ©claration susceptible de contenir plusieurs dÃ©clarateurs de variable.(Ã©lÃ©mentsÂ : ne doivent pas Ãªtre videsRL'emplacement doit Ãªtre indiquÃ© pour fournir une qualification de type minimale.4LookupOptions a une combinaison d'options non valideConflit de noms pour le nom {0}SearchCriteria est attendu.Symbole non C#.{Il existe {0} types de paramÃ¨tre et {1} genres de rÃ©fÃ©rence de paramÃ¨tre. Ces tableaux doivent avoir la mÃªme longueur.N'RefKind.Out' n'est pas un genre de rÃ©fÃ©rence valide pour un type de retour.WLa position ne se trouve pas dans l'Ã©tendue complÃ¨te {0} de l'arborescence de syntaxeILa position doit se trouver dans l'Ã©tendue de l'arborescence de syntaxe.sLe nÅ“ud de syntaxe Ã  extrapoler ne peut pas appartenir Ã  une arborescence de syntaxe de la compilation actuelle.>Une soumission peut avoir au plus une arborescence de syntaxe.5Une soumission ne peut inclure que du code de script.CLe nÅ“ud de syntaxe ne se trouve pas dans l'arborescence de syntaxe(Arborescence de syntaxe dÃ©jÃ  prÃ©sentefLe SyntaxTree rÃ©sulte d'une directive #load, et ne peut pas Ãªtre supprimÃ© ou remplacÃ© directement.HL'arborescence de syntaxe doit Ãªtre crÃ©Ã©e Ã  partir d'une soumission./SyntaxTree ne fait pas partie de la compilationRSyntaxTree ne faisant pas partie de la compilation, il ne peut pas Ãªtre supprimÃ©\SyntaxTreeSemanticModel doit Ãªtre indiquÃ© pour fournir une qualification de type minimale.dCette mÃ©thode ne peut Ãªtre utilisÃ©e que pour crÃ©er des jetons - {0} n'est pas un genre de jeton.Il'arborescence doit avoir un nÅ“ud racine avec SyntaxKind.CompilationUnit3L'argument de type ne peut pas avoir la valeur nulllUtilisez Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Literal pour crÃ©er des jetons de littÃ©ral numÃ©rique.oUtilisez Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Literal pour crÃ©er des jetons de littÃ©ral de caractÃ¨re.ªUtilisez Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Identifier ou Microsoft.CodeAnalysis.CSharp.SyntaxFactory.VerbatimIdentifier pour crÃ©er des jetons d'identificateur.zLâ€™opÃ©rateur '&' ne doit pas Ãªtre utilisÃ© sur les paramÃ¨tres ou les variables locales dans les mÃ©thodes asynchrones.zLâ€™opÃ©rateur '&' ne doit pas Ãªtre utilisÃ© sur les paramÃ¨tres ou les variables locales dans les mÃ©thodes asynchrones.rLa valeur d'alignement {0} a une magnitude supÃ©rieure Ã  {1} et peut gÃ©nÃ©rer une chaÃ®ne formatÃ©e volumineuse.ZLa valeur d'alignement a une magnitude pouvant gÃ©nÃ©rer une chaÃ®ne formatÃ©e volumineuse>Le rÃ©sultat de l'expression est toujours 'null' de type '{0}'0Le rÃ©sultat de l'expression est toujours 'null'‘RÃ©fÃ©rence ambiguÃ« dans l'attribut crefÂ : '{0}'. '{1}' pris par dÃ©faut, mais peut aussi correspondre Ã  d'autres surcharges, notamment '{2}'..La rÃ©fÃ©rence de l'attribut cref est ambiguÃ«MImpossible de crÃ©er une instance de l'analyseur {0} Ã  partir de {1}Â : {2}.=DÃ©solÃ©... Nous ne pouvons pas crÃ©er d'instance d'analyseurhL'assembly '{0}' contenant le type '{1}' rÃ©fÃ©rence le .NET Framework, ce qui n'est pas pris en charge.RL'assembly chargÃ© rÃ©fÃ©rence le .NET Framework, ce qui n'est pas pris en charge.“L'assembly d'analyseur '{0}' fait rÃ©fÃ©rence Ã  la version '{1}' du compilateur, qui est plus rÃ©cente que la version en cours d'exÃ©cution '{2}'.|L'assembly de l'analyseur fait rÃ©fÃ©rence Ã  une version plus rÃ©cente du compilateur que la version en cours d'exÃ©cution.^L'attribut '{0}' du module '{1}' sera ignorÃ© au profit de l'instance prÃ©sente dans la sourceHL'attribut sera ignorÃ© en faveur de l'instance prÃ©sente dans la sourceØAssignation potentiellement incorrecte Ã  la variable locale '{0}', qui est l'argument d'une instruction using ou lock. L'appel Dispose ou le dÃ©verrouillage se produira sur la valeur d'origine de la variable locale.oAssignation potentiellement incorrecte Ã  la variable locale qui est l'argument d'une instruction using ou lock]Assignation effectuÃ©e Ã  la mÃªme variableÂ ; souhaitiez-vous assigner un autre Ã©lÃ©mentÂ ?+Assignation effectuÃ©e Ã  la mÃªme variableCette mÃ©thode async n'a pas d'opÃ©rateur 'await' et elle s'exÃ©cutera de faÃ§on synchrone. Utilisez l'opÃ©rateur 'await' pour attendre les appels d'API non bloquants ou 'await Task.Run(â€¦)' pour effectuer un travail utilisant le processeur sur un thread d'arriÃ¨re-plan.ZCette mÃ©thode async n'a pas d'opÃ©rateur 'await' et elle s'exÃ©cutera de faÃ§on synchrone~Le type Â«Â {0}Â Â» ne peut pas Ãªtre utilisÃ© dans ce contexte, car il ne peut pas Ãªtre reprÃ©sentÃ© dans les mÃ©tadonnÃ©es.rLe type ne peut pas Ãªtre utilisÃ© dans ce contexte, car il ne peut pas Ãªtre reprÃ©sentÃ© dans les mÃ©tadonnÃ©es.JL'attribut '{0}' est ignorÃ© quand une signature publique est spÃ©cifiÃ©e.DL'attribut est ignorÃ© quand une signature publique est spÃ©cifiÃ©e.Á'{0}' n'est pas un emplacement d'attribut valide pour cette dÃ©claration. Les emplacements d'attributs valides pour cette dÃ©claration sont '{1}'. Tous les attributs de ce bloc seront ignorÃ©s.GCeci n'est pas un emplacement d'attribut valide pour cette dÃ©clarationÀLes attributs ciblÃ©s par des champs sur les propriÃ©tÃ©s automatiques ne sont pas pris en charge dans la version de langage {0}. Utilisez la version de langage {1} ou une version ultÃ©rieure.€Les attributs ciblÃ©s par des champs sur les propriÃ©tÃ©s automatiques ne sont pas pris en charge dans cette version du langage.›PossibilitÃ© d'une comparaison de rÃ©fÃ©rences involontaireÂ ; pour obtenir une comparaison de valeurs, effectuez un cast de la partie gauche en type '{0}'bPossibilitÃ© d'une comparaison de rÃ©fÃ©rences involontaireÂ ; la partie gauche a besoin d'un cast›PossibilitÃ© d'une comparaison de rÃ©fÃ©rences involontaireÂ ; pour obtenir une comparaison de valeurs, effectuez un cast de la partie droite en type '{0}'bPossibilitÃ© d'une comparaison de rÃ©fÃ©rences involontaireÂ ; la partie droite a besoin d'un castXImpossible de restaurer un avertissement 'CS{0}', car il a Ã©tÃ© dÃ©sactivÃ© globalementnDÃ©solÃ©... Nous ne pouvons pas restaurer les avertissements, car ils ont Ã©tÃ© dÃ©sactivÃ©s de faÃ§on globale(Le nom de langue '{0}' n'est pas valide.&Le nom de ce langage n'est pas correct1'{0}' n'est pas un numÃ©ro d'avertissement valide²Un numÃ©ro transmis Ã  la directive de prÃ©processeur d'avertissement #pragma n'est pas correct. Veuillez vÃ©rifier que ce numÃ©ro reprÃ©sente un avertissement et non une erreur.!NumÃ©ro d'avertissement incorrect@Impossible de rÃ©soudre l'attribut cref '{0}' du commentaire XMLWType non valide pour le paramÃ¨tre {0} dans l'attribut cref du commentaire XMLÂ : '{1}'JType non valide pour le paramÃ¨tre dans l'attribut cref du commentaire XMLAType de retour non valide dans l'attribut cref de commentaire XMLAType de retour non valide dans l'attribut cref de commentaire XMLELa syntaxe de l'attribut cref '{0}' du commentaire XML est incorrecteNLe commentaire XML comporte une erreur de syntaxe au niveau de l'attribut crefRL'attribut cref '{0}' du commentaire XML fait rÃ©fÃ©rence Ã  un paramÃ¨tre de typeZLe commentaire XML possÃ¨de un attribut cref qui fait rÃ©fÃ©rence Ã  un paramÃ¨tre de typeLDÃ©solÃ©... Nous ne pouvons pas rÃ©soudre l'attribut cref du commentaire XMLtOpÃ©rateur de bits or utilisÃ© sur un opÃ©rande de signe Ã©tenduÂ ; effectuez un cast en type plus faible non signÃ©ÃLe compilateur a Ã©tendu une variable et son signe de faÃ§on implicite, avant d'utiliser la valeur obtenue dans une opÃ©ration OR au niveau du bit. Ceci peut entraÃ®ner un comportement inattendu.IOpÃ©rateur OU au niveau du bit utilisÃ© sur un opÃ©rande de signe Ã©tendu»L'utilisation de '{0}' en tant que valeur ref ou out, ou la prise de son adresse, peut provoquer une exception runtime, car il s'agit d'un champ d'une classe de marshaling par rÃ©fÃ©rence£L'utilisation d'un champ d'une classe de marshaling par rÃ©fÃ©rence en tant que valeur ref ou out, ou la prise de son adresse, peut provoquer une exception runtime•Appelez System.IDisposable.Dispose() au niveau de l'instance allouÃ©e de {0} avant que toutes les rÃ©fÃ©rences s'y rapportant soient hors de portÃ©e.‡Appelez System.IDisposable.Dispose() sur l'instance allouÃ©e avant que toutes les rÃ©fÃ©rences pointant vers lui soient hors de portÃ©eÍL'instance allouÃ©e de {0} n'a pas Ã©tÃ© supprimÃ©e dans tous les chemins d'accÃ¨s d'exception. Appelez System.IDisposable.Dispose() avant que toutes les rÃ©fÃ©rences s'y rapportant soient hors de portÃ©e.ZL'instance allouÃ©e n'a pas Ã©tÃ© supprimÃ©e dans tous les chemins d'accÃ¨s de l'exception2L'objet '{0}' peut Ãªtre supprimÃ© plusieurs fois.+L'objet peut Ãªtre supprimÃ© plusieurs foisQL'utilisation de tableaux en tant qu'arguments d'attributs n'est pas conforme CLSQL'utilisation de tableaux en tant qu'arguments d'attributs n'est pas conforme CLS_'Impossible de marquer '{0}' comme conforme CLS, car l'assembly n'a pas d'attribut CLSCompliantG'{0}' n'a pas besoin d'attribut CLSCompliant, car l'assembly n'en a pasnLe type ou le membre n'a pas besoin d'un attribut CLSCompliant, car l'assembly n'a pas d'attribut CLSCompliantuVous ne pouvez pas indiquer que le type ou le membre est conforme CLS, car l'assembly n'a pas d'attribut CLSCompliant/Le type d'argument '{0}' n'est pas conforme CLS)Le type d'argument n'est pas conforme CLSV'{0}' n'a aucun constructeur accessible qui utilise uniquement des types conformes CLSWLe type n'a pas de constructeur accessible utilisant uniquement des types conformes CLS5'{0}'Â : le type de base '{1}' n'est pas conforme CLS‘Un type de base est marquÃ© comme n'ayant pas besoin d'Ãªtre conforme CLS dans un assembly marquÃ© comme devant Ãªtre conforme CLS. Veuillez supprimer l'attribut indiquant que l'assembly est conforme CLS ou supprimer l'attribut indiquant que le type n'est pas conforme CLS.&Le type de base n'est pas conforme CLS'Le type de '{0}' n'est pas conforme CLS]Le type d'une variable publique, protÃ©gÃ©e ou protÃ©gÃ©e en interne doit Ãªtre conforme CLS. Le type nâ€™est pas conforme CLS-L'identificateur '{0}' n'est pas conforme CLSXL'identificateur '{0}', qui se diffÃ©rencie uniquement dans case, n'est pas conforme CLSTUn identificateur qui se diffÃ©rencie uniquement par la casse n'est pas conforme CLS'L'identificateur n'est pas conforme CLSR'{0}' n'est pas conforme CLS, car l'interface de base '{1}' n'est pas conforme CLSX'{0}'Â : les interfaces conformes CLS doivent avoir uniquement des membres conformes CLSOLes interfaces conformes CLS doivent uniquement avoir des membres conformes CLSNLe type n'est pas conforme CLS, car l'interface de base n'est pas conforme CLS1Le type de retour de '{0}' n'est pas conforme CLS(Le type de retour n'est pas conforme CLS2Le type de contrainte '{0}' n'est pas conforme CLS,Le type de contrainte n'est pas conforme CLSi'Impossible de marquer '{0}' comme conforme CLS, car il s'agit d'un membre de type '{1}' non conforme CLS`Impossible d'indiquer que ce type est conforme CLS, car il est membre d'un type non conforme CLS†L'attribut CLSCompliant n'a pas de sens lorsqu'il est appliquÃ© Ã  des paramÃ¨tres. Essayez de le placer dans la mÃ©thode Ã  la place.RL'attribut CLSCompliant n'a pas de sens lorsqu'il est appliquÃ© Ã  des paramÃ¨tressLa vÃ©rification de conformitÃ© CLS ne sera pas effectuÃ©e sur '{0}', car il n'est pas visible hors de cet assemblyxLa vÃ©rification de conformitÃ© CLS ne sera pas effectuÃ©e, car l'objet inspectÃ© n'est pas visible hors de cet assemblyŠL'attribut CLSCompliant n'a pas de sens lorsqu'il est appliquÃ© Ã  des types de retour. Essayez de le placer dans la mÃ©thode Ã  la place.VL'attribut CLSCompliant n'a pas de sens lorsqu'il est appliquÃ© Ã  des types de retourhLes modules ajoutÃ©s doivent Ãªtre marquÃ©s avec l'attribut CLSCompliant pour correspondre Ã  l'assemblyhLes modules ajoutÃ©s doivent Ãªtre marquÃ©s avec l'attribut CLSCompliant pour correspondre Ã  l'assembly?'{0}'Â : seuls les membres conformes CLS peuvent Ãªtre abstract7Seuls les membres conformes CLS peuvent Ãªtre abstraitsQLes mÃ©thodes qui possÃ¨dent des arguments de variables ne sont pas conformes CLSQLes mÃ©thodes qui possÃ¨dent des arguments de variables ne sont pas conformes CLS„Vous devez spÃ©cifier l'attribut CLSCompliant sur l'assembly, non sur le module, pour activer la vÃ©rification de la conformitÃ© CLSyVous ne pouvez pas spÃ©cifier l'attribut CLSCompliant sur un module qui diffÃ¨re de l'attribut CLSCompliant de l'assemblyyVous ne pouvez pas spÃ©cifier l'attribut CLSCompliant sur un module qui diffÃ¨re de l'attribut CLSCompliant de l'assembly„Vous devez spÃ©cifier l'attribut CLSCompliant sur l'assembly, non sur le module, pour activer la vÃ©rification de la conformitÃ© CLSƒLa mÃ©thode surchargÃ©e '{0}', qui se diffÃ©rencie uniquement au niveau de ref ou out ou du rang de tableau, n'est pas conforme CLS{La mÃ©thode surchargÃ©e qui se diffÃ©rencie uniquement au niveau de ref ou out ou du rang de tableau n'est pas conforme CLSwLa mÃ©thode surchargÃ©e '{0}', qui se diffÃ©rencie uniquement par les types de tableau sans nom, n'est pas conforme CLS¶Cette erreur survient si vous avez une mÃ©thode surchargÃ©e qui prend un tableau en escalier et que la seule diffÃ©rence entre les signatures de mÃ©thode est le type d'Ã©lÃ©ment du tableau. Pour Ã©viter cette erreur, nous vous conseillons les mÃ©thodes suivantesÂ : utilisez un tableau rectangulaire plutÃ´t qu'un tableau en escalier, utilisez un paramÃ¨tre supplÃ©mentaire pour supprimer l'ambiguÃ¯tÃ© de l'appel de fonction, renommez une ou plusieurs des mÃ©thodes surchargÃ©es ou, si la conformitÃ© CLS est facultative, supprimez l'attribut CLSCompliantAttribute.qLa mÃ©thode surchargÃ©e, qui se diffÃ©rencie uniquement par les types de tableau sans nom, n'est pas conforme CLS6Le champ conforme CLS '{0}' ne peut pas Ãªtre volatile0Le champ conforme CLS ne peut pas Ãªtre volatile—Cette combinaison d'arguments pour '{0}' peut exposer les variables rÃ©fÃ©rencÃ©es par le paramÃ¨tre '{1}' en dehors de la portÃ©e de leur dÃ©claration‹Cette combinaison d'arguments pour peut exposer les variables rÃ©fÃ©rencÃ©es par le paramÃ¨tre en dehors de la portÃ©e de leur dÃ©clarationŠL'accÃ¨s Ã  un membre de '{0}' peut occasionner une exception runtime, car il s'agit d'un champ d'une classe de marshaling par rÃ©fÃ©renceòCet avertissement survient lorsque vous essayez d'appeler une mÃ©thode, une propriÃ©tÃ© ou un indexeur sur le membre d'une classe dÃ©rivant de MarshalByRefObject, et que ce membre est un type de valeur. Les objets hÃ©ritant de MarshalByRefObject doivent gÃ©nÃ©ralement Ãªtre marshalÃ©s par rÃ©fÃ©rence dans un domaine d'application. Si un code tente d'accÃ©der directement au membre de type valeur d'un tel objet dans un domaine d'application, cela entraÃ®ne une exception de runtime. Pour rÃ©soudre cet avertissement, veuillez d'abord copier le membre dans une variable locale, avant d'appeler la mÃ©thode sur cette variable.vL'accÃ¨s Ã  un membre sur le champ d'une classe de marshaling par rÃ©fÃ©rence peut entraÃ®ner une exception de runtime“Le CallerArgumentExpressionAttribute appliquÃ© au paramÃ¨tre Â« {0} Â» nâ€™aura aucun effet. Il est appliquÃ© avec un nom de paramÃ¨tre non valide.UCallerArgumentExpressionAttribute est appliquÃ© avec un nom de paramÃ¨tre non valide.Le CallerArgumentExpressionAttribute appliquÃ© au paramÃ¨tre Â«Â {0}Â Â» '*nâ€™aura aucun effet, car il est auto-rÃ©fÃ©rentiel.qLe CallerArgumentExpressionAttribute appliquÃ© au paramÃ¨tre nâ€™aura aucun effet, car il est auto-rÃ©fÃ©rentiel.¿CallerArgumentExpressionAttribute, appliquÃ© au paramÃ¨tre '{0}', n'aura aucun effet, car il s'applique Ã  un membre utilisÃ© dans des contextes qui n'autorisent pas les arguments facultatifsCallerArgumentExpressionAttribute n'aura pas d'effet, car il s'applique Ã  un membre utilisÃ© dans des contextes qui n'autorisent pas d'arguments facultatifs½CallerFilePathAttribute, qui est appliquÃ© au paramÃ¨tre '{0}', n'aura aucun effet, car il s'applique Ã  un membre utilisÃ© dans des contextes qui n'autorisent pas les arguments facultatifs“CallerFilePathAttribute n'aura pas d'effet, car il s'applique Ã  un membre utilisÃ© dans des contextes qui n'autorisent pas d'arguments facultatifs‹CallerArgumentExpressionAttribute, qui est appliquÃ© au paramÃ¨tre '{0}', n'aura aucun effet. Il est remplacÃ© par CallerFilePathAttribute.dCallerArgumentExpressionAttribute n'aura pas d'effetÂ ; il est remplacÃ© par CallerFilePathAttributeƒCallerMemberNameAttribute, qui est appliquÃ© au paramÃ¨tre '{0}', n'aura aucun effet. Il est remplacÃ© par CallerFilePathAttribute.\CallerMemberNameAttribute n'aura pas d'effetÂ ; il est remplacÃ© par CallerFilePathAttribute¿CallerLineNumberAttribute, qui est appliquÃ© au paramÃ¨tre '{0}', n'aura aucun effet, car il s'applique Ã  un membre utilisÃ© dans des contextes qui n'autorisent pas les arguments facultatifs•CallerLineNumberAttribute n'aura pas d'effet, car il s'applique Ã  un membre utilisÃ© dans des contextes qui n'autorisent pas d'arguments facultatifsCallerArgumentExpressionAttribute, qui est appliquÃ© au paramÃ¨tre '{0}', n'aura aucun effet. Il est remplacÃ© par CallerLineNumberAttribute.fCallerArgumentExpressionAttribute n'aura pas d'effetÂ ; il est remplacÃ© par CallerLineNumberAttributeƒCallerFilePathAttribute, qui est appliquÃ© au paramÃ¨tre '{0}', n'aura aucun effet. Il est remplacÃ© par CallerLineNumberAttribute.\CallerFilePathAttribute n'aura pas d'effetÂ ; il est remplacÃ© par CallerLineNumberAttribute…CallerMemberNameAttribute, qui est appliquÃ© au paramÃ¨tre '{0}', n'aura aucun effet. Il est remplacÃ© par CallerLineNumberAttribute.^CallerMemberNameAttribute n'aura pas d'effetÂ ; il est remplacÃ© par CallerLineNumberAttribute·CallerMemberNameAttribute, appliquÃ© au paramÃ¨tre '{0}', n'aura aucun effet, car il s'applique Ã  un membre utilisÃ© dans des contextes qui n'autorisent pas les arguments facultatifs•CallerMemberNameAttribute n'aura pas d'effet, car il s'applique Ã  un membre utilisÃ© dans des contextes qui n'autorisent pas d'arguments facultatifsCallerArgumentExpressionAttribute, qui est appliquÃ© au paramÃ¨tre '{0}', n'aura aucun effet. Il est remplacÃ© par CallerMemberNameAttribute.fCallerArgumentExpressionAttribute n'aura pas d'effetÂ ; il est remplacÃ© par CallerMemberNameAttribute[Option /win32manifest ignorÃ©e pour le module, car elle s'applique uniquement aux assemblys[Option /win32manifest ignorÃ©e pour le module, car elle s'applique uniquement aux assemblys¼ParamÃ¨tre '{0}' est capturÃ© dans lâ€™Ã©tat du type englobant et sa valeur est Ã©galement passÃ©e au constructeur de base. La valeur peut Ã©galement Ãªtre capturÃ©e par la classe de base.¹Un paramÃ¨tre est capturÃ© dans lâ€™Ã©tat du type englobant et sa valeur est Ã©galement passÃ©e au constructeur de base. La valeur peut Ã©galement Ãªtre capturÃ©e par la classe de base.®Le nom '_' fait rÃ©fÃ©rence Ã  la constante, pas au modÃ¨le d'abandon. Utilisez 'var _' pour abandonner la valeur, ou '@_' pour faire rÃ©fÃ©rence Ã  une constante par ce nom.+N'utilisez pas '_' pour une constante case.fL'option '{0}' se substitue Ã  l'attribut '{1}' spÃ©cifiÃ© dans un fichier source ou un module ajoutÃ©¯Cet avertissement survient si les attributs de l'assembly AssemblyKeyFileAttribute ou AssemblyKeyNameAttribute trouvÃ©s dans la source entrent en conflit avec l'option de ligne de commande /keyfile ou /keycontainer ou le nom de fichier clÃ© ou le conteneur clÃ© indiquÃ© dans les propriÃ©tÃ©s du projet.ZL'option se substitue Ã  l'attribut spÃ©cifiÃ© dans un fichier source ou un module ajoutÃ©?La comparaison avec null de type '{0}' produit toujours 'false'@La comparaison avec null de type struct produit toujours 'false'R'Interface '{0}' marquÃ©e avec 'CoClassAttribute' et non avec 'ComImportAttribute'KInterface marquÃ©e avec 'CoClassAttribute' et non avec 'ComImportAttribute'XComparaison effectuÃ©e avec la mÃªme variableÂ ; souhaitiez-vous comparer autre choseÂ ?-Comparaison effectuÃ©e avec la mÃªme variableoL'opÃ©ration peut dÃ©passer {0}' au moment de l'exÃ©cution (utilisez la syntaxe 'unchecked' pour passer outre).jL'opÃ©ration peut dÃ©border au moment de l'exÃ©cution (utilisez la syntaxe 'unchecked' pour passer outre).8Valeurs de checksum diffÃ©rentes spÃ©cifiÃ©es pour '{0}':Valeurs de checksum diffÃ©rentes spÃ©cifiÃ©es pour #pragma=L'assembly rÃ©fÃ©rencÃ© '{0}' cible un processeur diffÃ©rent.6L'assembly rÃ©fÃ©rencÃ© cible un processeur diffÃ©rentLa valeur de constante '{0}' peut dÃ©passer '{1}' au moment de l'exÃ©cution (utilisez la syntaxe 'unchecked' pour la remplacer)}DÃ©passement possible de la valeur de constante au moment de l'exÃ©cution (utilisez la syntaxe 'unchecked' pour la remplacer)dConversion de littÃ©ral ayant une valeur null ou d'une Ã©ventuelle valeur null en type non-nullable.dConversion de littÃ©ral ayant une valeur null ou d'une Ã©ventuelle valeur null en type non-nullable.tLe nom qualifiÃ© complet de '{0}' est trop long pour les informations de dÃ©bogage. Compilez sans l'option '/debug'.?Le nom complet est trop long pour les informations de dÃ©bogageºLa valeur par dÃ©faut spÃ©cifiÃ©e pour le paramÃ¨tre '{0}' n'aura aucun effet, car elle s'applique Ã  un membre utilisÃ© dans des contextes qui n'autorisent pas les arguments facultatifs´La valeur par dÃ©faut spÃ©cifiÃ©e pour le paramÃ¨tre n'aura aucun effet, car elle s'applique Ã  un membre utilisÃ© dans des contextes qui n'autorisent pas les arguments facultatifsXNom non valide pour un symbole de prÃ©traitement. '{0}' est un identificateur non valideKNom non valide pour un symbole de prÃ©traitement. Identificateur non valide|La signature diffÃ©rÃ©e a Ã©tÃ© spÃ©cifiÃ©e et nÃ©cessite une clÃ© publique, mais aucune clÃ© publique n'a Ã©tÃ© spÃ©cifiÃ©e|La signature diffÃ©rÃ©e a Ã©tÃ© spÃ©cifiÃ©e et nÃ©cessite une clÃ© publique, mais aucune clÃ© publique n'a Ã©tÃ© spÃ©cifiÃ©efLa meilleure mÃ©thode Add surchargÃ©e '{0}' pour l'Ã©lÃ©ment initialiseur de collection est obsolÃ¨te.jLa meilleure mÃ©thode Add surchargÃ©e '{0}' pour l'Ã©lÃ©ment initialiseur de collection est obsolÃ¨te. {1}_La meilleure mÃ©thode Add surchargÃ©e pour l'Ã©lÃ©ment initialiseur de collection est obsolÃ¨te_La meilleure mÃ©thode Add surchargÃ©e pour l'Ã©lÃ©ment initialiseur de collection est obsolÃ¨te'{0}' est obsolÃ¨te'{0}' est obsolÃ¨teÂ : '{1}'"Le type ou le membre est obsolÃ¨te"Le type ou le membre est obsolÃ¨tegImpossible d'utiliser une Ã©ventuelle valeur null pour un type marquÃ© avec [NotNull] ou [DisallowNull]gImpossible d'utiliser une Ã©ventuelle valeur null pour un type marquÃ© avec [NotNull] ou [DisallowNull]La comparaison des pointeurs de fonction peut donner un rÃ©sultat inattendu, car les pointeurs vers la mÃªme fonction peuvent Ãªtre distincts.5Ne pas comparer les valeurs des pointeurs de fonctionlLa mÃ©thode '{0}' n'a pas d'annotation '[DoesNotReturn]' correspondant au membre implÃ©mentÃ© ou substituÃ©.fLa mÃ©thode n'a pas d'annotation '[DoesNotReturn]' correspondant au membre implÃ©mentÃ© ou substituÃ©.pL'expression fera toujours intervenir System.NullReferenceException, car la valeur par dÃ©faut de '{0}' est nulloL'expression fera toujours intervenir System.NullReferenceException, car la valeur par dÃ©faut du type est null=RÃ©fÃ©rence de lâ€™analyseur '{0}' spÃ©cifiÃ©e plusieurs fois7RÃ©fÃ©rence de lâ€™analyseur spÃ©cifiÃ©e plusieurs fois„'{0}' figure dÃ©jÃ  dans la liste des interfaces du type '{1}' avec diffÃ©rentes possibilitÃ©s de valeur null des types rÃ©fÃ©rence.|L'interface figure dÃ©jÃ  dans la liste des interfaces avec diffÃ©rentes possibilitÃ©s de valeur null des types rÃ©fÃ©rence.:Le commentaire XML a une balise param en double pour '{0}'/Le commentaire XML a une balise param en double>Le commentaire XML a une balise typeparam en double pour '{0}'3Le commentaire XML a une balise typeparam en doubleNLa directive using de '{0}' est apparue prÃ©cÃ©demment dans cet espace de nomsELa directive using est apparue prÃ©cÃ©demment dans cet espace de noms®L'appel dispatchÃ© dynamiquement Ã  la mÃ©thode '{0}' peut Ã©chouer au moment de l'exÃ©cution, car une ou plusieurs surcharges applicables sont des mÃ©thodes conditionnelles.˜L'appel dispatchÃ© dynamiquement peut Ã©chouer au moment de l'exÃ©cution, car une ou plusieurs surcharges applicables sont des mÃ©thodes conditionnellesBloc switch videBloc switch vide8Commentaire sur une seule ligne ou fin de ligne attendueTCommentaire sur une seule ligne ou fin de ligne attendue aprÃ¨s la directive #pragmae'{0}' dÃ©finit l'opÃ©rateur == ou l'opÃ©rateur != mais ne se substitue pas Ã  Object.Equals(object o)gLe type dÃ©finit l'opÃ©rateur == ou l'opÃ©rateur != mais ne se substitue pas Ã  Object.Equals(object o)b'{0}' dÃ©finit l'opÃ©rateur == ou l'opÃ©rateur != mais ne se substitue pas Ã  Object.GetHashCode()dLe type dÃ©finit l'opÃ©rateur == ou l'opÃ©rateur != mais ne se substitue pas Ã  Object.GetHashCode()N'{0}' se substitue Ã  Object.Equals(object o) mais pas Ã  Object.GetHashCode()PLe type se substitue Ã  Object.Equals(object o) mais pas Ã  Object.GetHashCode(){0}. Voir aussi l'erreur CS{1}.«Le compilateur Ã©met cet avertissement lorsqu'il remplace une erreur par un avertissement. Pour plus d'informations sur ce problÃ¨me, recherchez le code d'erreur indiquÃ©.#L'avertissement remplace une erreurUtiliser un rÃ©sultat de '{0}' dans ce contexte peut exposer les variables rÃ©fÃ©rencÃ©es par le paramÃ¨tre '{1}' en dehors de la portÃ©e de leur dÃ©claration¨Utiliser un membre du rÃ©sultat de '{0}' dans ce contexte peut exposer les variables rÃ©fÃ©rencÃ©es par le paramÃ¨tre '{1}' en dehors de la portÃ©e de leur dÃ©claration™Utiliser un membre du rÃ©sultat dans ce contexte peut exposer les variables rÃ©fÃ©rencÃ©es par le paramÃ¨tre en dehors de la portÃ©e de leur dÃ©clarationUtiliser un rÃ©sultat dans ce contexte peut exposer les variables rÃ©fÃ©rencÃ©es par le paramÃ¨tre en dehors de la portÃ©e de leur dÃ©claration}Un rÃ©sultat d'une expression stackalloc de type '{0}' dans ce contexte peut Ãªtre exposÃ© en dehors de la mÃ©thode conteneurzUn rÃ©sultat d'une expression stackalloc de ce type dans ce contexte peut Ãªtre exposÃ© en dehors de la mÃ©thode conteneur€Utiliser la variable '{0}' dans ce contexte peut exposer des variables de rÃ©fÃ©rence en dehors de leur Ã©tendue de dÃ©clarationzUtiliser la variable dans ce contexte peut exposer des variables de rÃ©fÃ©rence en dehors de leur Ã©tendue de dÃ©claration‡'{0}' est utilisÃ© Ã  des fins d'Ã©valuation uniquement. Il sera peut-Ãªtre changÃ© ou supprimÃ© au cours des prochaines mises Ã  jour.‰Le type est utilisÃ© Ã  des fins d'Ã©valuation uniquement. Il sera peut-Ãªtre changÃ© ou supprimÃ© au cours des prochaines mises Ã  jour.ÉL'implÃ©mentation d'interface explicite '{0}' correspond Ã  plusieurs membres d'interface. Le membre d'interface choisi dÃ©pend de l'implÃ©mentation. Utilisez plutÃ´t une implÃ©mentation non explicite.SL'implÃ©mentation d'interface explicite correspond Ã  plusieurs membres d'interface0Le constructeur '{0}' est marquÃ© comme external*Le constructeur est marquÃ© comme external©La mÃ©thode, l'opÃ©rateur ou l'accesseur '{0}' est marquÃ© comme external et n'a pas d'attribut. Ajoutez un attribut DllImport pour spÃ©cifier l'implÃ©mentation externe.YLa mÃ©thode, l'opÃ©rateur ou l'accesseur est marquÃ© comme external et n'a pas d'attributBImpossible d'inclure le fragment XML '{1}' du fichier '{0}' -- {2}$Impossible d'inclure le fragment XML,Fichier source '{0}' indiquÃ© plusieurs fois3Le fichier source a Ã©tÃ© spÃ©cifiÃ© plusieurs fois~Nom de fichier spÃ©cifiÃ© non valide pour la directive de prÃ©processeur. Le nom de fichier est trop long ou n'est pas valide.HNom de fichier spÃ©cifiÃ© non valide pour la directive de prÃ©processeurML'expression de filtre est une constante 'false'Â ; supprimez la clause catchOL'expression de filtre est une constante 'false'Â ; supprimez le bloc try-catch1L'expression de filtre est une constante 'false'.0L'expression de filtre est une constante 'false'PL'expression de filtre est une constante 'true'Â ; songez Ã  supprimer le filtre/L'expression de filtre est une constante 'true'€L'introduction d'une mÃ©thode 'Finalize' peut interfÃ©rer avec un appel destructeur. Souhaitiez-vous dÃ©clarer un destructeurÂ ?ÂCet avertissement survient lorsque vous crÃ©ez une classe avec une mÃ©thode dont la signature est public virtual void Finalize.

Si une telle classe est utilisÃ©e en tant que classe de base et si la classe dÃ©rivÃ©e dÃ©finit un destructeur, celui-ci remplacera la mÃ©thode Finalize de la classe de base, et non Finalize.SL'introduction d'une mÃ©thode 'Finalize' peut interfÃ©rer avec un appel destructeurÓLe gÃ©nÃ©rateur '{0}' n'a pas pu gÃ©nÃ©rer la source. Dans la mesure oÃ¹ il ne va pas contribuer Ã  la sortie, des erreurs de compilation peuvent se produire. Exception levÃ©e de type '{1}' avec le message '{2}'7Le gÃ©nÃ©rateur a levÃ© l'exception suivanteÂ :
'{0}'./Le gÃ©nÃ©rateur n'a pas pu gÃ©nÃ©rer la source.ÏÃ‰chec de l'initialisation du gÃ©nÃ©rateur '{0}'. Dans la mesure oÃ¹ il ne va pas contribuer Ã  la sortie, des erreurs de compilation peuvent se produire. Exception levÃ©e de type '{1}' avec le message '{2}'7Le gÃ©nÃ©rateur a levÃ© l'exception suivanteÂ :
'{0}'.+Ã‰chec de l'initialisation du gÃ©nÃ©rateur.AL'expression donnÃ©e correspond toujours Ã  la constante fournie.AL'expression donnÃ©e correspond toujours Ã  la constante fournie.;L'expression donnÃ©e correspond toujours au modÃ¨le fourni.;L'expression donnÃ©e correspond toujours au modÃ¨le fourni.<L'expression donnÃ©e ne correspond jamais au modÃ¨le fourni.<L'expression donnÃ©e ne correspond jamais au modÃ¨le fourni.ªLa dÃ©finition d'un alias nommÃ© 'global' n'est pas trÃ¨s judicieuse dans la mesure oÃ¹ 'global::' fait toujours rÃ©fÃ©rence Ã  l'espace de noms global et non Ã  un alias@La dÃ©finition d'un alias nommÃ© 'global' n'est pas recommandÃ©eGLa valeur 'goto case' n'est pas implicitement convertible en type '{0}'HLa valeur 'goto case' n'est pas implicitement convertible en type switch/Identificateur ou littÃ©ral numÃ©rique attendu..Identificateur ou littÃ©ral numÃ©rique attendu†Syntaxe de #pragma checksum non valideÂ ; doit Ãªtre #pragma checksum "nom_fichier" "{XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX}" "XXXX..."&Syntaxe de checksum #pragma incorrecte'disable' ou 'restore' attendu='disable' ou 'restore' attendu aprÃ¨s l'avertissement #pragmaDirective #pragma non reconnueDirective #pragma non reconnuelL'appel au membre '{0}' non readonly Ã  partir d'un membre 'readonly' gÃ©nÃ¨re une copie implicite de '{1}'.]L'appel au membre non readonly Ã  partir d'un membre 'readonly' gÃ©nÃ¨re une copie implicite.qL'assignation dans une expression conditionnelle est toujours constanteÂ ; voulez-vous utiliser == au lieu de = ?GL'assignation dans une expression conditionnelle est toujours constante’InterpolatedStringHandlerArgument nâ€™a aucun effet lorsquâ€™il est appliquÃ© aux paramÃ¨tres lambda et quâ€™il est ignorÃ© sur le site dâ€™appel.’InterpolatedStringHandlerArgument nâ€™a aucun effet lorsquâ€™il est appliquÃ© aux paramÃ¨tres lambda et quâ€™il est ignorÃ© sur le site dâ€™appel.NLa rÃ©fÃ©rence d'assembly '{0}' n'est pas valide et ne peut pas Ãªtre rÃ©solueuCet avertissement indique qu'un attribut, tel que InternalsVisibleToAttribute, n'a pas Ã©tÃ© spÃ©cifiÃ© correctement.HLa rÃ©fÃ©rence d'assembly n'est pas valide et ne peut pas Ãªtre rÃ©solueª'{0}' n'est pas un emplacement d'attribut reconnu. Les emplacements d'attributs valides pour cette dÃ©claration sont '{1}'. Tous les attributs de ce bloc seront ignorÃ©s.,Cet emplacement d'attribut n'est pas reconnu'Ã‰lÃ©ment include XML non valide -- {0}Ã‰lÃ©ment include XML incorrectD'{0}' n'a pas la signature appropriÃ©e pour Ãªtre un point d'entrÃ©eJLa mÃ©thode n'a pas la signature appropriÃ©e pour Ãªtre un point d'entrÃ©eNombre non valideNombre non valideCChemin de recherche '{0}' non valide spÃ©cifiÃ© dans '{1}' -- '{2}'3Le chemin de recherche spÃ©cifiÃ© n'est pas correctoLa chaÃ®ne de version spÃ©cifiÃ©e '{0}' nâ€™est pas conforme au format recommandÃ© : major.minor.build.revisionoLe format de la chaÃ®ne de version spÃ©cifiÃ©e n'est pas conforme au format requis - major.minor.build.revision8L'expression donnÃ©e n'est jamais du type fourni ('{0}')F'L'expression donnÃ©e de l'expression 'is' n'est jamais du type fourni8L'expression donnÃ©e est toujours du type fourni ('{0}')F'L'expression donnÃ©e de l'expression 'is' est toujours du type fourni·L'utilisation de '{0}' pour tester la compatibilitÃ© avec '{1}' est fondamentalement identique au test de la compatibilitÃ© avec '{2}' et elle aboutit pour toutes les valeurs non nullŒL'utilisation de 'is' pour tester la compatibilitÃ© avec 'dynamic' est fondamentalement identique au test de la compatibilitÃ© avec 'Object'CUne expression de type '{0}' correspond toujours au modÃ¨le fourni.0L'entrÃ©e correspond toujours au modÃ¨le fourni.|Le nom '_' fait rÃ©fÃ©rence au type '{0}', pas au modÃ¨le d'abandon. Utilisez '@_' pour le type, ou 'var _' pour abandonner.NN'utilisez pas '_' pour faire rÃ©fÃ©rence au type dans une expression is-type.…Le nom de type '{0}' contient uniquement des caractÃ¨res ascii en minuscules. De tels noms peuvent devenir rÃ©servÃ©s pour la langue.Le nom de type contient uniquement des caractÃ¨res ascii en minuscules. De tels noms peuvent devenir rÃ©servÃ©s pour la langue.]Le suffixe 'l' risque d'Ãªtre facilement confondu avec le chiffre '1' -- utilisez plutÃ´t 'L'ELe suffixe 'l' risque d'Ãªtre facilement confondu avec le chiffre '1'R'{0}'Â : un point d'entrÃ©e ne peut pas Ãªtre gÃ©nÃ©rique ou d'un type gÃ©nÃ©riqueIUn point d'entrÃ©e ne peut pas Ãªtre gÃ©nÃ©rique ou d'un type gÃ©nÃ©riqueTLe point d'entrÃ©e du programme est du code globalÂ ; point d'entrÃ©e '{0}' ignorÃ©.TLe point d'entrÃ©e du programme est du code globalÂ ; ce point d'entrÃ©e est ignorÃ©_Peut prendre l'adresse, obtenir la taille ou dÃ©clarer un pointeur vers un type managÃ© ('{0}')WPeut prendre l'adresse, obtenir la taille ou dÃ©clarer un pointeur vers un type managÃ©FLe membre '{0}' doit avoir une valeur non null au moment de la sortie.=Le membre '{0}' ne peut pas Ãªtre utilisÃ© dans cet attribut.7Le membre ne peut pas Ãªtre utilisÃ© dans cet attribut.QLe membre '{0}' doit avoir une valeur non null au moment de la sortie avec '{1}'.ZLe membre doit avoir une valeur non null au moment de la sortie dans certaines conditions.@Le membre doit avoir une valeur non null au moment de la sortie.wImpossible de convertir le groupe de mÃ©thodes '{0}' en type non-dÃ©lÃ©guÃ© '{1}'. Souhaitiez-vous appeler la mÃ©thode?<Conversion dâ€™un groupe de mÃ©thodes en type non-dÃ©lÃ©guÃ©Les branches d'un opÃ©rateur conditionnel ref font rÃ©fÃ©rence Ã  des variables ayant des Ã©tendues de dÃ©claration incompatiblesLes branches d'un opÃ©rateur conditionnel ref font rÃ©fÃ©rence Ã  des variables ayant des Ã©tendues de dÃ©claration incompatiblesL'annotation pour les types rÃ©fÃ©rence Nullable doit Ãªtre utilisÃ©e uniquement dans le code au sein d'un contexte d'annotations '#nullable'.ïL'annotation pour les types rÃ©fÃ©rence Nullable doit Ãªtre utilisÃ©e uniquement dans le code au sein d'un contexte d'annotations '#nullable'. Le code gÃ©nÃ©rÃ© automatiquement nÃ©cessite une directive '#nullable' explicite dans la source.ïL'annotation pour les types rÃ©fÃ©rence Nullable doit Ãªtre utilisÃ©e uniquement dans le code au sein d'un contexte d'annotations '#nullable'. Le code gÃ©nÃ©rÃ© automatiquement nÃ©cessite une directive '#nullable' explicite dans la source.L'annotation pour les types rÃ©fÃ©rence Nullable doit Ãªtre utilisÃ©e uniquement dans le code au sein d'un contexte d'annotations '#nullable'.…Le paramÃ¨tre '{0}' n'a pas de balise param correspondante dans le commentaire XML pour '{1}' (contrairement Ã  d'autres paramÃ¨tres)tLe paramÃ¨tre n'a pas de balise param correspondante dans le commentaire XML (contrairement Ã  d'autres paramÃ¨tres)—Le paramÃ¨tre de type '{0}' n'a pas de balise typeparam correspondante dans le commentaire XML de '{1}' (contrairement Ã  d'autres paramÃ¨tres de type)€Le type de paramÃ¨tre n'a pas de balise typeparam correspondante dans le commentaire XML (contrairement Ã  d'autres paramÃ¨tres)MCommentaire XML manquant pour le type ou le membre visible publiquement '{0}'sL'option de compilateur /doc a Ã©tÃ© spÃ©cifiÃ©e, mais un ou plusieurs constructeurs n'avaient pas de commentaires.GCommentaire XML manquant pour le type ou le membre visible publiquementzLe type prÃ©dÃ©fini '{0}' est dÃ©fini dans plusieurs assemblys de l'alias globalÂ ; utilisation de la dÃ©finition de '{1}'¶Cette erreur survient quand un type de systÃ¨me prÃ©dÃ©fini tel que System.Int32 est trouvÃ© dans deux assemblys. Cela peut se produire quand vous rÃ©fÃ©rencez mscorlib ou System.Runtime.dll depuis deux emplacements diffÃ©rents, comme si vous tentiez d'exÃ©cuter deux versions du .NET Framework cÃ´te Ã  cÃ´te.LUn type prÃ©dÃ©fini est dÃ©fini dans plusieurs assemblys de l'alias globalÂ ØLe membre '{0}' implÃ©mente le membre d'interface '{1}' dans le type '{2}'. Il existe plusieurs correspondances pour le membre d'interface au moment de l'exÃ©cution. La mÃ©thode appelÃ©e dÃ©pend de l'implÃ©mentation.½Cet avertissement peut Ãªtre gÃ©nÃ©rÃ© lorsque deux mÃ©thodes d'interface sont uniquement diffÃ©renciÃ©es si un paramÃ¨tre particulier est marquÃ© avec ref ou avec out. Nous vous recommandons de modifier votre code pour Ã©viter cet avertissement, car la mÃ©thode appelÃ©e au dÃ©marrage n'est ni Ã©vidente, ni garantie.

MÃªme si le langage C# permet de faire la diffÃ©rence entre out et ref, ce n'est pas le cas pour le CLR. Lors du choix de la mÃ©thode d'implÃ©mentation de l'interface, le CLR en sÃ©lectionne simplement une.

Permettez au compilateur de diffÃ©rencier les mÃ©thodes. Par exemple, vous pouvez leur donner diffÃ©rents noms ou fournir un paramÃ¨tre supplÃ©mentaire Ã  l'une d'elles.dUn membre implÃ©mente un membre d'interface avec plusieurs correspondances au moment de l'exÃ©cutionÇLe membre '{1}' se substitue Ã  '{0}'. Il existe plusieurs candidats Ã  la substitution au moment de l'exÃ©cution. La mÃ©thode appelÃ©e dÃ©pend de l'implÃ©mentation. Utilisez un runtime plus rÃ©cent.jUn membre remplace un membre de base avec plusieurs candidats Ã  la substitution au moment de l'exÃ©cutionbIndexation d'un tableau avec un index nÃ©gatif (les index de tableau commencent toujours Ã  zÃ©ro).Indexation d'un tableau avec un index nÃ©gatifZLe membre '{0}' ne masque pas de membre accessible. Le mot clÃ© new n'est pas nÃ©cessaire.NUn membre ne masque pas un membre hÃ©ritÃ©Â ; le mot clÃ© new n'est pas requis¤'{0}' masque le membre hÃ©ritÃ© '{1}'. Pour que le membre actif se substitue Ã  cette implÃ©mentation, ajoutez le mot clÃ© override. Sinon, ajoutez le mot clÃ© new.HUn membre masque un membre hÃ©ritÃ©Â ; le mot clÃ© override est manquant`'{0}' masque le membre hÃ©ritÃ© '{1}'. Utilisez le mot clÃ© new si le masquage est intentionnel.›Une variable a Ã©tÃ© dÃ©clarÃ©e avec le mÃªme nom qu'une variable dans le type de base. Cependant, le mot clÃ© new n'a pas Ã©tÃ© utilisÃ©. Cet avertissement vous informe que vous devez utiliser newÂ ; la variable est dÃ©clarÃ©e comme si new avait Ã©tÃ© utilisÃ© dans la dÃ©claration.CUn membre masque un membre hÃ©ritÃ©Â ; le mot clÃ© new est manquant,L'assembly {0} ne contient pas d'analyseurs.&L'assembly ne contient pas d'analyseurOOption /noconfig ignorÃ©e, car elle Ã©tait spÃ©cifiÃ©e dans un fichier rÃ©ponseOOption /noconfig ignorÃ©e, car elle Ã©tait spÃ©cifiÃ©e dans un fichier rÃ©ponseÊAucune valeur n'a Ã©tÃ© trouvÃ©e pour RuntimeMetadataVersion. Aucun assembly contenant System.Object n'a Ã©tÃ© trouvÃ© et aucune valeur n'a Ã©tÃ© spÃ©cifiÃ©e pour RuntimeMetadataVersion via les options.4Aucune valeur dÃ©tectÃ©e pour RuntimeMetadataVersion Aucun fichier source spÃ©cifiÃ©.Aucun fichier source spÃ©cifiÃ©™La fonctionnalitÃ© '{0}' ne fait pas partie de la spÃ©cification du langage C# ISO standardisÃ©e et peut ne pas Ãªtre acceptÃ©e par d'autres compilateurs¨Cette fonctionnalitÃ© ne fait pas partie de la spÃ©cification du langage C# ISO standardisÃ©eÂ ; il est possible qu'elle ne soit pas acceptÃ©e par d'autres compilateurs]Le membre '{0}' se substitue au membre obsolÃ¨te '{1}'. Ajoutez l'attribut Obsolete Ã  '{0}'.*Un membre se substitue au membre obsolÃ¨teyLe rÃ©sultat de l'expression est toujours '{0}', car une valeur de type '{1}' n'est jamais Ã©gale Ã  'null' du type '{2}'yLe rÃ©sultat de l'expression est toujours '{0}', car une valeur de type '{1}' n'est jamais Ã©gale Ã  'null' du type '{2}'kLe rÃ©sultat de l'expression est toujours le mÃªme, car une valeur de ce type n'est jamais Ã©gale Ã  'null'kLe rÃ©sultat de l'expression est toujours le mÃªme, car une valeur de ce type n'est jamais Ã©gale Ã  'null'\Impossible de convertir un littÃ©ral ayant une valeur null en type rÃ©fÃ©rence non-nullable.\Impossible de convertir un littÃ©ral ayant une valeur null en type rÃ©fÃ©rence non-nullable.YExistence possible d'un argument de rÃ©fÃ©rence null pour le paramÃ¨tre '{0}' dans '{1}'.5Existence possible d'un argument de rÃ©fÃ©rence null.9Existence possible d'une assignation de rÃ©fÃ©rence null.9Existence possible d'une assignation de rÃ©fÃ©rence null.yL'initialiseur d'objet ou de collection dÃ©rÃ©fÃ©rence implicitement le membre susceptible d'avoir une valeur null '{0}'.sL'initialiseur d'objet ou de collection dÃ©rÃ©fÃ©rence implicitement le membre susceptible d'avoir une valeur null.6DÃ©rÃ©fÃ©rencement d'une Ã©ventuelle rÃ©fÃ©rence null.6DÃ©rÃ©fÃ©rencement d'une Ã©ventuelle rÃ©fÃ©rence null.3Existence possible d'un retour de rÃ©fÃ©rence null.3Existence possible d'un retour de rÃ©fÃ©rence null.ÅImpossible d'utiliser l'argument de type '{0}' pour le paramÃ¨tre '{2}' de type '{1}' dans '{3}'. En effet, il existe des diffÃ©rences dans l'acceptation des valeurs null par les types rÃ©fÃ©rence.ØImpossible d'utiliser l'argument de type '{0}' en tant que sortie de type '{1}' pour le paramÃ¨tre '{2}' dans '{3}'. En effet, il existe des diffÃ©rences dans l'acceptation des valeurs null par les types rÃ©fÃ©rence. Impossible d'utiliser l'argument en tant que sortie du paramÃ¨tre, car il existe des diffÃ©rences dans l'acceptation des valeurs null par les types rÃ©fÃ©rence.’Impossible d'utiliser l'argument pour le paramÃ¨tre, car il existe des diffÃ©rences dans l'acceptation des valeurs null par les types rÃ©fÃ©rence.iLa nullabilitÃ© des types rÃ©fÃ©rence dans la valeur de type '{0}' ne correspond pas au type cible '{1}'.ULa nullabilitÃ© des types rÃ©fÃ©rence dans la valeur ne correspond pas au type cible.ÿLa nullabilitÃ© dans les contraintes pour le paramÃ¨tre de type '{0}' de la mÃ©thode '{1}' ne correspond pas aux contraintes pour le paramÃ¨tre de type '{2}' de la mÃ©thode d'interface '{3}'. Utilisez une implÃ©mentation d'interface explicite Ã  la place.¶La nullabilitÃ© dans les contraintes pour le paramÃ¨tre de type ne correspond pas aux contraintes pour le paramÃ¨tre de type dans la mÃ©thode d'interface implÃ©mentÃ©e implicitement.Les dÃ©clarations de mÃ©thodes partielles de '{0}' prÃ©sentent des possibilitÃ©s de valeur null incohÃ©rentes pour le paramÃ¨tre de type '{1}'Les dÃ©clarations de mÃ©thodes partielles prÃ©sentent des possibilitÃ©s de valeur null incohÃ©rentes pour le paramÃ¨tre de type¢Les possibilitÃ©s de valeur null des types rÃ©fÃ©rence dans le spÃ©cificateur d'interface explicite ne correspondent pas Ã  l'interface implÃ©mentÃ©e par le type.¢Les possibilitÃ©s de valeur null des types rÃ©fÃ©rence dans le spÃ©cificateur d'interface explicite ne correspondent pas Ã  l'interface implÃ©mentÃ©e par le type.´'{0}' n'implÃ©mente pas le membre d'interface '{1}'. Les possibilitÃ©s de valeur null des types rÃ©fÃ©rence dans l'interface implÃ©mentÃ©e par le type de base ne correspondent pas.°Le type n'implÃ©mente pas le membre d'interface. Les possibilitÃ©s de valeur null des types rÃ©fÃ©rence dans l'interface implÃ©mentÃ©e par le type de base ne correspondent pas.³La nullabilitÃ© des types rÃ©fÃ©rence dans le type du paramÃ¨tre '{0}' de '{1}' ne correspond pas au dÃ©lÃ©guÃ© cible '{2}' (probablement en raison d